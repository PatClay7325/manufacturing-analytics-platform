
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model DimSite
 * 
 */
export type DimSite = $Result.DefaultSelection<Prisma.$DimSitePayload>
/**
 * Model DimArea
 * 
 */
export type DimArea = $Result.DefaultSelection<Prisma.$DimAreaPayload>
/**
 * Model DimWorkCenter
 * 
 */
export type DimWorkCenter = $Result.DefaultSelection<Prisma.$DimWorkCenterPayload>
/**
 * Model DimEquipment
 * 
 */
export type DimEquipment = $Result.DefaultSelection<Prisma.$DimEquipmentPayload>
/**
 * Model DimProduct
 * 
 */
export type DimProduct = $Result.DefaultSelection<Prisma.$DimProductPayload>
/**
 * Model DimShift
 * 
 */
export type DimShift = $Result.DefaultSelection<Prisma.$DimShiftPayload>
/**
 * Model DimDowntimeReason
 * 
 */
export type DimDowntimeReason = $Result.DefaultSelection<Prisma.$DimDowntimeReasonPayload>
/**
 * Model DimUnit
 * 
 */
export type DimUnit = $Result.DefaultSelection<Prisma.$DimUnitPayload>
/**
 * Model FactProduction
 * 
 */
export type FactProduction = $Result.DefaultSelection<Prisma.$FactProductionPayload>
/**
 * Model FactDowntime
 * 
 */
export type FactDowntime = $Result.DefaultSelection<Prisma.$FactDowntimePayload>
/**
 * Model FactScrap
 * 
 */
export type FactScrap = $Result.DefaultSelection<Prisma.$FactScrapPayload>
/**
 * Model FactMaintenance
 * 
 */
export type FactMaintenance = $Result.DefaultSelection<Prisma.$FactMaintenancePayload>
/**
 * Model FactSensorEvent
 * 
 */
export type FactSensorEvent = $Result.DefaultSelection<Prisma.$FactSensorEventPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AuditEvent
 * 
 */
export type AuditEvent = $Result.DefaultSelection<Prisma.$AuditEventPayload>
/**
 * Model DataDictionary
 * 
 */
export type DataDictionary = $Result.DefaultSelection<Prisma.$DataDictionaryPayload>
/**
 * Model DataRetentionPolicy
 * 
 */
export type DataRetentionPolicy = $Result.DefaultSelection<Prisma.$DataRetentionPolicyPayload>
/**
 * Model QueryPerformance
 * 
 */
export type QueryPerformance = $Result.DefaultSelection<Prisma.$QueryPerformancePayload>
/**
 * Model DataQualityScores
 * 
 */
export type DataQualityScores = $Result.DefaultSelection<Prisma.$DataQualityScoresPayload>
/**
 * Model SystemMetrics
 * 
 */
export type SystemMetrics = $Result.DefaultSelection<Prisma.$SystemMetricsPayload>
/**
 * Model DimDateRange
 * 
 */
export type DimDateRange = $Result.DefaultSelection<Prisma.$DimDateRangePayload>
/**
 * Model OntologyTerm
 * 
 */
export type OntologyTerm = $Result.DefaultSelection<Prisma.$OntologyTermPayload>
/**
 * Model ViewOeeDaily
 * Daily OEE metrics by equipment and shift
 */
export type ViewOeeDaily = $Result.DefaultSelection<Prisma.$ViewOeeDailyPayload>
/**
 * Model ViewReliabilitySummary
 * Equipment reliability summary (MTBF, MTTR)
 */
export type ViewReliabilitySummary = $Result.DefaultSelection<Prisma.$ViewReliabilitySummaryPayload>
/**
 * Model ViewScrapSummary
 * Scrap/quality summary by date, equipment, and product
 */
export type ViewScrapSummary = $Result.DefaultSelection<Prisma.$ViewScrapSummaryPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more DimSites
 * const dimSites = await prisma.dimSite.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more DimSites
   * const dimSites = await prisma.dimSite.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.dimSite`: Exposes CRUD operations for the **DimSite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimSites
    * const dimSites = await prisma.dimSite.findMany()
    * ```
    */
  get dimSite(): Prisma.DimSiteDelegate<ExtArgs>;

  /**
   * `prisma.dimArea`: Exposes CRUD operations for the **DimArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimAreas
    * const dimAreas = await prisma.dimArea.findMany()
    * ```
    */
  get dimArea(): Prisma.DimAreaDelegate<ExtArgs>;

  /**
   * `prisma.dimWorkCenter`: Exposes CRUD operations for the **DimWorkCenter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimWorkCenters
    * const dimWorkCenters = await prisma.dimWorkCenter.findMany()
    * ```
    */
  get dimWorkCenter(): Prisma.DimWorkCenterDelegate<ExtArgs>;

  /**
   * `prisma.dimEquipment`: Exposes CRUD operations for the **DimEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimEquipments
    * const dimEquipments = await prisma.dimEquipment.findMany()
    * ```
    */
  get dimEquipment(): Prisma.DimEquipmentDelegate<ExtArgs>;

  /**
   * `prisma.dimProduct`: Exposes CRUD operations for the **DimProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimProducts
    * const dimProducts = await prisma.dimProduct.findMany()
    * ```
    */
  get dimProduct(): Prisma.DimProductDelegate<ExtArgs>;

  /**
   * `prisma.dimShift`: Exposes CRUD operations for the **DimShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimShifts
    * const dimShifts = await prisma.dimShift.findMany()
    * ```
    */
  get dimShift(): Prisma.DimShiftDelegate<ExtArgs>;

  /**
   * `prisma.dimDowntimeReason`: Exposes CRUD operations for the **DimDowntimeReason** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimDowntimeReasons
    * const dimDowntimeReasons = await prisma.dimDowntimeReason.findMany()
    * ```
    */
  get dimDowntimeReason(): Prisma.DimDowntimeReasonDelegate<ExtArgs>;

  /**
   * `prisma.dimUnit`: Exposes CRUD operations for the **DimUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimUnits
    * const dimUnits = await prisma.dimUnit.findMany()
    * ```
    */
  get dimUnit(): Prisma.DimUnitDelegate<ExtArgs>;

  /**
   * `prisma.factProduction`: Exposes CRUD operations for the **FactProduction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FactProductions
    * const factProductions = await prisma.factProduction.findMany()
    * ```
    */
  get factProduction(): Prisma.FactProductionDelegate<ExtArgs>;

  /**
   * `prisma.factDowntime`: Exposes CRUD operations for the **FactDowntime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FactDowntimes
    * const factDowntimes = await prisma.factDowntime.findMany()
    * ```
    */
  get factDowntime(): Prisma.FactDowntimeDelegate<ExtArgs>;

  /**
   * `prisma.factScrap`: Exposes CRUD operations for the **FactScrap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FactScraps
    * const factScraps = await prisma.factScrap.findMany()
    * ```
    */
  get factScrap(): Prisma.FactScrapDelegate<ExtArgs>;

  /**
   * `prisma.factMaintenance`: Exposes CRUD operations for the **FactMaintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FactMaintenances
    * const factMaintenances = await prisma.factMaintenance.findMany()
    * ```
    */
  get factMaintenance(): Prisma.FactMaintenanceDelegate<ExtArgs>;

  /**
   * `prisma.factSensorEvent`: Exposes CRUD operations for the **FactSensorEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FactSensorEvents
    * const factSensorEvents = await prisma.factSensorEvent.findMany()
    * ```
    */
  get factSensorEvent(): Prisma.FactSensorEventDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.auditEvent`: Exposes CRUD operations for the **AuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditEvents
    * const auditEvents = await prisma.auditEvent.findMany()
    * ```
    */
  get auditEvent(): Prisma.AuditEventDelegate<ExtArgs>;

  /**
   * `prisma.dataDictionary`: Exposes CRUD operations for the **DataDictionary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataDictionaries
    * const dataDictionaries = await prisma.dataDictionary.findMany()
    * ```
    */
  get dataDictionary(): Prisma.DataDictionaryDelegate<ExtArgs>;

  /**
   * `prisma.dataRetentionPolicy`: Exposes CRUD operations for the **DataRetentionPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRetentionPolicies
    * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany()
    * ```
    */
  get dataRetentionPolicy(): Prisma.DataRetentionPolicyDelegate<ExtArgs>;

  /**
   * `prisma.queryPerformance`: Exposes CRUD operations for the **QueryPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueryPerformances
    * const queryPerformances = await prisma.queryPerformance.findMany()
    * ```
    */
  get queryPerformance(): Prisma.QueryPerformanceDelegate<ExtArgs>;

  /**
   * `prisma.dataQualityScores`: Exposes CRUD operations for the **DataQualityScores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataQualityScores
    * const dataQualityScores = await prisma.dataQualityScores.findMany()
    * ```
    */
  get dataQualityScores(): Prisma.DataQualityScoresDelegate<ExtArgs>;

  /**
   * `prisma.systemMetrics`: Exposes CRUD operations for the **SystemMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemMetrics
    * const systemMetrics = await prisma.systemMetrics.findMany()
    * ```
    */
  get systemMetrics(): Prisma.SystemMetricsDelegate<ExtArgs>;

  /**
   * `prisma.dimDateRange`: Exposes CRUD operations for the **DimDateRange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DimDateRanges
    * const dimDateRanges = await prisma.dimDateRange.findMany()
    * ```
    */
  get dimDateRange(): Prisma.DimDateRangeDelegate<ExtArgs>;

  /**
   * `prisma.ontologyTerm`: Exposes CRUD operations for the **OntologyTerm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OntologyTerms
    * const ontologyTerms = await prisma.ontologyTerm.findMany()
    * ```
    */
  get ontologyTerm(): Prisma.OntologyTermDelegate<ExtArgs>;

  /**
   * `prisma.viewOeeDaily`: Exposes CRUD operations for the **ViewOeeDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewOeeDailies
    * const viewOeeDailies = await prisma.viewOeeDaily.findMany()
    * ```
    */
  get viewOeeDaily(): Prisma.ViewOeeDailyDelegate<ExtArgs>;

  /**
   * `prisma.viewReliabilitySummary`: Exposes CRUD operations for the **ViewReliabilitySummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewReliabilitySummaries
    * const viewReliabilitySummaries = await prisma.viewReliabilitySummary.findMany()
    * ```
    */
  get viewReliabilitySummary(): Prisma.ViewReliabilitySummaryDelegate<ExtArgs>;

  /**
   * `prisma.viewScrapSummary`: Exposes CRUD operations for the **ViewScrapSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewScrapSummaries
    * const viewScrapSummaries = await prisma.viewScrapSummary.findMany()
    * ```
    */
  get viewScrapSummary(): Prisma.ViewScrapSummaryDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    DimSite: 'DimSite',
    DimArea: 'DimArea',
    DimWorkCenter: 'DimWorkCenter',
    DimEquipment: 'DimEquipment',
    DimProduct: 'DimProduct',
    DimShift: 'DimShift',
    DimDowntimeReason: 'DimDowntimeReason',
    DimUnit: 'DimUnit',
    FactProduction: 'FactProduction',
    FactDowntime: 'FactDowntime',
    FactScrap: 'FactScrap',
    FactMaintenance: 'FactMaintenance',
    FactSensorEvent: 'FactSensorEvent',
    AuditLog: 'AuditLog',
    AuditEvent: 'AuditEvent',
    DataDictionary: 'DataDictionary',
    DataRetentionPolicy: 'DataRetentionPolicy',
    QueryPerformance: 'QueryPerformance',
    DataQualityScores: 'DataQualityScores',
    SystemMetrics: 'SystemMetrics',
    DimDateRange: 'DimDateRange',
    OntologyTerm: 'OntologyTerm',
    ViewOeeDaily: 'ViewOeeDaily',
    ViewReliabilitySummary: 'ViewReliabilitySummary',
    ViewScrapSummary: 'ViewScrapSummary'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "dimSite" | "dimArea" | "dimWorkCenter" | "dimEquipment" | "dimProduct" | "dimShift" | "dimDowntimeReason" | "dimUnit" | "factProduction" | "factDowntime" | "factScrap" | "factMaintenance" | "factSensorEvent" | "auditLog" | "auditEvent" | "dataDictionary" | "dataRetentionPolicy" | "queryPerformance" | "dataQualityScores" | "systemMetrics" | "dimDateRange" | "ontologyTerm" | "viewOeeDaily" | "viewReliabilitySummary" | "viewScrapSummary"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      DimSite: {
        payload: Prisma.$DimSitePayload<ExtArgs>
        fields: Prisma.DimSiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimSiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimSiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload>
          }
          findFirst: {
            args: Prisma.DimSiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimSiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload>
          }
          findMany: {
            args: Prisma.DimSiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload>[]
          }
          create: {
            args: Prisma.DimSiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload>
          }
          createMany: {
            args: Prisma.DimSiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimSiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload>[]
          }
          delete: {
            args: Prisma.DimSiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload>
          }
          update: {
            args: Prisma.DimSiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload>
          }
          deleteMany: {
            args: Prisma.DimSiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimSiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimSiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimSitePayload>
          }
          aggregate: {
            args: Prisma.DimSiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimSite>
          }
          groupBy: {
            args: Prisma.DimSiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimSiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimSiteCountArgs<ExtArgs>
            result: $Utils.Optional<DimSiteCountAggregateOutputType> | number
          }
        }
      }
      DimArea: {
        payload: Prisma.$DimAreaPayload<ExtArgs>
        fields: Prisma.DimAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload>
          }
          findFirst: {
            args: Prisma.DimAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload>
          }
          findMany: {
            args: Prisma.DimAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload>[]
          }
          create: {
            args: Prisma.DimAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload>
          }
          createMany: {
            args: Prisma.DimAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload>[]
          }
          delete: {
            args: Prisma.DimAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload>
          }
          update: {
            args: Prisma.DimAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload>
          }
          deleteMany: {
            args: Prisma.DimAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimAreaPayload>
          }
          aggregate: {
            args: Prisma.DimAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimArea>
          }
          groupBy: {
            args: Prisma.DimAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimAreaCountArgs<ExtArgs>
            result: $Utils.Optional<DimAreaCountAggregateOutputType> | number
          }
        }
      }
      DimWorkCenter: {
        payload: Prisma.$DimWorkCenterPayload<ExtArgs>
        fields: Prisma.DimWorkCenterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimWorkCenterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimWorkCenterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload>
          }
          findFirst: {
            args: Prisma.DimWorkCenterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimWorkCenterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload>
          }
          findMany: {
            args: Prisma.DimWorkCenterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload>[]
          }
          create: {
            args: Prisma.DimWorkCenterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload>
          }
          createMany: {
            args: Prisma.DimWorkCenterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimWorkCenterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload>[]
          }
          delete: {
            args: Prisma.DimWorkCenterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload>
          }
          update: {
            args: Prisma.DimWorkCenterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload>
          }
          deleteMany: {
            args: Prisma.DimWorkCenterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimWorkCenterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimWorkCenterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimWorkCenterPayload>
          }
          aggregate: {
            args: Prisma.DimWorkCenterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimWorkCenter>
          }
          groupBy: {
            args: Prisma.DimWorkCenterGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimWorkCenterGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimWorkCenterCountArgs<ExtArgs>
            result: $Utils.Optional<DimWorkCenterCountAggregateOutputType> | number
          }
        }
      }
      DimEquipment: {
        payload: Prisma.$DimEquipmentPayload<ExtArgs>
        fields: Prisma.DimEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload>
          }
          findFirst: {
            args: Prisma.DimEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload>
          }
          findMany: {
            args: Prisma.DimEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload>[]
          }
          create: {
            args: Prisma.DimEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload>
          }
          createMany: {
            args: Prisma.DimEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload>[]
          }
          delete: {
            args: Prisma.DimEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload>
          }
          update: {
            args: Prisma.DimEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.DimEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimEquipmentPayload>
          }
          aggregate: {
            args: Prisma.DimEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimEquipment>
          }
          groupBy: {
            args: Prisma.DimEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<DimEquipmentCountAggregateOutputType> | number
          }
        }
      }
      DimProduct: {
        payload: Prisma.$DimProductPayload<ExtArgs>
        fields: Prisma.DimProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          findFirst: {
            args: Prisma.DimProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          findMany: {
            args: Prisma.DimProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>[]
          }
          create: {
            args: Prisma.DimProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          createMany: {
            args: Prisma.DimProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>[]
          }
          delete: {
            args: Prisma.DimProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          update: {
            args: Prisma.DimProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          deleteMany: {
            args: Prisma.DimProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          aggregate: {
            args: Prisma.DimProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimProduct>
          }
          groupBy: {
            args: Prisma.DimProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimProductCountArgs<ExtArgs>
            result: $Utils.Optional<DimProductCountAggregateOutputType> | number
          }
        }
      }
      DimShift: {
        payload: Prisma.$DimShiftPayload<ExtArgs>
        fields: Prisma.DimShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload>
          }
          findFirst: {
            args: Prisma.DimShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload>
          }
          findMany: {
            args: Prisma.DimShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload>[]
          }
          create: {
            args: Prisma.DimShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload>
          }
          createMany: {
            args: Prisma.DimShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload>[]
          }
          delete: {
            args: Prisma.DimShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload>
          }
          update: {
            args: Prisma.DimShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload>
          }
          deleteMany: {
            args: Prisma.DimShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimShiftPayload>
          }
          aggregate: {
            args: Prisma.DimShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimShift>
          }
          groupBy: {
            args: Prisma.DimShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimShiftCountArgs<ExtArgs>
            result: $Utils.Optional<DimShiftCountAggregateOutputType> | number
          }
        }
      }
      DimDowntimeReason: {
        payload: Prisma.$DimDowntimeReasonPayload<ExtArgs>
        fields: Prisma.DimDowntimeReasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimDowntimeReasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimDowntimeReasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload>
          }
          findFirst: {
            args: Prisma.DimDowntimeReasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimDowntimeReasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload>
          }
          findMany: {
            args: Prisma.DimDowntimeReasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload>[]
          }
          create: {
            args: Prisma.DimDowntimeReasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload>
          }
          createMany: {
            args: Prisma.DimDowntimeReasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimDowntimeReasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload>[]
          }
          delete: {
            args: Prisma.DimDowntimeReasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload>
          }
          update: {
            args: Prisma.DimDowntimeReasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload>
          }
          deleteMany: {
            args: Prisma.DimDowntimeReasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimDowntimeReasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimDowntimeReasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDowntimeReasonPayload>
          }
          aggregate: {
            args: Prisma.DimDowntimeReasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimDowntimeReason>
          }
          groupBy: {
            args: Prisma.DimDowntimeReasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimDowntimeReasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimDowntimeReasonCountArgs<ExtArgs>
            result: $Utils.Optional<DimDowntimeReasonCountAggregateOutputType> | number
          }
        }
      }
      DimUnit: {
        payload: Prisma.$DimUnitPayload<ExtArgs>
        fields: Prisma.DimUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload>
          }
          findFirst: {
            args: Prisma.DimUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload>
          }
          findMany: {
            args: Prisma.DimUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload>[]
          }
          create: {
            args: Prisma.DimUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload>
          }
          createMany: {
            args: Prisma.DimUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload>[]
          }
          delete: {
            args: Prisma.DimUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload>
          }
          update: {
            args: Prisma.DimUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload>
          }
          deleteMany: {
            args: Prisma.DimUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUnitPayload>
          }
          aggregate: {
            args: Prisma.DimUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimUnit>
          }
          groupBy: {
            args: Prisma.DimUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimUnitCountArgs<ExtArgs>
            result: $Utils.Optional<DimUnitCountAggregateOutputType> | number
          }
        }
      }
      FactProduction: {
        payload: Prisma.$FactProductionPayload<ExtArgs>
        fields: Prisma.FactProductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactProductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactProductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload>
          }
          findFirst: {
            args: Prisma.FactProductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactProductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload>
          }
          findMany: {
            args: Prisma.FactProductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload>[]
          }
          create: {
            args: Prisma.FactProductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload>
          }
          createMany: {
            args: Prisma.FactProductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactProductionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload>[]
          }
          delete: {
            args: Prisma.FactProductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload>
          }
          update: {
            args: Prisma.FactProductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload>
          }
          deleteMany: {
            args: Prisma.FactProductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactProductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FactProductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactProductionPayload>
          }
          aggregate: {
            args: Prisma.FactProductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactProduction>
          }
          groupBy: {
            args: Prisma.FactProductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactProductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactProductionCountArgs<ExtArgs>
            result: $Utils.Optional<FactProductionCountAggregateOutputType> | number
          }
        }
      }
      FactDowntime: {
        payload: Prisma.$FactDowntimePayload<ExtArgs>
        fields: Prisma.FactDowntimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactDowntimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactDowntimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload>
          }
          findFirst: {
            args: Prisma.FactDowntimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactDowntimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload>
          }
          findMany: {
            args: Prisma.FactDowntimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload>[]
          }
          create: {
            args: Prisma.FactDowntimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload>
          }
          createMany: {
            args: Prisma.FactDowntimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactDowntimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload>[]
          }
          delete: {
            args: Prisma.FactDowntimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload>
          }
          update: {
            args: Prisma.FactDowntimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload>
          }
          deleteMany: {
            args: Prisma.FactDowntimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactDowntimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FactDowntimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactDowntimePayload>
          }
          aggregate: {
            args: Prisma.FactDowntimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactDowntime>
          }
          groupBy: {
            args: Prisma.FactDowntimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactDowntimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactDowntimeCountArgs<ExtArgs>
            result: $Utils.Optional<FactDowntimeCountAggregateOutputType> | number
          }
        }
      }
      FactScrap: {
        payload: Prisma.$FactScrapPayload<ExtArgs>
        fields: Prisma.FactScrapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactScrapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactScrapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload>
          }
          findFirst: {
            args: Prisma.FactScrapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactScrapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload>
          }
          findMany: {
            args: Prisma.FactScrapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload>[]
          }
          create: {
            args: Prisma.FactScrapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload>
          }
          createMany: {
            args: Prisma.FactScrapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactScrapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload>[]
          }
          delete: {
            args: Prisma.FactScrapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload>
          }
          update: {
            args: Prisma.FactScrapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload>
          }
          deleteMany: {
            args: Prisma.FactScrapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactScrapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FactScrapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactScrapPayload>
          }
          aggregate: {
            args: Prisma.FactScrapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactScrap>
          }
          groupBy: {
            args: Prisma.FactScrapGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactScrapGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactScrapCountArgs<ExtArgs>
            result: $Utils.Optional<FactScrapCountAggregateOutputType> | number
          }
        }
      }
      FactMaintenance: {
        payload: Prisma.$FactMaintenancePayload<ExtArgs>
        fields: Prisma.FactMaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactMaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactMaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload>
          }
          findFirst: {
            args: Prisma.FactMaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactMaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload>
          }
          findMany: {
            args: Prisma.FactMaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload>[]
          }
          create: {
            args: Prisma.FactMaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload>
          }
          createMany: {
            args: Prisma.FactMaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactMaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload>[]
          }
          delete: {
            args: Prisma.FactMaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload>
          }
          update: {
            args: Prisma.FactMaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload>
          }
          deleteMany: {
            args: Prisma.FactMaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactMaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FactMaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactMaintenancePayload>
          }
          aggregate: {
            args: Prisma.FactMaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactMaintenance>
          }
          groupBy: {
            args: Prisma.FactMaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactMaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactMaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<FactMaintenanceCountAggregateOutputType> | number
          }
        }
      }
      FactSensorEvent: {
        payload: Prisma.$FactSensorEventPayload<ExtArgs>
        fields: Prisma.FactSensorEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactSensorEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactSensorEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload>
          }
          findFirst: {
            args: Prisma.FactSensorEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactSensorEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload>
          }
          findMany: {
            args: Prisma.FactSensorEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload>[]
          }
          create: {
            args: Prisma.FactSensorEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload>
          }
          createMany: {
            args: Prisma.FactSensorEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactSensorEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload>[]
          }
          delete: {
            args: Prisma.FactSensorEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload>
          }
          update: {
            args: Prisma.FactSensorEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload>
          }
          deleteMany: {
            args: Prisma.FactSensorEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactSensorEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FactSensorEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSensorEventPayload>
          }
          aggregate: {
            args: Prisma.FactSensorEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactSensorEvent>
          }
          groupBy: {
            args: Prisma.FactSensorEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactSensorEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactSensorEventCountArgs<ExtArgs>
            result: $Utils.Optional<FactSensorEventCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AuditEvent: {
        payload: Prisma.$AuditEventPayload<ExtArgs>
        fields: Prisma.AuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findFirst: {
            args: Prisma.AuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findMany: {
            args: Prisma.AuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          create: {
            args: Prisma.AuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          createMany: {
            args: Prisma.AuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          delete: {
            args: Prisma.AuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          update: {
            args: Prisma.AuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          deleteMany: {
            args: Prisma.AuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          aggregate: {
            args: Prisma.AuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditEvent>
          }
          groupBy: {
            args: Prisma.AuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<AuditEventCountAggregateOutputType> | number
          }
        }
      }
      DataDictionary: {
        payload: Prisma.$DataDictionaryPayload<ExtArgs>
        fields: Prisma.DataDictionaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataDictionaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataDictionaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload>
          }
          findFirst: {
            args: Prisma.DataDictionaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataDictionaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload>
          }
          findMany: {
            args: Prisma.DataDictionaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload>[]
          }
          create: {
            args: Prisma.DataDictionaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload>
          }
          createMany: {
            args: Prisma.DataDictionaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataDictionaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload>[]
          }
          delete: {
            args: Prisma.DataDictionaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload>
          }
          update: {
            args: Prisma.DataDictionaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload>
          }
          deleteMany: {
            args: Prisma.DataDictionaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataDictionaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataDictionaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDictionaryPayload>
          }
          aggregate: {
            args: Prisma.DataDictionaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataDictionary>
          }
          groupBy: {
            args: Prisma.DataDictionaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataDictionaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataDictionaryCountArgs<ExtArgs>
            result: $Utils.Optional<DataDictionaryCountAggregateOutputType> | number
          }
        }
      }
      DataRetentionPolicy: {
        payload: Prisma.$DataRetentionPolicyPayload<ExtArgs>
        fields: Prisma.DataRetentionPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataRetentionPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          findFirst: {
            args: Prisma.DataRetentionPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          findMany: {
            args: Prisma.DataRetentionPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>[]
          }
          create: {
            args: Prisma.DataRetentionPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          createMany: {
            args: Prisma.DataRetentionPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>[]
          }
          delete: {
            args: Prisma.DataRetentionPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          update: {
            args: Prisma.DataRetentionPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          deleteMany: {
            args: Prisma.DataRetentionPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataRetentionPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataRetentionPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          aggregate: {
            args: Prisma.DataRetentionPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRetentionPolicy>
          }
          groupBy: {
            args: Prisma.DataRetentionPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRetentionPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataRetentionPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<DataRetentionPolicyCountAggregateOutputType> | number
          }
        }
      }
      QueryPerformance: {
        payload: Prisma.$QueryPerformancePayload<ExtArgs>
        fields: Prisma.QueryPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueryPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueryPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload>
          }
          findFirst: {
            args: Prisma.QueryPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueryPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload>
          }
          findMany: {
            args: Prisma.QueryPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload>[]
          }
          create: {
            args: Prisma.QueryPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload>
          }
          createMany: {
            args: Prisma.QueryPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueryPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload>[]
          }
          delete: {
            args: Prisma.QueryPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload>
          }
          update: {
            args: Prisma.QueryPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload>
          }
          deleteMany: {
            args: Prisma.QueryPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueryPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QueryPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPerformancePayload>
          }
          aggregate: {
            args: Prisma.QueryPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueryPerformance>
          }
          groupBy: {
            args: Prisma.QueryPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueryPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueryPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<QueryPerformanceCountAggregateOutputType> | number
          }
        }
      }
      DataQualityScores: {
        payload: Prisma.$DataQualityScoresPayload<ExtArgs>
        fields: Prisma.DataQualityScoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataQualityScoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataQualityScoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload>
          }
          findFirst: {
            args: Prisma.DataQualityScoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataQualityScoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload>
          }
          findMany: {
            args: Prisma.DataQualityScoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload>[]
          }
          create: {
            args: Prisma.DataQualityScoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload>
          }
          createMany: {
            args: Prisma.DataQualityScoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataQualityScoresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload>[]
          }
          delete: {
            args: Prisma.DataQualityScoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload>
          }
          update: {
            args: Prisma.DataQualityScoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload>
          }
          deleteMany: {
            args: Prisma.DataQualityScoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataQualityScoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataQualityScoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataQualityScoresPayload>
          }
          aggregate: {
            args: Prisma.DataQualityScoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataQualityScores>
          }
          groupBy: {
            args: Prisma.DataQualityScoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataQualityScoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataQualityScoresCountArgs<ExtArgs>
            result: $Utils.Optional<DataQualityScoresCountAggregateOutputType> | number
          }
        }
      }
      SystemMetrics: {
        payload: Prisma.$SystemMetricsPayload<ExtArgs>
        fields: Prisma.SystemMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          findFirst: {
            args: Prisma.SystemMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          findMany: {
            args: Prisma.SystemMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>[]
          }
          create: {
            args: Prisma.SystemMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          createMany: {
            args: Prisma.SystemMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>[]
          }
          delete: {
            args: Prisma.SystemMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          update: {
            args: Prisma.SystemMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          deleteMany: {
            args: Prisma.SystemMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          aggregate: {
            args: Prisma.SystemMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemMetrics>
          }
          groupBy: {
            args: Prisma.SystemMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemMetricsCountAggregateOutputType> | number
          }
        }
      }
      DimDateRange: {
        payload: Prisma.$DimDateRangePayload<ExtArgs>
        fields: Prisma.DimDateRangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimDateRangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimDateRangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload>
          }
          findFirst: {
            args: Prisma.DimDateRangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimDateRangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload>
          }
          findMany: {
            args: Prisma.DimDateRangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload>[]
          }
          create: {
            args: Prisma.DimDateRangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload>
          }
          createMany: {
            args: Prisma.DimDateRangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimDateRangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload>[]
          }
          delete: {
            args: Prisma.DimDateRangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload>
          }
          update: {
            args: Prisma.DimDateRangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload>
          }
          deleteMany: {
            args: Prisma.DimDateRangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimDateRangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DimDateRangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDateRangePayload>
          }
          aggregate: {
            args: Prisma.DimDateRangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimDateRange>
          }
          groupBy: {
            args: Prisma.DimDateRangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimDateRangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimDateRangeCountArgs<ExtArgs>
            result: $Utils.Optional<DimDateRangeCountAggregateOutputType> | number
          }
        }
      }
      OntologyTerm: {
        payload: Prisma.$OntologyTermPayload<ExtArgs>
        fields: Prisma.OntologyTermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OntologyTermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OntologyTermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload>
          }
          findFirst: {
            args: Prisma.OntologyTermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OntologyTermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload>
          }
          findMany: {
            args: Prisma.OntologyTermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload>[]
          }
          create: {
            args: Prisma.OntologyTermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload>
          }
          createMany: {
            args: Prisma.OntologyTermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OntologyTermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload>[]
          }
          delete: {
            args: Prisma.OntologyTermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload>
          }
          update: {
            args: Prisma.OntologyTermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload>
          }
          deleteMany: {
            args: Prisma.OntologyTermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OntologyTermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OntologyTermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OntologyTermPayload>
          }
          aggregate: {
            args: Prisma.OntologyTermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOntologyTerm>
          }
          groupBy: {
            args: Prisma.OntologyTermGroupByArgs<ExtArgs>
            result: $Utils.Optional<OntologyTermGroupByOutputType>[]
          }
          count: {
            args: Prisma.OntologyTermCountArgs<ExtArgs>
            result: $Utils.Optional<OntologyTermCountAggregateOutputType> | number
          }
        }
      }
      ViewOeeDaily: {
        payload: Prisma.$ViewOeeDailyPayload<ExtArgs>
        fields: Prisma.ViewOeeDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewOeeDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewOeeDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload>
          }
          findFirst: {
            args: Prisma.ViewOeeDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewOeeDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload>
          }
          findMany: {
            args: Prisma.ViewOeeDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload>[]
          }
          create: {
            args: Prisma.ViewOeeDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload>
          }
          createMany: {
            args: Prisma.ViewOeeDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewOeeDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload>[]
          }
          delete: {
            args: Prisma.ViewOeeDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload>
          }
          update: {
            args: Prisma.ViewOeeDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload>
          }
          deleteMany: {
            args: Prisma.ViewOeeDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewOeeDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViewOeeDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewOeeDailyPayload>
          }
          aggregate: {
            args: Prisma.ViewOeeDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewOeeDaily>
          }
          groupBy: {
            args: Prisma.ViewOeeDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewOeeDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewOeeDailyCountArgs<ExtArgs>
            result: $Utils.Optional<ViewOeeDailyCountAggregateOutputType> | number
          }
        }
      }
      ViewReliabilitySummary: {
        payload: Prisma.$ViewReliabilitySummaryPayload<ExtArgs>
        fields: Prisma.ViewReliabilitySummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewReliabilitySummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewReliabilitySummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload>
          }
          findFirst: {
            args: Prisma.ViewReliabilitySummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewReliabilitySummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload>
          }
          findMany: {
            args: Prisma.ViewReliabilitySummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload>[]
          }
          create: {
            args: Prisma.ViewReliabilitySummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload>
          }
          createMany: {
            args: Prisma.ViewReliabilitySummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewReliabilitySummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload>[]
          }
          delete: {
            args: Prisma.ViewReliabilitySummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload>
          }
          update: {
            args: Prisma.ViewReliabilitySummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload>
          }
          deleteMany: {
            args: Prisma.ViewReliabilitySummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewReliabilitySummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViewReliabilitySummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewReliabilitySummaryPayload>
          }
          aggregate: {
            args: Prisma.ViewReliabilitySummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewReliabilitySummary>
          }
          groupBy: {
            args: Prisma.ViewReliabilitySummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewReliabilitySummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewReliabilitySummaryCountArgs<ExtArgs>
            result: $Utils.Optional<ViewReliabilitySummaryCountAggregateOutputType> | number
          }
        }
      }
      ViewScrapSummary: {
        payload: Prisma.$ViewScrapSummaryPayload<ExtArgs>
        fields: Prisma.ViewScrapSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewScrapSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewScrapSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload>
          }
          findFirst: {
            args: Prisma.ViewScrapSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewScrapSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload>
          }
          findMany: {
            args: Prisma.ViewScrapSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload>[]
          }
          create: {
            args: Prisma.ViewScrapSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload>
          }
          createMany: {
            args: Prisma.ViewScrapSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewScrapSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload>[]
          }
          delete: {
            args: Prisma.ViewScrapSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload>
          }
          update: {
            args: Prisma.ViewScrapSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload>
          }
          deleteMany: {
            args: Prisma.ViewScrapSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewScrapSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViewScrapSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewScrapSummaryPayload>
          }
          aggregate: {
            args: Prisma.ViewScrapSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewScrapSummary>
          }
          groupBy: {
            args: Prisma.ViewScrapSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewScrapSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewScrapSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<ViewScrapSummaryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DimSiteCountOutputType
   */

  export type DimSiteCountOutputType = {
    areas: number
    shifts: number
  }

  export type DimSiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | DimSiteCountOutputTypeCountAreasArgs
    shifts?: boolean | DimSiteCountOutputTypeCountShiftsArgs
  }

  // Custom InputTypes
  /**
   * DimSiteCountOutputType without action
   */
  export type DimSiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSiteCountOutputType
     */
    select?: DimSiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimSiteCountOutputType without action
   */
  export type DimSiteCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimAreaWhereInput
  }

  /**
   * DimSiteCountOutputType without action
   */
  export type DimSiteCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimShiftWhereInput
  }


  /**
   * Count Type DimAreaCountOutputType
   */

  export type DimAreaCountOutputType = {
    workCenters: number
  }

  export type DimAreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workCenters?: boolean | DimAreaCountOutputTypeCountWorkCentersArgs
  }

  // Custom InputTypes
  /**
   * DimAreaCountOutputType without action
   */
  export type DimAreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimAreaCountOutputType
     */
    select?: DimAreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimAreaCountOutputType without action
   */
  export type DimAreaCountOutputTypeCountWorkCentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimWorkCenterWhereInput
  }


  /**
   * Count Type DimWorkCenterCountOutputType
   */

  export type DimWorkCenterCountOutputType = {
    equipment: number
  }

  export type DimWorkCenterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimWorkCenterCountOutputTypeCountEquipmentArgs
  }

  // Custom InputTypes
  /**
   * DimWorkCenterCountOutputType without action
   */
  export type DimWorkCenterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenterCountOutputType
     */
    select?: DimWorkCenterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimWorkCenterCountOutputType without action
   */
  export type DimWorkCenterCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimEquipmentWhereInput
  }


  /**
   * Count Type DimEquipmentCountOutputType
   */

  export type DimEquipmentCountOutputType = {
    production: number
    downtime: number
    maintenance: number
    sensorEvents: number
  }

  export type DimEquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    production?: boolean | DimEquipmentCountOutputTypeCountProductionArgs
    downtime?: boolean | DimEquipmentCountOutputTypeCountDowntimeArgs
    maintenance?: boolean | DimEquipmentCountOutputTypeCountMaintenanceArgs
    sensorEvents?: boolean | DimEquipmentCountOutputTypeCountSensorEventsArgs
  }

  // Custom InputTypes
  /**
   * DimEquipmentCountOutputType without action
   */
  export type DimEquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipmentCountOutputType
     */
    select?: DimEquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimEquipmentCountOutputType without action
   */
  export type DimEquipmentCountOutputTypeCountProductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactProductionWhereInput
  }

  /**
   * DimEquipmentCountOutputType without action
   */
  export type DimEquipmentCountOutputTypeCountDowntimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactDowntimeWhereInput
  }

  /**
   * DimEquipmentCountOutputType without action
   */
  export type DimEquipmentCountOutputTypeCountMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactMaintenanceWhereInput
  }

  /**
   * DimEquipmentCountOutputType without action
   */
  export type DimEquipmentCountOutputTypeCountSensorEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactSensorEventWhereInput
  }


  /**
   * Count Type DimProductCountOutputType
   */

  export type DimProductCountOutputType = {
    production: number
    scrap: number
  }

  export type DimProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    production?: boolean | DimProductCountOutputTypeCountProductionArgs
    scrap?: boolean | DimProductCountOutputTypeCountScrapArgs
  }

  // Custom InputTypes
  /**
   * DimProductCountOutputType without action
   */
  export type DimProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProductCountOutputType
     */
    select?: DimProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimProductCountOutputType without action
   */
  export type DimProductCountOutputTypeCountProductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactProductionWhereInput
  }

  /**
   * DimProductCountOutputType without action
   */
  export type DimProductCountOutputTypeCountScrapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactScrapWhereInput
  }


  /**
   * Count Type DimShiftCountOutputType
   */

  export type DimShiftCountOutputType = {
    production: number
  }

  export type DimShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    production?: boolean | DimShiftCountOutputTypeCountProductionArgs
  }

  // Custom InputTypes
  /**
   * DimShiftCountOutputType without action
   */
  export type DimShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShiftCountOutputType
     */
    select?: DimShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimShiftCountOutputType without action
   */
  export type DimShiftCountOutputTypeCountProductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactProductionWhereInput
  }


  /**
   * Count Type DimDowntimeReasonCountOutputType
   */

  export type DimDowntimeReasonCountOutputType = {
    downtime: number
  }

  export type DimDowntimeReasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    downtime?: boolean | DimDowntimeReasonCountOutputTypeCountDowntimeArgs
  }

  // Custom InputTypes
  /**
   * DimDowntimeReasonCountOutputType without action
   */
  export type DimDowntimeReasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReasonCountOutputType
     */
    select?: DimDowntimeReasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimDowntimeReasonCountOutputType without action
   */
  export type DimDowntimeReasonCountOutputTypeCountDowntimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactDowntimeWhereInput
  }


  /**
   * Count Type DimUnitCountOutputType
   */

  export type DimUnitCountOutputType = {
    sensorEvents: number
  }

  export type DimUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensorEvents?: boolean | DimUnitCountOutputTypeCountSensorEventsArgs
  }

  // Custom InputTypes
  /**
   * DimUnitCountOutputType without action
   */
  export type DimUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnitCountOutputType
     */
    select?: DimUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DimUnitCountOutputType without action
   */
  export type DimUnitCountOutputTypeCountSensorEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactSensorEventWhereInput
  }


  /**
   * Count Type FactProductionCountOutputType
   */

  export type FactProductionCountOutputType = {
    downtime: number
    scrap: number
  }

  export type FactProductionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    downtime?: boolean | FactProductionCountOutputTypeCountDowntimeArgs
    scrap?: boolean | FactProductionCountOutputTypeCountScrapArgs
  }

  // Custom InputTypes
  /**
   * FactProductionCountOutputType without action
   */
  export type FactProductionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProductionCountOutputType
     */
    select?: FactProductionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FactProductionCountOutputType without action
   */
  export type FactProductionCountOutputTypeCountDowntimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactDowntimeWhereInput
  }

  /**
   * FactProductionCountOutputType without action
   */
  export type FactProductionCountOutputTypeCountScrapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactScrapWhereInput
  }


  /**
   * Models
   */

  /**
   * Model DimSite
   */

  export type AggregateDimSite = {
    _count: DimSiteCountAggregateOutputType | null
    _avg: DimSiteAvgAggregateOutputType | null
    _sum: DimSiteSumAggregateOutputType | null
    _min: DimSiteMinAggregateOutputType | null
    _max: DimSiteMaxAggregateOutputType | null
  }

  export type DimSiteAvgAggregateOutputType = {
    id: number | null
  }

  export type DimSiteSumAggregateOutputType = {
    id: number | null
  }

  export type DimSiteMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    timezone: string | null
  }

  export type DimSiteMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    timezone: string | null
  }

  export type DimSiteCountAggregateOutputType = {
    id: number
    code: number
    name: number
    timezone: number
    _all: number
  }


  export type DimSiteAvgAggregateInputType = {
    id?: true
  }

  export type DimSiteSumAggregateInputType = {
    id?: true
  }

  export type DimSiteMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    timezone?: true
  }

  export type DimSiteMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    timezone?: true
  }

  export type DimSiteCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    timezone?: true
    _all?: true
  }

  export type DimSiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimSite to aggregate.
     */
    where?: DimSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimSites to fetch.
     */
    orderBy?: DimSiteOrderByWithRelationInput | DimSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimSites
    **/
    _count?: true | DimSiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimSiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimSiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimSiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimSiteMaxAggregateInputType
  }

  export type GetDimSiteAggregateType<T extends DimSiteAggregateArgs> = {
        [P in keyof T & keyof AggregateDimSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimSite[P]>
      : GetScalarType<T[P], AggregateDimSite[P]>
  }




  export type DimSiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimSiteWhereInput
    orderBy?: DimSiteOrderByWithAggregationInput | DimSiteOrderByWithAggregationInput[]
    by: DimSiteScalarFieldEnum[] | DimSiteScalarFieldEnum
    having?: DimSiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimSiteCountAggregateInputType | true
    _avg?: DimSiteAvgAggregateInputType
    _sum?: DimSiteSumAggregateInputType
    _min?: DimSiteMinAggregateInputType
    _max?: DimSiteMaxAggregateInputType
  }

  export type DimSiteGroupByOutputType = {
    id: number
    code: string
    name: string
    timezone: string | null
    _count: DimSiteCountAggregateOutputType | null
    _avg: DimSiteAvgAggregateOutputType | null
    _sum: DimSiteSumAggregateOutputType | null
    _min: DimSiteMinAggregateOutputType | null
    _max: DimSiteMaxAggregateOutputType | null
  }

  type GetDimSiteGroupByPayload<T extends DimSiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimSiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimSiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimSiteGroupByOutputType[P]>
            : GetScalarType<T[P], DimSiteGroupByOutputType[P]>
        }
      >
    >


  export type DimSiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    timezone?: boolean
    areas?: boolean | DimSite$areasArgs<ExtArgs>
    shifts?: boolean | DimSite$shiftsArgs<ExtArgs>
    _count?: boolean | DimSiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimSite"]>

  export type DimSiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    timezone?: boolean
  }, ExtArgs["result"]["dimSite"]>

  export type DimSiteSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    timezone?: boolean
  }

  export type DimSiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | DimSite$areasArgs<ExtArgs>
    shifts?: boolean | DimSite$shiftsArgs<ExtArgs>
    _count?: boolean | DimSiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DimSiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DimSitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimSite"
    objects: {
      areas: Prisma.$DimAreaPayload<ExtArgs>[]
      shifts: Prisma.$DimShiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      timezone: string | null
    }, ExtArgs["result"]["dimSite"]>
    composites: {}
  }

  type DimSiteGetPayload<S extends boolean | null | undefined | DimSiteDefaultArgs> = $Result.GetResult<Prisma.$DimSitePayload, S>

  type DimSiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimSiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimSiteCountAggregateInputType | true
    }

  export interface DimSiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimSite'], meta: { name: 'DimSite' } }
    /**
     * Find zero or one DimSite that matches the filter.
     * @param {DimSiteFindUniqueArgs} args - Arguments to find a DimSite
     * @example
     * // Get one DimSite
     * const dimSite = await prisma.dimSite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimSiteFindUniqueArgs>(args: SelectSubset<T, DimSiteFindUniqueArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimSite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimSiteFindUniqueOrThrowArgs} args - Arguments to find a DimSite
     * @example
     * // Get one DimSite
     * const dimSite = await prisma.dimSite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimSiteFindUniqueOrThrowArgs>(args: SelectSubset<T, DimSiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimSite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimSiteFindFirstArgs} args - Arguments to find a DimSite
     * @example
     * // Get one DimSite
     * const dimSite = await prisma.dimSite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimSiteFindFirstArgs>(args?: SelectSubset<T, DimSiteFindFirstArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimSite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimSiteFindFirstOrThrowArgs} args - Arguments to find a DimSite
     * @example
     * // Get one DimSite
     * const dimSite = await prisma.dimSite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimSiteFindFirstOrThrowArgs>(args?: SelectSubset<T, DimSiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimSites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimSiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimSites
     * const dimSites = await prisma.dimSite.findMany()
     * 
     * // Get first 10 DimSites
     * const dimSites = await prisma.dimSite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimSiteWithIdOnly = await prisma.dimSite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimSiteFindManyArgs>(args?: SelectSubset<T, DimSiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimSite.
     * @param {DimSiteCreateArgs} args - Arguments to create a DimSite.
     * @example
     * // Create one DimSite
     * const DimSite = await prisma.dimSite.create({
     *   data: {
     *     // ... data to create a DimSite
     *   }
     * })
     * 
     */
    create<T extends DimSiteCreateArgs>(args: SelectSubset<T, DimSiteCreateArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimSites.
     * @param {DimSiteCreateManyArgs} args - Arguments to create many DimSites.
     * @example
     * // Create many DimSites
     * const dimSite = await prisma.dimSite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimSiteCreateManyArgs>(args?: SelectSubset<T, DimSiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimSites and returns the data saved in the database.
     * @param {DimSiteCreateManyAndReturnArgs} args - Arguments to create many DimSites.
     * @example
     * // Create many DimSites
     * const dimSite = await prisma.dimSite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimSites and only return the `id`
     * const dimSiteWithIdOnly = await prisma.dimSite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimSiteCreateManyAndReturnArgs>(args?: SelectSubset<T, DimSiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimSite.
     * @param {DimSiteDeleteArgs} args - Arguments to delete one DimSite.
     * @example
     * // Delete one DimSite
     * const DimSite = await prisma.dimSite.delete({
     *   where: {
     *     // ... filter to delete one DimSite
     *   }
     * })
     * 
     */
    delete<T extends DimSiteDeleteArgs>(args: SelectSubset<T, DimSiteDeleteArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimSite.
     * @param {DimSiteUpdateArgs} args - Arguments to update one DimSite.
     * @example
     * // Update one DimSite
     * const dimSite = await prisma.dimSite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimSiteUpdateArgs>(args: SelectSubset<T, DimSiteUpdateArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimSites.
     * @param {DimSiteDeleteManyArgs} args - Arguments to filter DimSites to delete.
     * @example
     * // Delete a few DimSites
     * const { count } = await prisma.dimSite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimSiteDeleteManyArgs>(args?: SelectSubset<T, DimSiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimSiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimSites
     * const dimSite = await prisma.dimSite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimSiteUpdateManyArgs>(args: SelectSubset<T, DimSiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimSite.
     * @param {DimSiteUpsertArgs} args - Arguments to update or create a DimSite.
     * @example
     * // Update or create a DimSite
     * const dimSite = await prisma.dimSite.upsert({
     *   create: {
     *     // ... data to create a DimSite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimSite we want to update
     *   }
     * })
     */
    upsert<T extends DimSiteUpsertArgs>(args: SelectSubset<T, DimSiteUpsertArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimSiteCountArgs} args - Arguments to filter DimSites to count.
     * @example
     * // Count the number of DimSites
     * const count = await prisma.dimSite.count({
     *   where: {
     *     // ... the filter for the DimSites we want to count
     *   }
     * })
    **/
    count<T extends DimSiteCountArgs>(
      args?: Subset<T, DimSiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimSiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimSiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimSiteAggregateArgs>(args: Subset<T, DimSiteAggregateArgs>): Prisma.PrismaPromise<GetDimSiteAggregateType<T>>

    /**
     * Group by DimSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimSiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimSiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimSiteGroupByArgs['orderBy'] }
        : { orderBy?: DimSiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimSiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimSite model
   */
  readonly fields: DimSiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimSite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimSiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    areas<T extends DimSite$areasArgs<ExtArgs> = {}>(args?: Subset<T, DimSite$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "findMany"> | Null>
    shifts<T extends DimSite$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, DimSite$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimSite model
   */ 
  interface DimSiteFieldRefs {
    readonly id: FieldRef<"DimSite", 'Int'>
    readonly code: FieldRef<"DimSite", 'String'>
    readonly name: FieldRef<"DimSite", 'String'>
    readonly timezone: FieldRef<"DimSite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DimSite findUnique
   */
  export type DimSiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * Filter, which DimSite to fetch.
     */
    where: DimSiteWhereUniqueInput
  }

  /**
   * DimSite findUniqueOrThrow
   */
  export type DimSiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * Filter, which DimSite to fetch.
     */
    where: DimSiteWhereUniqueInput
  }

  /**
   * DimSite findFirst
   */
  export type DimSiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * Filter, which DimSite to fetch.
     */
    where?: DimSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimSites to fetch.
     */
    orderBy?: DimSiteOrderByWithRelationInput | DimSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimSites.
     */
    cursor?: DimSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimSites.
     */
    distinct?: DimSiteScalarFieldEnum | DimSiteScalarFieldEnum[]
  }

  /**
   * DimSite findFirstOrThrow
   */
  export type DimSiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * Filter, which DimSite to fetch.
     */
    where?: DimSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimSites to fetch.
     */
    orderBy?: DimSiteOrderByWithRelationInput | DimSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimSites.
     */
    cursor?: DimSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimSites.
     */
    distinct?: DimSiteScalarFieldEnum | DimSiteScalarFieldEnum[]
  }

  /**
   * DimSite findMany
   */
  export type DimSiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * Filter, which DimSites to fetch.
     */
    where?: DimSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimSites to fetch.
     */
    orderBy?: DimSiteOrderByWithRelationInput | DimSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimSites.
     */
    cursor?: DimSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimSites.
     */
    skip?: number
    distinct?: DimSiteScalarFieldEnum | DimSiteScalarFieldEnum[]
  }

  /**
   * DimSite create
   */
  export type DimSiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * The data needed to create a DimSite.
     */
    data: XOR<DimSiteCreateInput, DimSiteUncheckedCreateInput>
  }

  /**
   * DimSite createMany
   */
  export type DimSiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimSites.
     */
    data: DimSiteCreateManyInput | DimSiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimSite createManyAndReturn
   */
  export type DimSiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimSites.
     */
    data: DimSiteCreateManyInput | DimSiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimSite update
   */
  export type DimSiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * The data needed to update a DimSite.
     */
    data: XOR<DimSiteUpdateInput, DimSiteUncheckedUpdateInput>
    /**
     * Choose, which DimSite to update.
     */
    where: DimSiteWhereUniqueInput
  }

  /**
   * DimSite updateMany
   */
  export type DimSiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimSites.
     */
    data: XOR<DimSiteUpdateManyMutationInput, DimSiteUncheckedUpdateManyInput>
    /**
     * Filter which DimSites to update
     */
    where?: DimSiteWhereInput
  }

  /**
   * DimSite upsert
   */
  export type DimSiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * The filter to search for the DimSite to update in case it exists.
     */
    where: DimSiteWhereUniqueInput
    /**
     * In case the DimSite found by the `where` argument doesn't exist, create a new DimSite with this data.
     */
    create: XOR<DimSiteCreateInput, DimSiteUncheckedCreateInput>
    /**
     * In case the DimSite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimSiteUpdateInput, DimSiteUncheckedUpdateInput>
  }

  /**
   * DimSite delete
   */
  export type DimSiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
    /**
     * Filter which DimSite to delete.
     */
    where: DimSiteWhereUniqueInput
  }

  /**
   * DimSite deleteMany
   */
  export type DimSiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimSites to delete
     */
    where?: DimSiteWhereInput
  }

  /**
   * DimSite.areas
   */
  export type DimSite$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    where?: DimAreaWhereInput
    orderBy?: DimAreaOrderByWithRelationInput | DimAreaOrderByWithRelationInput[]
    cursor?: DimAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimAreaScalarFieldEnum | DimAreaScalarFieldEnum[]
  }

  /**
   * DimSite.shifts
   */
  export type DimSite$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    where?: DimShiftWhereInput
    orderBy?: DimShiftOrderByWithRelationInput | DimShiftOrderByWithRelationInput[]
    cursor?: DimShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimShiftScalarFieldEnum | DimShiftScalarFieldEnum[]
  }

  /**
   * DimSite without action
   */
  export type DimSiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimSite
     */
    select?: DimSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimSiteInclude<ExtArgs> | null
  }


  /**
   * Model DimArea
   */

  export type AggregateDimArea = {
    _count: DimAreaCountAggregateOutputType | null
    _avg: DimAreaAvgAggregateOutputType | null
    _sum: DimAreaSumAggregateOutputType | null
    _min: DimAreaMinAggregateOutputType | null
    _max: DimAreaMaxAggregateOutputType | null
  }

  export type DimAreaAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
  }

  export type DimAreaSumAggregateOutputType = {
    id: number | null
    siteId: number | null
  }

  export type DimAreaMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    siteId: number | null
  }

  export type DimAreaMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    siteId: number | null
  }

  export type DimAreaCountAggregateOutputType = {
    id: number
    code: number
    name: number
    siteId: number
    _all: number
  }


  export type DimAreaAvgAggregateInputType = {
    id?: true
    siteId?: true
  }

  export type DimAreaSumAggregateInputType = {
    id?: true
    siteId?: true
  }

  export type DimAreaMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    siteId?: true
  }

  export type DimAreaMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    siteId?: true
  }

  export type DimAreaCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    siteId?: true
    _all?: true
  }

  export type DimAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimArea to aggregate.
     */
    where?: DimAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimAreas to fetch.
     */
    orderBy?: DimAreaOrderByWithRelationInput | DimAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimAreas
    **/
    _count?: true | DimAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimAreaMaxAggregateInputType
  }

  export type GetDimAreaAggregateType<T extends DimAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateDimArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimArea[P]>
      : GetScalarType<T[P], AggregateDimArea[P]>
  }




  export type DimAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimAreaWhereInput
    orderBy?: DimAreaOrderByWithAggregationInput | DimAreaOrderByWithAggregationInput[]
    by: DimAreaScalarFieldEnum[] | DimAreaScalarFieldEnum
    having?: DimAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimAreaCountAggregateInputType | true
    _avg?: DimAreaAvgAggregateInputType
    _sum?: DimAreaSumAggregateInputType
    _min?: DimAreaMinAggregateInputType
    _max?: DimAreaMaxAggregateInputType
  }

  export type DimAreaGroupByOutputType = {
    id: number
    code: string
    name: string
    siteId: number
    _count: DimAreaCountAggregateOutputType | null
    _avg: DimAreaAvgAggregateOutputType | null
    _sum: DimAreaSumAggregateOutputType | null
    _min: DimAreaMinAggregateOutputType | null
    _max: DimAreaMaxAggregateOutputType | null
  }

  type GetDimAreaGroupByPayload<T extends DimAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimAreaGroupByOutputType[P]>
            : GetScalarType<T[P], DimAreaGroupByOutputType[P]>
        }
      >
    >


  export type DimAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    siteId?: boolean
    site?: boolean | DimSiteDefaultArgs<ExtArgs>
    workCenters?: boolean | DimArea$workCentersArgs<ExtArgs>
    _count?: boolean | DimAreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimArea"]>

  export type DimAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    siteId?: boolean
    site?: boolean | DimSiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimArea"]>

  export type DimAreaSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    siteId?: boolean
  }

  export type DimAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | DimSiteDefaultArgs<ExtArgs>
    workCenters?: boolean | DimArea$workCentersArgs<ExtArgs>
    _count?: boolean | DimAreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DimAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | DimSiteDefaultArgs<ExtArgs>
  }

  export type $DimAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimArea"
    objects: {
      site: Prisma.$DimSitePayload<ExtArgs>
      workCenters: Prisma.$DimWorkCenterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      siteId: number
    }, ExtArgs["result"]["dimArea"]>
    composites: {}
  }

  type DimAreaGetPayload<S extends boolean | null | undefined | DimAreaDefaultArgs> = $Result.GetResult<Prisma.$DimAreaPayload, S>

  type DimAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimAreaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimAreaCountAggregateInputType | true
    }

  export interface DimAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimArea'], meta: { name: 'DimArea' } }
    /**
     * Find zero or one DimArea that matches the filter.
     * @param {DimAreaFindUniqueArgs} args - Arguments to find a DimArea
     * @example
     * // Get one DimArea
     * const dimArea = await prisma.dimArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimAreaFindUniqueArgs>(args: SelectSubset<T, DimAreaFindUniqueArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimArea that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimAreaFindUniqueOrThrowArgs} args - Arguments to find a DimArea
     * @example
     * // Get one DimArea
     * const dimArea = await prisma.dimArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, DimAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimAreaFindFirstArgs} args - Arguments to find a DimArea
     * @example
     * // Get one DimArea
     * const dimArea = await prisma.dimArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimAreaFindFirstArgs>(args?: SelectSubset<T, DimAreaFindFirstArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimAreaFindFirstOrThrowArgs} args - Arguments to find a DimArea
     * @example
     * // Get one DimArea
     * const dimArea = await prisma.dimArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, DimAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimAreas
     * const dimAreas = await prisma.dimArea.findMany()
     * 
     * // Get first 10 DimAreas
     * const dimAreas = await prisma.dimArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimAreaWithIdOnly = await prisma.dimArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimAreaFindManyArgs>(args?: SelectSubset<T, DimAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimArea.
     * @param {DimAreaCreateArgs} args - Arguments to create a DimArea.
     * @example
     * // Create one DimArea
     * const DimArea = await prisma.dimArea.create({
     *   data: {
     *     // ... data to create a DimArea
     *   }
     * })
     * 
     */
    create<T extends DimAreaCreateArgs>(args: SelectSubset<T, DimAreaCreateArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimAreas.
     * @param {DimAreaCreateManyArgs} args - Arguments to create many DimAreas.
     * @example
     * // Create many DimAreas
     * const dimArea = await prisma.dimArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimAreaCreateManyArgs>(args?: SelectSubset<T, DimAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimAreas and returns the data saved in the database.
     * @param {DimAreaCreateManyAndReturnArgs} args - Arguments to create many DimAreas.
     * @example
     * // Create many DimAreas
     * const dimArea = await prisma.dimArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimAreas and only return the `id`
     * const dimAreaWithIdOnly = await prisma.dimArea.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, DimAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimArea.
     * @param {DimAreaDeleteArgs} args - Arguments to delete one DimArea.
     * @example
     * // Delete one DimArea
     * const DimArea = await prisma.dimArea.delete({
     *   where: {
     *     // ... filter to delete one DimArea
     *   }
     * })
     * 
     */
    delete<T extends DimAreaDeleteArgs>(args: SelectSubset<T, DimAreaDeleteArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimArea.
     * @param {DimAreaUpdateArgs} args - Arguments to update one DimArea.
     * @example
     * // Update one DimArea
     * const dimArea = await prisma.dimArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimAreaUpdateArgs>(args: SelectSubset<T, DimAreaUpdateArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimAreas.
     * @param {DimAreaDeleteManyArgs} args - Arguments to filter DimAreas to delete.
     * @example
     * // Delete a few DimAreas
     * const { count } = await prisma.dimArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimAreaDeleteManyArgs>(args?: SelectSubset<T, DimAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimAreas
     * const dimArea = await prisma.dimArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimAreaUpdateManyArgs>(args: SelectSubset<T, DimAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimArea.
     * @param {DimAreaUpsertArgs} args - Arguments to update or create a DimArea.
     * @example
     * // Update or create a DimArea
     * const dimArea = await prisma.dimArea.upsert({
     *   create: {
     *     // ... data to create a DimArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimArea we want to update
     *   }
     * })
     */
    upsert<T extends DimAreaUpsertArgs>(args: SelectSubset<T, DimAreaUpsertArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimAreaCountArgs} args - Arguments to filter DimAreas to count.
     * @example
     * // Count the number of DimAreas
     * const count = await prisma.dimArea.count({
     *   where: {
     *     // ... the filter for the DimAreas we want to count
     *   }
     * })
    **/
    count<T extends DimAreaCountArgs>(
      args?: Subset<T, DimAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimAreaAggregateArgs>(args: Subset<T, DimAreaAggregateArgs>): Prisma.PrismaPromise<GetDimAreaAggregateType<T>>

    /**
     * Group by DimArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimAreaGroupByArgs['orderBy'] }
        : { orderBy?: DimAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimArea model
   */
  readonly fields: DimAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends DimSiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimSiteDefaultArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workCenters<T extends DimArea$workCentersArgs<ExtArgs> = {}>(args?: Subset<T, DimArea$workCentersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimArea model
   */ 
  interface DimAreaFieldRefs {
    readonly id: FieldRef<"DimArea", 'Int'>
    readonly code: FieldRef<"DimArea", 'String'>
    readonly name: FieldRef<"DimArea", 'String'>
    readonly siteId: FieldRef<"DimArea", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DimArea findUnique
   */
  export type DimAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * Filter, which DimArea to fetch.
     */
    where: DimAreaWhereUniqueInput
  }

  /**
   * DimArea findUniqueOrThrow
   */
  export type DimAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * Filter, which DimArea to fetch.
     */
    where: DimAreaWhereUniqueInput
  }

  /**
   * DimArea findFirst
   */
  export type DimAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * Filter, which DimArea to fetch.
     */
    where?: DimAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimAreas to fetch.
     */
    orderBy?: DimAreaOrderByWithRelationInput | DimAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimAreas.
     */
    cursor?: DimAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimAreas.
     */
    distinct?: DimAreaScalarFieldEnum | DimAreaScalarFieldEnum[]
  }

  /**
   * DimArea findFirstOrThrow
   */
  export type DimAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * Filter, which DimArea to fetch.
     */
    where?: DimAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimAreas to fetch.
     */
    orderBy?: DimAreaOrderByWithRelationInput | DimAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimAreas.
     */
    cursor?: DimAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimAreas.
     */
    distinct?: DimAreaScalarFieldEnum | DimAreaScalarFieldEnum[]
  }

  /**
   * DimArea findMany
   */
  export type DimAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * Filter, which DimAreas to fetch.
     */
    where?: DimAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimAreas to fetch.
     */
    orderBy?: DimAreaOrderByWithRelationInput | DimAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimAreas.
     */
    cursor?: DimAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimAreas.
     */
    skip?: number
    distinct?: DimAreaScalarFieldEnum | DimAreaScalarFieldEnum[]
  }

  /**
   * DimArea create
   */
  export type DimAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a DimArea.
     */
    data: XOR<DimAreaCreateInput, DimAreaUncheckedCreateInput>
  }

  /**
   * DimArea createMany
   */
  export type DimAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimAreas.
     */
    data: DimAreaCreateManyInput | DimAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimArea createManyAndReturn
   */
  export type DimAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimAreas.
     */
    data: DimAreaCreateManyInput | DimAreaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DimArea update
   */
  export type DimAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a DimArea.
     */
    data: XOR<DimAreaUpdateInput, DimAreaUncheckedUpdateInput>
    /**
     * Choose, which DimArea to update.
     */
    where: DimAreaWhereUniqueInput
  }

  /**
   * DimArea updateMany
   */
  export type DimAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimAreas.
     */
    data: XOR<DimAreaUpdateManyMutationInput, DimAreaUncheckedUpdateManyInput>
    /**
     * Filter which DimAreas to update
     */
    where?: DimAreaWhereInput
  }

  /**
   * DimArea upsert
   */
  export type DimAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the DimArea to update in case it exists.
     */
    where: DimAreaWhereUniqueInput
    /**
     * In case the DimArea found by the `where` argument doesn't exist, create a new DimArea with this data.
     */
    create: XOR<DimAreaCreateInput, DimAreaUncheckedCreateInput>
    /**
     * In case the DimArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimAreaUpdateInput, DimAreaUncheckedUpdateInput>
  }

  /**
   * DimArea delete
   */
  export type DimAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
    /**
     * Filter which DimArea to delete.
     */
    where: DimAreaWhereUniqueInput
  }

  /**
   * DimArea deleteMany
   */
  export type DimAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimAreas to delete
     */
    where?: DimAreaWhereInput
  }

  /**
   * DimArea.workCenters
   */
  export type DimArea$workCentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    where?: DimWorkCenterWhereInput
    orderBy?: DimWorkCenterOrderByWithRelationInput | DimWorkCenterOrderByWithRelationInput[]
    cursor?: DimWorkCenterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimWorkCenterScalarFieldEnum | DimWorkCenterScalarFieldEnum[]
  }

  /**
   * DimArea without action
   */
  export type DimAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimArea
     */
    select?: DimAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimAreaInclude<ExtArgs> | null
  }


  /**
   * Model DimWorkCenter
   */

  export type AggregateDimWorkCenter = {
    _count: DimWorkCenterCountAggregateOutputType | null
    _avg: DimWorkCenterAvgAggregateOutputType | null
    _sum: DimWorkCenterSumAggregateOutputType | null
    _min: DimWorkCenterMinAggregateOutputType | null
    _max: DimWorkCenterMaxAggregateOutputType | null
  }

  export type DimWorkCenterAvgAggregateOutputType = {
    id: number | null
    areaId: number | null
    capacity: Decimal | null
  }

  export type DimWorkCenterSumAggregateOutputType = {
    id: number | null
    areaId: number | null
    capacity: Decimal | null
  }

  export type DimWorkCenterMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    areaId: number | null
    capacity: Decimal | null
    capacityUnit: string | null
  }

  export type DimWorkCenterMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    areaId: number | null
    capacity: Decimal | null
    capacityUnit: string | null
  }

  export type DimWorkCenterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    areaId: number
    capacity: number
    capacityUnit: number
    _all: number
  }


  export type DimWorkCenterAvgAggregateInputType = {
    id?: true
    areaId?: true
    capacity?: true
  }

  export type DimWorkCenterSumAggregateInputType = {
    id?: true
    areaId?: true
    capacity?: true
  }

  export type DimWorkCenterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    areaId?: true
    capacity?: true
    capacityUnit?: true
  }

  export type DimWorkCenterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    areaId?: true
    capacity?: true
    capacityUnit?: true
  }

  export type DimWorkCenterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    areaId?: true
    capacity?: true
    capacityUnit?: true
    _all?: true
  }

  export type DimWorkCenterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimWorkCenter to aggregate.
     */
    where?: DimWorkCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimWorkCenters to fetch.
     */
    orderBy?: DimWorkCenterOrderByWithRelationInput | DimWorkCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimWorkCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimWorkCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimWorkCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimWorkCenters
    **/
    _count?: true | DimWorkCenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimWorkCenterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimWorkCenterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimWorkCenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimWorkCenterMaxAggregateInputType
  }

  export type GetDimWorkCenterAggregateType<T extends DimWorkCenterAggregateArgs> = {
        [P in keyof T & keyof AggregateDimWorkCenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimWorkCenter[P]>
      : GetScalarType<T[P], AggregateDimWorkCenter[P]>
  }




  export type DimWorkCenterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimWorkCenterWhereInput
    orderBy?: DimWorkCenterOrderByWithAggregationInput | DimWorkCenterOrderByWithAggregationInput[]
    by: DimWorkCenterScalarFieldEnum[] | DimWorkCenterScalarFieldEnum
    having?: DimWorkCenterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimWorkCenterCountAggregateInputType | true
    _avg?: DimWorkCenterAvgAggregateInputType
    _sum?: DimWorkCenterSumAggregateInputType
    _min?: DimWorkCenterMinAggregateInputType
    _max?: DimWorkCenterMaxAggregateInputType
  }

  export type DimWorkCenterGroupByOutputType = {
    id: number
    code: string
    name: string
    areaId: number
    capacity: Decimal | null
    capacityUnit: string | null
    _count: DimWorkCenterCountAggregateOutputType | null
    _avg: DimWorkCenterAvgAggregateOutputType | null
    _sum: DimWorkCenterSumAggregateOutputType | null
    _min: DimWorkCenterMinAggregateOutputType | null
    _max: DimWorkCenterMaxAggregateOutputType | null
  }

  type GetDimWorkCenterGroupByPayload<T extends DimWorkCenterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimWorkCenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimWorkCenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimWorkCenterGroupByOutputType[P]>
            : GetScalarType<T[P], DimWorkCenterGroupByOutputType[P]>
        }
      >
    >


  export type DimWorkCenterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    areaId?: boolean
    capacity?: boolean
    capacityUnit?: boolean
    area?: boolean | DimAreaDefaultArgs<ExtArgs>
    equipment?: boolean | DimWorkCenter$equipmentArgs<ExtArgs>
    _count?: boolean | DimWorkCenterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimWorkCenter"]>

  export type DimWorkCenterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    areaId?: boolean
    capacity?: boolean
    capacityUnit?: boolean
    area?: boolean | DimAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimWorkCenter"]>

  export type DimWorkCenterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    areaId?: boolean
    capacity?: boolean
    capacityUnit?: boolean
  }

  export type DimWorkCenterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | DimAreaDefaultArgs<ExtArgs>
    equipment?: boolean | DimWorkCenter$equipmentArgs<ExtArgs>
    _count?: boolean | DimWorkCenterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DimWorkCenterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | DimAreaDefaultArgs<ExtArgs>
  }

  export type $DimWorkCenterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimWorkCenter"
    objects: {
      area: Prisma.$DimAreaPayload<ExtArgs>
      equipment: Prisma.$DimEquipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      areaId: number
      capacity: Prisma.Decimal | null
      capacityUnit: string | null
    }, ExtArgs["result"]["dimWorkCenter"]>
    composites: {}
  }

  type DimWorkCenterGetPayload<S extends boolean | null | undefined | DimWorkCenterDefaultArgs> = $Result.GetResult<Prisma.$DimWorkCenterPayload, S>

  type DimWorkCenterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimWorkCenterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimWorkCenterCountAggregateInputType | true
    }

  export interface DimWorkCenterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimWorkCenter'], meta: { name: 'DimWorkCenter' } }
    /**
     * Find zero or one DimWorkCenter that matches the filter.
     * @param {DimWorkCenterFindUniqueArgs} args - Arguments to find a DimWorkCenter
     * @example
     * // Get one DimWorkCenter
     * const dimWorkCenter = await prisma.dimWorkCenter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimWorkCenterFindUniqueArgs>(args: SelectSubset<T, DimWorkCenterFindUniqueArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimWorkCenter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimWorkCenterFindUniqueOrThrowArgs} args - Arguments to find a DimWorkCenter
     * @example
     * // Get one DimWorkCenter
     * const dimWorkCenter = await prisma.dimWorkCenter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimWorkCenterFindUniqueOrThrowArgs>(args: SelectSubset<T, DimWorkCenterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimWorkCenter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimWorkCenterFindFirstArgs} args - Arguments to find a DimWorkCenter
     * @example
     * // Get one DimWorkCenter
     * const dimWorkCenter = await prisma.dimWorkCenter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimWorkCenterFindFirstArgs>(args?: SelectSubset<T, DimWorkCenterFindFirstArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimWorkCenter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimWorkCenterFindFirstOrThrowArgs} args - Arguments to find a DimWorkCenter
     * @example
     * // Get one DimWorkCenter
     * const dimWorkCenter = await prisma.dimWorkCenter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimWorkCenterFindFirstOrThrowArgs>(args?: SelectSubset<T, DimWorkCenterFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimWorkCenters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimWorkCenterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimWorkCenters
     * const dimWorkCenters = await prisma.dimWorkCenter.findMany()
     * 
     * // Get first 10 DimWorkCenters
     * const dimWorkCenters = await prisma.dimWorkCenter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimWorkCenterWithIdOnly = await prisma.dimWorkCenter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimWorkCenterFindManyArgs>(args?: SelectSubset<T, DimWorkCenterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimWorkCenter.
     * @param {DimWorkCenterCreateArgs} args - Arguments to create a DimWorkCenter.
     * @example
     * // Create one DimWorkCenter
     * const DimWorkCenter = await prisma.dimWorkCenter.create({
     *   data: {
     *     // ... data to create a DimWorkCenter
     *   }
     * })
     * 
     */
    create<T extends DimWorkCenterCreateArgs>(args: SelectSubset<T, DimWorkCenterCreateArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimWorkCenters.
     * @param {DimWorkCenterCreateManyArgs} args - Arguments to create many DimWorkCenters.
     * @example
     * // Create many DimWorkCenters
     * const dimWorkCenter = await prisma.dimWorkCenter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimWorkCenterCreateManyArgs>(args?: SelectSubset<T, DimWorkCenterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimWorkCenters and returns the data saved in the database.
     * @param {DimWorkCenterCreateManyAndReturnArgs} args - Arguments to create many DimWorkCenters.
     * @example
     * // Create many DimWorkCenters
     * const dimWorkCenter = await prisma.dimWorkCenter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimWorkCenters and only return the `id`
     * const dimWorkCenterWithIdOnly = await prisma.dimWorkCenter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimWorkCenterCreateManyAndReturnArgs>(args?: SelectSubset<T, DimWorkCenterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimWorkCenter.
     * @param {DimWorkCenterDeleteArgs} args - Arguments to delete one DimWorkCenter.
     * @example
     * // Delete one DimWorkCenter
     * const DimWorkCenter = await prisma.dimWorkCenter.delete({
     *   where: {
     *     // ... filter to delete one DimWorkCenter
     *   }
     * })
     * 
     */
    delete<T extends DimWorkCenterDeleteArgs>(args: SelectSubset<T, DimWorkCenterDeleteArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimWorkCenter.
     * @param {DimWorkCenterUpdateArgs} args - Arguments to update one DimWorkCenter.
     * @example
     * // Update one DimWorkCenter
     * const dimWorkCenter = await prisma.dimWorkCenter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimWorkCenterUpdateArgs>(args: SelectSubset<T, DimWorkCenterUpdateArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimWorkCenters.
     * @param {DimWorkCenterDeleteManyArgs} args - Arguments to filter DimWorkCenters to delete.
     * @example
     * // Delete a few DimWorkCenters
     * const { count } = await prisma.dimWorkCenter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimWorkCenterDeleteManyArgs>(args?: SelectSubset<T, DimWorkCenterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimWorkCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimWorkCenterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimWorkCenters
     * const dimWorkCenter = await prisma.dimWorkCenter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimWorkCenterUpdateManyArgs>(args: SelectSubset<T, DimWorkCenterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimWorkCenter.
     * @param {DimWorkCenterUpsertArgs} args - Arguments to update or create a DimWorkCenter.
     * @example
     * // Update or create a DimWorkCenter
     * const dimWorkCenter = await prisma.dimWorkCenter.upsert({
     *   create: {
     *     // ... data to create a DimWorkCenter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimWorkCenter we want to update
     *   }
     * })
     */
    upsert<T extends DimWorkCenterUpsertArgs>(args: SelectSubset<T, DimWorkCenterUpsertArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimWorkCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimWorkCenterCountArgs} args - Arguments to filter DimWorkCenters to count.
     * @example
     * // Count the number of DimWorkCenters
     * const count = await prisma.dimWorkCenter.count({
     *   where: {
     *     // ... the filter for the DimWorkCenters we want to count
     *   }
     * })
    **/
    count<T extends DimWorkCenterCountArgs>(
      args?: Subset<T, DimWorkCenterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimWorkCenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimWorkCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimWorkCenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimWorkCenterAggregateArgs>(args: Subset<T, DimWorkCenterAggregateArgs>): Prisma.PrismaPromise<GetDimWorkCenterAggregateType<T>>

    /**
     * Group by DimWorkCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimWorkCenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimWorkCenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimWorkCenterGroupByArgs['orderBy'] }
        : { orderBy?: DimWorkCenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimWorkCenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimWorkCenterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimWorkCenter model
   */
  readonly fields: DimWorkCenterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimWorkCenter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimWorkCenterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends DimAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimAreaDefaultArgs<ExtArgs>>): Prisma__DimAreaClient<$Result.GetResult<Prisma.$DimAreaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    equipment<T extends DimWorkCenter$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, DimWorkCenter$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimWorkCenter model
   */ 
  interface DimWorkCenterFieldRefs {
    readonly id: FieldRef<"DimWorkCenter", 'Int'>
    readonly code: FieldRef<"DimWorkCenter", 'String'>
    readonly name: FieldRef<"DimWorkCenter", 'String'>
    readonly areaId: FieldRef<"DimWorkCenter", 'Int'>
    readonly capacity: FieldRef<"DimWorkCenter", 'Decimal'>
    readonly capacityUnit: FieldRef<"DimWorkCenter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DimWorkCenter findUnique
   */
  export type DimWorkCenterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * Filter, which DimWorkCenter to fetch.
     */
    where: DimWorkCenterWhereUniqueInput
  }

  /**
   * DimWorkCenter findUniqueOrThrow
   */
  export type DimWorkCenterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * Filter, which DimWorkCenter to fetch.
     */
    where: DimWorkCenterWhereUniqueInput
  }

  /**
   * DimWorkCenter findFirst
   */
  export type DimWorkCenterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * Filter, which DimWorkCenter to fetch.
     */
    where?: DimWorkCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimWorkCenters to fetch.
     */
    orderBy?: DimWorkCenterOrderByWithRelationInput | DimWorkCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimWorkCenters.
     */
    cursor?: DimWorkCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimWorkCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimWorkCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimWorkCenters.
     */
    distinct?: DimWorkCenterScalarFieldEnum | DimWorkCenterScalarFieldEnum[]
  }

  /**
   * DimWorkCenter findFirstOrThrow
   */
  export type DimWorkCenterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * Filter, which DimWorkCenter to fetch.
     */
    where?: DimWorkCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimWorkCenters to fetch.
     */
    orderBy?: DimWorkCenterOrderByWithRelationInput | DimWorkCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimWorkCenters.
     */
    cursor?: DimWorkCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimWorkCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimWorkCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimWorkCenters.
     */
    distinct?: DimWorkCenterScalarFieldEnum | DimWorkCenterScalarFieldEnum[]
  }

  /**
   * DimWorkCenter findMany
   */
  export type DimWorkCenterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * Filter, which DimWorkCenters to fetch.
     */
    where?: DimWorkCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimWorkCenters to fetch.
     */
    orderBy?: DimWorkCenterOrderByWithRelationInput | DimWorkCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimWorkCenters.
     */
    cursor?: DimWorkCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimWorkCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimWorkCenters.
     */
    skip?: number
    distinct?: DimWorkCenterScalarFieldEnum | DimWorkCenterScalarFieldEnum[]
  }

  /**
   * DimWorkCenter create
   */
  export type DimWorkCenterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * The data needed to create a DimWorkCenter.
     */
    data: XOR<DimWorkCenterCreateInput, DimWorkCenterUncheckedCreateInput>
  }

  /**
   * DimWorkCenter createMany
   */
  export type DimWorkCenterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimWorkCenters.
     */
    data: DimWorkCenterCreateManyInput | DimWorkCenterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimWorkCenter createManyAndReturn
   */
  export type DimWorkCenterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimWorkCenters.
     */
    data: DimWorkCenterCreateManyInput | DimWorkCenterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DimWorkCenter update
   */
  export type DimWorkCenterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * The data needed to update a DimWorkCenter.
     */
    data: XOR<DimWorkCenterUpdateInput, DimWorkCenterUncheckedUpdateInput>
    /**
     * Choose, which DimWorkCenter to update.
     */
    where: DimWorkCenterWhereUniqueInput
  }

  /**
   * DimWorkCenter updateMany
   */
  export type DimWorkCenterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimWorkCenters.
     */
    data: XOR<DimWorkCenterUpdateManyMutationInput, DimWorkCenterUncheckedUpdateManyInput>
    /**
     * Filter which DimWorkCenters to update
     */
    where?: DimWorkCenterWhereInput
  }

  /**
   * DimWorkCenter upsert
   */
  export type DimWorkCenterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * The filter to search for the DimWorkCenter to update in case it exists.
     */
    where: DimWorkCenterWhereUniqueInput
    /**
     * In case the DimWorkCenter found by the `where` argument doesn't exist, create a new DimWorkCenter with this data.
     */
    create: XOR<DimWorkCenterCreateInput, DimWorkCenterUncheckedCreateInput>
    /**
     * In case the DimWorkCenter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimWorkCenterUpdateInput, DimWorkCenterUncheckedUpdateInput>
  }

  /**
   * DimWorkCenter delete
   */
  export type DimWorkCenterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
    /**
     * Filter which DimWorkCenter to delete.
     */
    where: DimWorkCenterWhereUniqueInput
  }

  /**
   * DimWorkCenter deleteMany
   */
  export type DimWorkCenterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimWorkCenters to delete
     */
    where?: DimWorkCenterWhereInput
  }

  /**
   * DimWorkCenter.equipment
   */
  export type DimWorkCenter$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    where?: DimEquipmentWhereInput
    orderBy?: DimEquipmentOrderByWithRelationInput | DimEquipmentOrderByWithRelationInput[]
    cursor?: DimEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DimEquipmentScalarFieldEnum | DimEquipmentScalarFieldEnum[]
  }

  /**
   * DimWorkCenter without action
   */
  export type DimWorkCenterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimWorkCenter
     */
    select?: DimWorkCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimWorkCenterInclude<ExtArgs> | null
  }


  /**
   * Model DimEquipment
   */

  export type AggregateDimEquipment = {
    _count: DimEquipmentCountAggregateOutputType | null
    _avg: DimEquipmentAvgAggregateOutputType | null
    _sum: DimEquipmentSumAggregateOutputType | null
    _min: DimEquipmentMinAggregateOutputType | null
    _max: DimEquipmentMaxAggregateOutputType | null
  }

  export type DimEquipmentAvgAggregateOutputType = {
    id: number | null
    workCenterId: number | null
    theoreticalRate: Decimal | null
  }

  export type DimEquipmentSumAggregateOutputType = {
    id: number | null
    workCenterId: number | null
    theoreticalRate: Decimal | null
  }

  export type DimEquipmentMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    type: string | null
    workCenterId: number | null
    manufacturer: string | null
    model: string | null
    serialNumber: string | null
    installationDate: Date | null
    criticalityLevel: string | null
    theoreticalRate: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimEquipmentMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    type: string | null
    workCenterId: number | null
    manufacturer: string | null
    model: string | null
    serialNumber: string | null
    installationDate: Date | null
    criticalityLevel: string | null
    theoreticalRate: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DimEquipmentCountAggregateOutputType = {
    id: number
    code: number
    name: number
    type: number
    workCenterId: number
    manufacturer: number
    model: number
    serialNumber: number
    installationDate: number
    criticalityLevel: number
    theoreticalRate: number
    attributes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DimEquipmentAvgAggregateInputType = {
    id?: true
    workCenterId?: true
    theoreticalRate?: true
  }

  export type DimEquipmentSumAggregateInputType = {
    id?: true
    workCenterId?: true
    theoreticalRate?: true
  }

  export type DimEquipmentMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    workCenterId?: true
    manufacturer?: true
    model?: true
    serialNumber?: true
    installationDate?: true
    criticalityLevel?: true
    theoreticalRate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimEquipmentMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    workCenterId?: true
    manufacturer?: true
    model?: true
    serialNumber?: true
    installationDate?: true
    criticalityLevel?: true
    theoreticalRate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DimEquipmentCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    workCenterId?: true
    manufacturer?: true
    model?: true
    serialNumber?: true
    installationDate?: true
    criticalityLevel?: true
    theoreticalRate?: true
    attributes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DimEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimEquipment to aggregate.
     */
    where?: DimEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimEquipments to fetch.
     */
    orderBy?: DimEquipmentOrderByWithRelationInput | DimEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimEquipments
    **/
    _count?: true | DimEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimEquipmentMaxAggregateInputType
  }

  export type GetDimEquipmentAggregateType<T extends DimEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDimEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimEquipment[P]>
      : GetScalarType<T[P], AggregateDimEquipment[P]>
  }




  export type DimEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimEquipmentWhereInput
    orderBy?: DimEquipmentOrderByWithAggregationInput | DimEquipmentOrderByWithAggregationInput[]
    by: DimEquipmentScalarFieldEnum[] | DimEquipmentScalarFieldEnum
    having?: DimEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimEquipmentCountAggregateInputType | true
    _avg?: DimEquipmentAvgAggregateInputType
    _sum?: DimEquipmentSumAggregateInputType
    _min?: DimEquipmentMinAggregateInputType
    _max?: DimEquipmentMaxAggregateInputType
  }

  export type DimEquipmentGroupByOutputType = {
    id: number
    code: string
    name: string
    type: string | null
    workCenterId: number
    manufacturer: string | null
    model: string | null
    serialNumber: string | null
    installationDate: Date | null
    criticalityLevel: string | null
    theoreticalRate: Decimal | null
    attributes: JsonValue | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: DimEquipmentCountAggregateOutputType | null
    _avg: DimEquipmentAvgAggregateOutputType | null
    _sum: DimEquipmentSumAggregateOutputType | null
    _min: DimEquipmentMinAggregateOutputType | null
    _max: DimEquipmentMaxAggregateOutputType | null
  }

  type GetDimEquipmentGroupByPayload<T extends DimEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], DimEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type DimEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    workCenterId?: boolean
    manufacturer?: boolean
    model?: boolean
    serialNumber?: boolean
    installationDate?: boolean
    criticalityLevel?: boolean
    theoreticalRate?: boolean
    attributes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workCenter?: boolean | DimWorkCenterDefaultArgs<ExtArgs>
    production?: boolean | DimEquipment$productionArgs<ExtArgs>
    downtime?: boolean | DimEquipment$downtimeArgs<ExtArgs>
    maintenance?: boolean | DimEquipment$maintenanceArgs<ExtArgs>
    sensorEvents?: boolean | DimEquipment$sensorEventsArgs<ExtArgs>
    _count?: boolean | DimEquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimEquipment"]>

  export type DimEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    workCenterId?: boolean
    manufacturer?: boolean
    model?: boolean
    serialNumber?: boolean
    installationDate?: boolean
    criticalityLevel?: boolean
    theoreticalRate?: boolean
    attributes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workCenter?: boolean | DimWorkCenterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimEquipment"]>

  export type DimEquipmentSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    workCenterId?: boolean
    manufacturer?: boolean
    model?: boolean
    serialNumber?: boolean
    installationDate?: boolean
    criticalityLevel?: boolean
    theoreticalRate?: boolean
    attributes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DimEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workCenter?: boolean | DimWorkCenterDefaultArgs<ExtArgs>
    production?: boolean | DimEquipment$productionArgs<ExtArgs>
    downtime?: boolean | DimEquipment$downtimeArgs<ExtArgs>
    maintenance?: boolean | DimEquipment$maintenanceArgs<ExtArgs>
    sensorEvents?: boolean | DimEquipment$sensorEventsArgs<ExtArgs>
    _count?: boolean | DimEquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DimEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workCenter?: boolean | DimWorkCenterDefaultArgs<ExtArgs>
  }

  export type $DimEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimEquipment"
    objects: {
      workCenter: Prisma.$DimWorkCenterPayload<ExtArgs>
      production: Prisma.$FactProductionPayload<ExtArgs>[]
      downtime: Prisma.$FactDowntimePayload<ExtArgs>[]
      maintenance: Prisma.$FactMaintenancePayload<ExtArgs>[]
      sensorEvents: Prisma.$FactSensorEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      type: string | null
      workCenterId: number
      manufacturer: string | null
      model: string | null
      serialNumber: string | null
      installationDate: Date | null
      criticalityLevel: string | null
      theoreticalRate: Prisma.Decimal | null
      attributes: Prisma.JsonValue | null
      isActive: boolean | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dimEquipment"]>
    composites: {}
  }

  type DimEquipmentGetPayload<S extends boolean | null | undefined | DimEquipmentDefaultArgs> = $Result.GetResult<Prisma.$DimEquipmentPayload, S>

  type DimEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimEquipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimEquipmentCountAggregateInputType | true
    }

  export interface DimEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimEquipment'], meta: { name: 'DimEquipment' } }
    /**
     * Find zero or one DimEquipment that matches the filter.
     * @param {DimEquipmentFindUniqueArgs} args - Arguments to find a DimEquipment
     * @example
     * // Get one DimEquipment
     * const dimEquipment = await prisma.dimEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimEquipmentFindUniqueArgs>(args: SelectSubset<T, DimEquipmentFindUniqueArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimEquipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimEquipmentFindUniqueOrThrowArgs} args - Arguments to find a DimEquipment
     * @example
     * // Get one DimEquipment
     * const dimEquipment = await prisma.dimEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DimEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimEquipmentFindFirstArgs} args - Arguments to find a DimEquipment
     * @example
     * // Get one DimEquipment
     * const dimEquipment = await prisma.dimEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimEquipmentFindFirstArgs>(args?: SelectSubset<T, DimEquipmentFindFirstArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimEquipmentFindFirstOrThrowArgs} args - Arguments to find a DimEquipment
     * @example
     * // Get one DimEquipment
     * const dimEquipment = await prisma.dimEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DimEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimEquipments
     * const dimEquipments = await prisma.dimEquipment.findMany()
     * 
     * // Get first 10 DimEquipments
     * const dimEquipments = await prisma.dimEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimEquipmentWithIdOnly = await prisma.dimEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimEquipmentFindManyArgs>(args?: SelectSubset<T, DimEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimEquipment.
     * @param {DimEquipmentCreateArgs} args - Arguments to create a DimEquipment.
     * @example
     * // Create one DimEquipment
     * const DimEquipment = await prisma.dimEquipment.create({
     *   data: {
     *     // ... data to create a DimEquipment
     *   }
     * })
     * 
     */
    create<T extends DimEquipmentCreateArgs>(args: SelectSubset<T, DimEquipmentCreateArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimEquipments.
     * @param {DimEquipmentCreateManyArgs} args - Arguments to create many DimEquipments.
     * @example
     * // Create many DimEquipments
     * const dimEquipment = await prisma.dimEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimEquipmentCreateManyArgs>(args?: SelectSubset<T, DimEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimEquipments and returns the data saved in the database.
     * @param {DimEquipmentCreateManyAndReturnArgs} args - Arguments to create many DimEquipments.
     * @example
     * // Create many DimEquipments
     * const dimEquipment = await prisma.dimEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimEquipments and only return the `id`
     * const dimEquipmentWithIdOnly = await prisma.dimEquipment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DimEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimEquipment.
     * @param {DimEquipmentDeleteArgs} args - Arguments to delete one DimEquipment.
     * @example
     * // Delete one DimEquipment
     * const DimEquipment = await prisma.dimEquipment.delete({
     *   where: {
     *     // ... filter to delete one DimEquipment
     *   }
     * })
     * 
     */
    delete<T extends DimEquipmentDeleteArgs>(args: SelectSubset<T, DimEquipmentDeleteArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimEquipment.
     * @param {DimEquipmentUpdateArgs} args - Arguments to update one DimEquipment.
     * @example
     * // Update one DimEquipment
     * const dimEquipment = await prisma.dimEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimEquipmentUpdateArgs>(args: SelectSubset<T, DimEquipmentUpdateArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimEquipments.
     * @param {DimEquipmentDeleteManyArgs} args - Arguments to filter DimEquipments to delete.
     * @example
     * // Delete a few DimEquipments
     * const { count } = await prisma.dimEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimEquipmentDeleteManyArgs>(args?: SelectSubset<T, DimEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimEquipments
     * const dimEquipment = await prisma.dimEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimEquipmentUpdateManyArgs>(args: SelectSubset<T, DimEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimEquipment.
     * @param {DimEquipmentUpsertArgs} args - Arguments to update or create a DimEquipment.
     * @example
     * // Update or create a DimEquipment
     * const dimEquipment = await prisma.dimEquipment.upsert({
     *   create: {
     *     // ... data to create a DimEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimEquipment we want to update
     *   }
     * })
     */
    upsert<T extends DimEquipmentUpsertArgs>(args: SelectSubset<T, DimEquipmentUpsertArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimEquipmentCountArgs} args - Arguments to filter DimEquipments to count.
     * @example
     * // Count the number of DimEquipments
     * const count = await prisma.dimEquipment.count({
     *   where: {
     *     // ... the filter for the DimEquipments we want to count
     *   }
     * })
    **/
    count<T extends DimEquipmentCountArgs>(
      args?: Subset<T, DimEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimEquipmentAggregateArgs>(args: Subset<T, DimEquipmentAggregateArgs>): Prisma.PrismaPromise<GetDimEquipmentAggregateType<T>>

    /**
     * Group by DimEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: DimEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimEquipment model
   */
  readonly fields: DimEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workCenter<T extends DimWorkCenterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimWorkCenterDefaultArgs<ExtArgs>>): Prisma__DimWorkCenterClient<$Result.GetResult<Prisma.$DimWorkCenterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    production<T extends DimEquipment$productionArgs<ExtArgs> = {}>(args?: Subset<T, DimEquipment$productionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findMany"> | Null>
    downtime<T extends DimEquipment$downtimeArgs<ExtArgs> = {}>(args?: Subset<T, DimEquipment$downtimeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "findMany"> | Null>
    maintenance<T extends DimEquipment$maintenanceArgs<ExtArgs> = {}>(args?: Subset<T, DimEquipment$maintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "findMany"> | Null>
    sensorEvents<T extends DimEquipment$sensorEventsArgs<ExtArgs> = {}>(args?: Subset<T, DimEquipment$sensorEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimEquipment model
   */ 
  interface DimEquipmentFieldRefs {
    readonly id: FieldRef<"DimEquipment", 'Int'>
    readonly code: FieldRef<"DimEquipment", 'String'>
    readonly name: FieldRef<"DimEquipment", 'String'>
    readonly type: FieldRef<"DimEquipment", 'String'>
    readonly workCenterId: FieldRef<"DimEquipment", 'Int'>
    readonly manufacturer: FieldRef<"DimEquipment", 'String'>
    readonly model: FieldRef<"DimEquipment", 'String'>
    readonly serialNumber: FieldRef<"DimEquipment", 'String'>
    readonly installationDate: FieldRef<"DimEquipment", 'DateTime'>
    readonly criticalityLevel: FieldRef<"DimEquipment", 'String'>
    readonly theoreticalRate: FieldRef<"DimEquipment", 'Decimal'>
    readonly attributes: FieldRef<"DimEquipment", 'Json'>
    readonly isActive: FieldRef<"DimEquipment", 'Boolean'>
    readonly createdAt: FieldRef<"DimEquipment", 'DateTime'>
    readonly updatedAt: FieldRef<"DimEquipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DimEquipment findUnique
   */
  export type DimEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which DimEquipment to fetch.
     */
    where: DimEquipmentWhereUniqueInput
  }

  /**
   * DimEquipment findUniqueOrThrow
   */
  export type DimEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which DimEquipment to fetch.
     */
    where: DimEquipmentWhereUniqueInput
  }

  /**
   * DimEquipment findFirst
   */
  export type DimEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which DimEquipment to fetch.
     */
    where?: DimEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimEquipments to fetch.
     */
    orderBy?: DimEquipmentOrderByWithRelationInput | DimEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimEquipments.
     */
    cursor?: DimEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimEquipments.
     */
    distinct?: DimEquipmentScalarFieldEnum | DimEquipmentScalarFieldEnum[]
  }

  /**
   * DimEquipment findFirstOrThrow
   */
  export type DimEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which DimEquipment to fetch.
     */
    where?: DimEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimEquipments to fetch.
     */
    orderBy?: DimEquipmentOrderByWithRelationInput | DimEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimEquipments.
     */
    cursor?: DimEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimEquipments.
     */
    distinct?: DimEquipmentScalarFieldEnum | DimEquipmentScalarFieldEnum[]
  }

  /**
   * DimEquipment findMany
   */
  export type DimEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which DimEquipments to fetch.
     */
    where?: DimEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimEquipments to fetch.
     */
    orderBy?: DimEquipmentOrderByWithRelationInput | DimEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimEquipments.
     */
    cursor?: DimEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimEquipments.
     */
    skip?: number
    distinct?: DimEquipmentScalarFieldEnum | DimEquipmentScalarFieldEnum[]
  }

  /**
   * DimEquipment create
   */
  export type DimEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DimEquipment.
     */
    data: XOR<DimEquipmentCreateInput, DimEquipmentUncheckedCreateInput>
  }

  /**
   * DimEquipment createMany
   */
  export type DimEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimEquipments.
     */
    data: DimEquipmentCreateManyInput | DimEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimEquipment createManyAndReturn
   */
  export type DimEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimEquipments.
     */
    data: DimEquipmentCreateManyInput | DimEquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DimEquipment update
   */
  export type DimEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DimEquipment.
     */
    data: XOR<DimEquipmentUpdateInput, DimEquipmentUncheckedUpdateInput>
    /**
     * Choose, which DimEquipment to update.
     */
    where: DimEquipmentWhereUniqueInput
  }

  /**
   * DimEquipment updateMany
   */
  export type DimEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimEquipments.
     */
    data: XOR<DimEquipmentUpdateManyMutationInput, DimEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which DimEquipments to update
     */
    where?: DimEquipmentWhereInput
  }

  /**
   * DimEquipment upsert
   */
  export type DimEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DimEquipment to update in case it exists.
     */
    where: DimEquipmentWhereUniqueInput
    /**
     * In case the DimEquipment found by the `where` argument doesn't exist, create a new DimEquipment with this data.
     */
    create: XOR<DimEquipmentCreateInput, DimEquipmentUncheckedCreateInput>
    /**
     * In case the DimEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimEquipmentUpdateInput, DimEquipmentUncheckedUpdateInput>
  }

  /**
   * DimEquipment delete
   */
  export type DimEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
    /**
     * Filter which DimEquipment to delete.
     */
    where: DimEquipmentWhereUniqueInput
  }

  /**
   * DimEquipment deleteMany
   */
  export type DimEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimEquipments to delete
     */
    where?: DimEquipmentWhereInput
  }

  /**
   * DimEquipment.production
   */
  export type DimEquipment$productionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    where?: FactProductionWhereInput
    orderBy?: FactProductionOrderByWithRelationInput | FactProductionOrderByWithRelationInput[]
    cursor?: FactProductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactProductionScalarFieldEnum | FactProductionScalarFieldEnum[]
  }

  /**
   * DimEquipment.downtime
   */
  export type DimEquipment$downtimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    where?: FactDowntimeWhereInput
    orderBy?: FactDowntimeOrderByWithRelationInput | FactDowntimeOrderByWithRelationInput[]
    cursor?: FactDowntimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactDowntimeScalarFieldEnum | FactDowntimeScalarFieldEnum[]
  }

  /**
   * DimEquipment.maintenance
   */
  export type DimEquipment$maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    where?: FactMaintenanceWhereInput
    orderBy?: FactMaintenanceOrderByWithRelationInput | FactMaintenanceOrderByWithRelationInput[]
    cursor?: FactMaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactMaintenanceScalarFieldEnum | FactMaintenanceScalarFieldEnum[]
  }

  /**
   * DimEquipment.sensorEvents
   */
  export type DimEquipment$sensorEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    where?: FactSensorEventWhereInput
    orderBy?: FactSensorEventOrderByWithRelationInput | FactSensorEventOrderByWithRelationInput[]
    cursor?: FactSensorEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactSensorEventScalarFieldEnum | FactSensorEventScalarFieldEnum[]
  }

  /**
   * DimEquipment without action
   */
  export type DimEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimEquipment
     */
    select?: DimEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model DimProduct
   */

  export type AggregateDimProduct = {
    _count: DimProductCountAggregateOutputType | null
    _avg: DimProductAvgAggregateOutputType | null
    _sum: DimProductSumAggregateOutputType | null
    _min: DimProductMinAggregateOutputType | null
    _max: DimProductMaxAggregateOutputType | null
  }

  export type DimProductAvgAggregateOutputType = {
    id: number | null
    standardCost: Decimal | null
    targetCycleTime: number | null
  }

  export type DimProductSumAggregateOutputType = {
    id: number | null
    standardCost: Decimal | null
    targetCycleTime: bigint | null
  }

  export type DimProductMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    family: string | null
    unitOfMeasure: string | null
    standardCost: Decimal | null
    targetCycleTime: bigint | null
  }

  export type DimProductMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    family: string | null
    unitOfMeasure: string | null
    standardCost: Decimal | null
    targetCycleTime: bigint | null
  }

  export type DimProductCountAggregateOutputType = {
    id: number
    code: number
    name: number
    family: number
    unitOfMeasure: number
    standardCost: number
    targetCycleTime: number
    _all: number
  }


  export type DimProductAvgAggregateInputType = {
    id?: true
    standardCost?: true
    targetCycleTime?: true
  }

  export type DimProductSumAggregateInputType = {
    id?: true
    standardCost?: true
    targetCycleTime?: true
  }

  export type DimProductMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    family?: true
    unitOfMeasure?: true
    standardCost?: true
    targetCycleTime?: true
  }

  export type DimProductMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    family?: true
    unitOfMeasure?: true
    standardCost?: true
    targetCycleTime?: true
  }

  export type DimProductCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    family?: true
    unitOfMeasure?: true
    standardCost?: true
    targetCycleTime?: true
    _all?: true
  }

  export type DimProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimProduct to aggregate.
     */
    where?: DimProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimProducts to fetch.
     */
    orderBy?: DimProductOrderByWithRelationInput | DimProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimProducts
    **/
    _count?: true | DimProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimProductMaxAggregateInputType
  }

  export type GetDimProductAggregateType<T extends DimProductAggregateArgs> = {
        [P in keyof T & keyof AggregateDimProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimProduct[P]>
      : GetScalarType<T[P], AggregateDimProduct[P]>
  }




  export type DimProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimProductWhereInput
    orderBy?: DimProductOrderByWithAggregationInput | DimProductOrderByWithAggregationInput[]
    by: DimProductScalarFieldEnum[] | DimProductScalarFieldEnum
    having?: DimProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimProductCountAggregateInputType | true
    _avg?: DimProductAvgAggregateInputType
    _sum?: DimProductSumAggregateInputType
    _min?: DimProductMinAggregateInputType
    _max?: DimProductMaxAggregateInputType
  }

  export type DimProductGroupByOutputType = {
    id: number
    code: string
    name: string
    family: string | null
    unitOfMeasure: string | null
    standardCost: Decimal | null
    targetCycleTime: bigint | null
    _count: DimProductCountAggregateOutputType | null
    _avg: DimProductAvgAggregateOutputType | null
    _sum: DimProductSumAggregateOutputType | null
    _min: DimProductMinAggregateOutputType | null
    _max: DimProductMaxAggregateOutputType | null
  }

  type GetDimProductGroupByPayload<T extends DimProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimProductGroupByOutputType[P]>
            : GetScalarType<T[P], DimProductGroupByOutputType[P]>
        }
      >
    >


  export type DimProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    family?: boolean
    unitOfMeasure?: boolean
    standardCost?: boolean
    targetCycleTime?: boolean
    production?: boolean | DimProduct$productionArgs<ExtArgs>
    scrap?: boolean | DimProduct$scrapArgs<ExtArgs>
    _count?: boolean | DimProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimProduct"]>

  export type DimProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    family?: boolean
    unitOfMeasure?: boolean
    standardCost?: boolean
    targetCycleTime?: boolean
  }, ExtArgs["result"]["dimProduct"]>

  export type DimProductSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    family?: boolean
    unitOfMeasure?: boolean
    standardCost?: boolean
    targetCycleTime?: boolean
  }

  export type DimProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    production?: boolean | DimProduct$productionArgs<ExtArgs>
    scrap?: boolean | DimProduct$scrapArgs<ExtArgs>
    _count?: boolean | DimProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DimProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DimProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimProduct"
    objects: {
      production: Prisma.$FactProductionPayload<ExtArgs>[]
      scrap: Prisma.$FactScrapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      family: string | null
      unitOfMeasure: string | null
      standardCost: Prisma.Decimal | null
      targetCycleTime: bigint | null
    }, ExtArgs["result"]["dimProduct"]>
    composites: {}
  }

  type DimProductGetPayload<S extends boolean | null | undefined | DimProductDefaultArgs> = $Result.GetResult<Prisma.$DimProductPayload, S>

  type DimProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimProductCountAggregateInputType | true
    }

  export interface DimProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimProduct'], meta: { name: 'DimProduct' } }
    /**
     * Find zero or one DimProduct that matches the filter.
     * @param {DimProductFindUniqueArgs} args - Arguments to find a DimProduct
     * @example
     * // Get one DimProduct
     * const dimProduct = await prisma.dimProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimProductFindUniqueArgs>(args: SelectSubset<T, DimProductFindUniqueArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimProductFindUniqueOrThrowArgs} args - Arguments to find a DimProduct
     * @example
     * // Get one DimProduct
     * const dimProduct = await prisma.dimProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimProductFindUniqueOrThrowArgs>(args: SelectSubset<T, DimProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductFindFirstArgs} args - Arguments to find a DimProduct
     * @example
     * // Get one DimProduct
     * const dimProduct = await prisma.dimProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimProductFindFirstArgs>(args?: SelectSubset<T, DimProductFindFirstArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductFindFirstOrThrowArgs} args - Arguments to find a DimProduct
     * @example
     * // Get one DimProduct
     * const dimProduct = await prisma.dimProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimProductFindFirstOrThrowArgs>(args?: SelectSubset<T, DimProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimProducts
     * const dimProducts = await prisma.dimProduct.findMany()
     * 
     * // Get first 10 DimProducts
     * const dimProducts = await prisma.dimProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimProductWithIdOnly = await prisma.dimProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimProductFindManyArgs>(args?: SelectSubset<T, DimProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimProduct.
     * @param {DimProductCreateArgs} args - Arguments to create a DimProduct.
     * @example
     * // Create one DimProduct
     * const DimProduct = await prisma.dimProduct.create({
     *   data: {
     *     // ... data to create a DimProduct
     *   }
     * })
     * 
     */
    create<T extends DimProductCreateArgs>(args: SelectSubset<T, DimProductCreateArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimProducts.
     * @param {DimProductCreateManyArgs} args - Arguments to create many DimProducts.
     * @example
     * // Create many DimProducts
     * const dimProduct = await prisma.dimProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimProductCreateManyArgs>(args?: SelectSubset<T, DimProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimProducts and returns the data saved in the database.
     * @param {DimProductCreateManyAndReturnArgs} args - Arguments to create many DimProducts.
     * @example
     * // Create many DimProducts
     * const dimProduct = await prisma.dimProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimProducts and only return the `id`
     * const dimProductWithIdOnly = await prisma.dimProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimProductCreateManyAndReturnArgs>(args?: SelectSubset<T, DimProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimProduct.
     * @param {DimProductDeleteArgs} args - Arguments to delete one DimProduct.
     * @example
     * // Delete one DimProduct
     * const DimProduct = await prisma.dimProduct.delete({
     *   where: {
     *     // ... filter to delete one DimProduct
     *   }
     * })
     * 
     */
    delete<T extends DimProductDeleteArgs>(args: SelectSubset<T, DimProductDeleteArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimProduct.
     * @param {DimProductUpdateArgs} args - Arguments to update one DimProduct.
     * @example
     * // Update one DimProduct
     * const dimProduct = await prisma.dimProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimProductUpdateArgs>(args: SelectSubset<T, DimProductUpdateArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimProducts.
     * @param {DimProductDeleteManyArgs} args - Arguments to filter DimProducts to delete.
     * @example
     * // Delete a few DimProducts
     * const { count } = await prisma.dimProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimProductDeleteManyArgs>(args?: SelectSubset<T, DimProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimProducts
     * const dimProduct = await prisma.dimProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimProductUpdateManyArgs>(args: SelectSubset<T, DimProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimProduct.
     * @param {DimProductUpsertArgs} args - Arguments to update or create a DimProduct.
     * @example
     * // Update or create a DimProduct
     * const dimProduct = await prisma.dimProduct.upsert({
     *   create: {
     *     // ... data to create a DimProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimProduct we want to update
     *   }
     * })
     */
    upsert<T extends DimProductUpsertArgs>(args: SelectSubset<T, DimProductUpsertArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductCountArgs} args - Arguments to filter DimProducts to count.
     * @example
     * // Count the number of DimProducts
     * const count = await prisma.dimProduct.count({
     *   where: {
     *     // ... the filter for the DimProducts we want to count
     *   }
     * })
    **/
    count<T extends DimProductCountArgs>(
      args?: Subset<T, DimProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimProductAggregateArgs>(args: Subset<T, DimProductAggregateArgs>): Prisma.PrismaPromise<GetDimProductAggregateType<T>>

    /**
     * Group by DimProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimProductGroupByArgs['orderBy'] }
        : { orderBy?: DimProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimProduct model
   */
  readonly fields: DimProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    production<T extends DimProduct$productionArgs<ExtArgs> = {}>(args?: Subset<T, DimProduct$productionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findMany"> | Null>
    scrap<T extends DimProduct$scrapArgs<ExtArgs> = {}>(args?: Subset<T, DimProduct$scrapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimProduct model
   */ 
  interface DimProductFieldRefs {
    readonly id: FieldRef<"DimProduct", 'Int'>
    readonly code: FieldRef<"DimProduct", 'String'>
    readonly name: FieldRef<"DimProduct", 'String'>
    readonly family: FieldRef<"DimProduct", 'String'>
    readonly unitOfMeasure: FieldRef<"DimProduct", 'String'>
    readonly standardCost: FieldRef<"DimProduct", 'Decimal'>
    readonly targetCycleTime: FieldRef<"DimProduct", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * DimProduct findUnique
   */
  export type DimProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * Filter, which DimProduct to fetch.
     */
    where: DimProductWhereUniqueInput
  }

  /**
   * DimProduct findUniqueOrThrow
   */
  export type DimProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * Filter, which DimProduct to fetch.
     */
    where: DimProductWhereUniqueInput
  }

  /**
   * DimProduct findFirst
   */
  export type DimProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * Filter, which DimProduct to fetch.
     */
    where?: DimProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimProducts to fetch.
     */
    orderBy?: DimProductOrderByWithRelationInput | DimProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimProducts.
     */
    cursor?: DimProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimProducts.
     */
    distinct?: DimProductScalarFieldEnum | DimProductScalarFieldEnum[]
  }

  /**
   * DimProduct findFirstOrThrow
   */
  export type DimProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * Filter, which DimProduct to fetch.
     */
    where?: DimProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimProducts to fetch.
     */
    orderBy?: DimProductOrderByWithRelationInput | DimProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimProducts.
     */
    cursor?: DimProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimProducts.
     */
    distinct?: DimProductScalarFieldEnum | DimProductScalarFieldEnum[]
  }

  /**
   * DimProduct findMany
   */
  export type DimProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * Filter, which DimProducts to fetch.
     */
    where?: DimProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimProducts to fetch.
     */
    orderBy?: DimProductOrderByWithRelationInput | DimProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimProducts.
     */
    cursor?: DimProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimProducts.
     */
    skip?: number
    distinct?: DimProductScalarFieldEnum | DimProductScalarFieldEnum[]
  }

  /**
   * DimProduct create
   */
  export type DimProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * The data needed to create a DimProduct.
     */
    data: XOR<DimProductCreateInput, DimProductUncheckedCreateInput>
  }

  /**
   * DimProduct createMany
   */
  export type DimProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimProducts.
     */
    data: DimProductCreateManyInput | DimProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimProduct createManyAndReturn
   */
  export type DimProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimProducts.
     */
    data: DimProductCreateManyInput | DimProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimProduct update
   */
  export type DimProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * The data needed to update a DimProduct.
     */
    data: XOR<DimProductUpdateInput, DimProductUncheckedUpdateInput>
    /**
     * Choose, which DimProduct to update.
     */
    where: DimProductWhereUniqueInput
  }

  /**
   * DimProduct updateMany
   */
  export type DimProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimProducts.
     */
    data: XOR<DimProductUpdateManyMutationInput, DimProductUncheckedUpdateManyInput>
    /**
     * Filter which DimProducts to update
     */
    where?: DimProductWhereInput
  }

  /**
   * DimProduct upsert
   */
  export type DimProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * The filter to search for the DimProduct to update in case it exists.
     */
    where: DimProductWhereUniqueInput
    /**
     * In case the DimProduct found by the `where` argument doesn't exist, create a new DimProduct with this data.
     */
    create: XOR<DimProductCreateInput, DimProductUncheckedCreateInput>
    /**
     * In case the DimProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimProductUpdateInput, DimProductUncheckedUpdateInput>
  }

  /**
   * DimProduct delete
   */
  export type DimProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
    /**
     * Filter which DimProduct to delete.
     */
    where: DimProductWhereUniqueInput
  }

  /**
   * DimProduct deleteMany
   */
  export type DimProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimProducts to delete
     */
    where?: DimProductWhereInput
  }

  /**
   * DimProduct.production
   */
  export type DimProduct$productionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    where?: FactProductionWhereInput
    orderBy?: FactProductionOrderByWithRelationInput | FactProductionOrderByWithRelationInput[]
    cursor?: FactProductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactProductionScalarFieldEnum | FactProductionScalarFieldEnum[]
  }

  /**
   * DimProduct.scrap
   */
  export type DimProduct$scrapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    where?: FactScrapWhereInput
    orderBy?: FactScrapOrderByWithRelationInput | FactScrapOrderByWithRelationInput[]
    cursor?: FactScrapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactScrapScalarFieldEnum | FactScrapScalarFieldEnum[]
  }

  /**
   * DimProduct without action
   */
  export type DimProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimProductInclude<ExtArgs> | null
  }


  /**
   * Model DimShift
   */

  export type AggregateDimShift = {
    _count: DimShiftCountAggregateOutputType | null
    _avg: DimShiftAvgAggregateOutputType | null
    _sum: DimShiftSumAggregateOutputType | null
    _min: DimShiftMinAggregateOutputType | null
    _max: DimShiftMaxAggregateOutputType | null
  }

  export type DimShiftAvgAggregateOutputType = {
    id: number | null
    siteId: number | null
    breakMinutes: number | null
  }

  export type DimShiftSumAggregateOutputType = {
    id: number | null
    siteId: number | null
    breakMinutes: number | null
  }

  export type DimShiftMinAggregateOutputType = {
    id: number | null
    siteId: number | null
    name: string | null
    startTime: string | null
    endTime: string | null
    breakMinutes: number | null
    isActive: boolean | null
  }

  export type DimShiftMaxAggregateOutputType = {
    id: number | null
    siteId: number | null
    name: string | null
    startTime: string | null
    endTime: string | null
    breakMinutes: number | null
    isActive: boolean | null
  }

  export type DimShiftCountAggregateOutputType = {
    id: number
    siteId: number
    name: number
    startTime: number
    endTime: number
    breakMinutes: number
    isActive: number
    _all: number
  }


  export type DimShiftAvgAggregateInputType = {
    id?: true
    siteId?: true
    breakMinutes?: true
  }

  export type DimShiftSumAggregateInputType = {
    id?: true
    siteId?: true
    breakMinutes?: true
  }

  export type DimShiftMinAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    startTime?: true
    endTime?: true
    breakMinutes?: true
    isActive?: true
  }

  export type DimShiftMaxAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    startTime?: true
    endTime?: true
    breakMinutes?: true
    isActive?: true
  }

  export type DimShiftCountAggregateInputType = {
    id?: true
    siteId?: true
    name?: true
    startTime?: true
    endTime?: true
    breakMinutes?: true
    isActive?: true
    _all?: true
  }

  export type DimShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimShift to aggregate.
     */
    where?: DimShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimShifts to fetch.
     */
    orderBy?: DimShiftOrderByWithRelationInput | DimShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimShifts
    **/
    _count?: true | DimShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimShiftMaxAggregateInputType
  }

  export type GetDimShiftAggregateType<T extends DimShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateDimShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimShift[P]>
      : GetScalarType<T[P], AggregateDimShift[P]>
  }




  export type DimShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimShiftWhereInput
    orderBy?: DimShiftOrderByWithAggregationInput | DimShiftOrderByWithAggregationInput[]
    by: DimShiftScalarFieldEnum[] | DimShiftScalarFieldEnum
    having?: DimShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimShiftCountAggregateInputType | true
    _avg?: DimShiftAvgAggregateInputType
    _sum?: DimShiftSumAggregateInputType
    _min?: DimShiftMinAggregateInputType
    _max?: DimShiftMaxAggregateInputType
  }

  export type DimShiftGroupByOutputType = {
    id: number
    siteId: number
    name: string
    startTime: string
    endTime: string
    breakMinutes: number | null
    isActive: boolean | null
    _count: DimShiftCountAggregateOutputType | null
    _avg: DimShiftAvgAggregateOutputType | null
    _sum: DimShiftSumAggregateOutputType | null
    _min: DimShiftMinAggregateOutputType | null
    _max: DimShiftMaxAggregateOutputType | null
  }

  type GetDimShiftGroupByPayload<T extends DimShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimShiftGroupByOutputType[P]>
            : GetScalarType<T[P], DimShiftGroupByOutputType[P]>
        }
      >
    >


  export type DimShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    breakMinutes?: boolean
    isActive?: boolean
    site?: boolean | DimSiteDefaultArgs<ExtArgs>
    production?: boolean | DimShift$productionArgs<ExtArgs>
    _count?: boolean | DimShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimShift"]>

  export type DimShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteId?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    breakMinutes?: boolean
    isActive?: boolean
    site?: boolean | DimSiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimShift"]>

  export type DimShiftSelectScalar = {
    id?: boolean
    siteId?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    breakMinutes?: boolean
    isActive?: boolean
  }

  export type DimShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | DimSiteDefaultArgs<ExtArgs>
    production?: boolean | DimShift$productionArgs<ExtArgs>
    _count?: boolean | DimShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DimShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    site?: boolean | DimSiteDefaultArgs<ExtArgs>
  }

  export type $DimShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimShift"
    objects: {
      site: Prisma.$DimSitePayload<ExtArgs>
      production: Prisma.$FactProductionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      siteId: number
      name: string
      startTime: string
      endTime: string
      breakMinutes: number | null
      isActive: boolean | null
    }, ExtArgs["result"]["dimShift"]>
    composites: {}
  }

  type DimShiftGetPayload<S extends boolean | null | undefined | DimShiftDefaultArgs> = $Result.GetResult<Prisma.$DimShiftPayload, S>

  type DimShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimShiftCountAggregateInputType | true
    }

  export interface DimShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimShift'], meta: { name: 'DimShift' } }
    /**
     * Find zero or one DimShift that matches the filter.
     * @param {DimShiftFindUniqueArgs} args - Arguments to find a DimShift
     * @example
     * // Get one DimShift
     * const dimShift = await prisma.dimShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimShiftFindUniqueArgs>(args: SelectSubset<T, DimShiftFindUniqueArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimShift that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimShiftFindUniqueOrThrowArgs} args - Arguments to find a DimShift
     * @example
     * // Get one DimShift
     * const dimShift = await prisma.dimShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, DimShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimShiftFindFirstArgs} args - Arguments to find a DimShift
     * @example
     * // Get one DimShift
     * const dimShift = await prisma.dimShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimShiftFindFirstArgs>(args?: SelectSubset<T, DimShiftFindFirstArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimShiftFindFirstOrThrowArgs} args - Arguments to find a DimShift
     * @example
     * // Get one DimShift
     * const dimShift = await prisma.dimShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, DimShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimShifts
     * const dimShifts = await prisma.dimShift.findMany()
     * 
     * // Get first 10 DimShifts
     * const dimShifts = await prisma.dimShift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimShiftWithIdOnly = await prisma.dimShift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimShiftFindManyArgs>(args?: SelectSubset<T, DimShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimShift.
     * @param {DimShiftCreateArgs} args - Arguments to create a DimShift.
     * @example
     * // Create one DimShift
     * const DimShift = await prisma.dimShift.create({
     *   data: {
     *     // ... data to create a DimShift
     *   }
     * })
     * 
     */
    create<T extends DimShiftCreateArgs>(args: SelectSubset<T, DimShiftCreateArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimShifts.
     * @param {DimShiftCreateManyArgs} args - Arguments to create many DimShifts.
     * @example
     * // Create many DimShifts
     * const dimShift = await prisma.dimShift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimShiftCreateManyArgs>(args?: SelectSubset<T, DimShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimShifts and returns the data saved in the database.
     * @param {DimShiftCreateManyAndReturnArgs} args - Arguments to create many DimShifts.
     * @example
     * // Create many DimShifts
     * const dimShift = await prisma.dimShift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimShifts and only return the `id`
     * const dimShiftWithIdOnly = await prisma.dimShift.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, DimShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimShift.
     * @param {DimShiftDeleteArgs} args - Arguments to delete one DimShift.
     * @example
     * // Delete one DimShift
     * const DimShift = await prisma.dimShift.delete({
     *   where: {
     *     // ... filter to delete one DimShift
     *   }
     * })
     * 
     */
    delete<T extends DimShiftDeleteArgs>(args: SelectSubset<T, DimShiftDeleteArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimShift.
     * @param {DimShiftUpdateArgs} args - Arguments to update one DimShift.
     * @example
     * // Update one DimShift
     * const dimShift = await prisma.dimShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimShiftUpdateArgs>(args: SelectSubset<T, DimShiftUpdateArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimShifts.
     * @param {DimShiftDeleteManyArgs} args - Arguments to filter DimShifts to delete.
     * @example
     * // Delete a few DimShifts
     * const { count } = await prisma.dimShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimShiftDeleteManyArgs>(args?: SelectSubset<T, DimShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimShifts
     * const dimShift = await prisma.dimShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimShiftUpdateManyArgs>(args: SelectSubset<T, DimShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimShift.
     * @param {DimShiftUpsertArgs} args - Arguments to update or create a DimShift.
     * @example
     * // Update or create a DimShift
     * const dimShift = await prisma.dimShift.upsert({
     *   create: {
     *     // ... data to create a DimShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimShift we want to update
     *   }
     * })
     */
    upsert<T extends DimShiftUpsertArgs>(args: SelectSubset<T, DimShiftUpsertArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimShiftCountArgs} args - Arguments to filter DimShifts to count.
     * @example
     * // Count the number of DimShifts
     * const count = await prisma.dimShift.count({
     *   where: {
     *     // ... the filter for the DimShifts we want to count
     *   }
     * })
    **/
    count<T extends DimShiftCountArgs>(
      args?: Subset<T, DimShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimShiftAggregateArgs>(args: Subset<T, DimShiftAggregateArgs>): Prisma.PrismaPromise<GetDimShiftAggregateType<T>>

    /**
     * Group by DimShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimShiftGroupByArgs['orderBy'] }
        : { orderBy?: DimShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimShift model
   */
  readonly fields: DimShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    site<T extends DimSiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimSiteDefaultArgs<ExtArgs>>): Prisma__DimSiteClient<$Result.GetResult<Prisma.$DimSitePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    production<T extends DimShift$productionArgs<ExtArgs> = {}>(args?: Subset<T, DimShift$productionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimShift model
   */ 
  interface DimShiftFieldRefs {
    readonly id: FieldRef<"DimShift", 'Int'>
    readonly siteId: FieldRef<"DimShift", 'Int'>
    readonly name: FieldRef<"DimShift", 'String'>
    readonly startTime: FieldRef<"DimShift", 'String'>
    readonly endTime: FieldRef<"DimShift", 'String'>
    readonly breakMinutes: FieldRef<"DimShift", 'Int'>
    readonly isActive: FieldRef<"DimShift", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DimShift findUnique
   */
  export type DimShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * Filter, which DimShift to fetch.
     */
    where: DimShiftWhereUniqueInput
  }

  /**
   * DimShift findUniqueOrThrow
   */
  export type DimShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * Filter, which DimShift to fetch.
     */
    where: DimShiftWhereUniqueInput
  }

  /**
   * DimShift findFirst
   */
  export type DimShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * Filter, which DimShift to fetch.
     */
    where?: DimShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimShifts to fetch.
     */
    orderBy?: DimShiftOrderByWithRelationInput | DimShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimShifts.
     */
    cursor?: DimShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimShifts.
     */
    distinct?: DimShiftScalarFieldEnum | DimShiftScalarFieldEnum[]
  }

  /**
   * DimShift findFirstOrThrow
   */
  export type DimShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * Filter, which DimShift to fetch.
     */
    where?: DimShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimShifts to fetch.
     */
    orderBy?: DimShiftOrderByWithRelationInput | DimShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimShifts.
     */
    cursor?: DimShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimShifts.
     */
    distinct?: DimShiftScalarFieldEnum | DimShiftScalarFieldEnum[]
  }

  /**
   * DimShift findMany
   */
  export type DimShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * Filter, which DimShifts to fetch.
     */
    where?: DimShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimShifts to fetch.
     */
    orderBy?: DimShiftOrderByWithRelationInput | DimShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimShifts.
     */
    cursor?: DimShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimShifts.
     */
    skip?: number
    distinct?: DimShiftScalarFieldEnum | DimShiftScalarFieldEnum[]
  }

  /**
   * DimShift create
   */
  export type DimShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a DimShift.
     */
    data: XOR<DimShiftCreateInput, DimShiftUncheckedCreateInput>
  }

  /**
   * DimShift createMany
   */
  export type DimShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimShifts.
     */
    data: DimShiftCreateManyInput | DimShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimShift createManyAndReturn
   */
  export type DimShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimShifts.
     */
    data: DimShiftCreateManyInput | DimShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DimShift update
   */
  export type DimShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a DimShift.
     */
    data: XOR<DimShiftUpdateInput, DimShiftUncheckedUpdateInput>
    /**
     * Choose, which DimShift to update.
     */
    where: DimShiftWhereUniqueInput
  }

  /**
   * DimShift updateMany
   */
  export type DimShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimShifts.
     */
    data: XOR<DimShiftUpdateManyMutationInput, DimShiftUncheckedUpdateManyInput>
    /**
     * Filter which DimShifts to update
     */
    where?: DimShiftWhereInput
  }

  /**
   * DimShift upsert
   */
  export type DimShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the DimShift to update in case it exists.
     */
    where: DimShiftWhereUniqueInput
    /**
     * In case the DimShift found by the `where` argument doesn't exist, create a new DimShift with this data.
     */
    create: XOR<DimShiftCreateInput, DimShiftUncheckedCreateInput>
    /**
     * In case the DimShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimShiftUpdateInput, DimShiftUncheckedUpdateInput>
  }

  /**
   * DimShift delete
   */
  export type DimShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
    /**
     * Filter which DimShift to delete.
     */
    where: DimShiftWhereUniqueInput
  }

  /**
   * DimShift deleteMany
   */
  export type DimShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimShifts to delete
     */
    where?: DimShiftWhereInput
  }

  /**
   * DimShift.production
   */
  export type DimShift$productionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    where?: FactProductionWhereInput
    orderBy?: FactProductionOrderByWithRelationInput | FactProductionOrderByWithRelationInput[]
    cursor?: FactProductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactProductionScalarFieldEnum | FactProductionScalarFieldEnum[]
  }

  /**
   * DimShift without action
   */
  export type DimShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimShift
     */
    select?: DimShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimShiftInclude<ExtArgs> | null
  }


  /**
   * Model DimDowntimeReason
   */

  export type AggregateDimDowntimeReason = {
    _count: DimDowntimeReasonCountAggregateOutputType | null
    _avg: DimDowntimeReasonAvgAggregateOutputType | null
    _sum: DimDowntimeReasonSumAggregateOutputType | null
    _min: DimDowntimeReasonMinAggregateOutputType | null
    _max: DimDowntimeReasonMaxAggregateOutputType | null
  }

  export type DimDowntimeReasonAvgAggregateOutputType = {
    id: number | null
  }

  export type DimDowntimeReasonSumAggregateOutputType = {
    id: number | null
  }

  export type DimDowntimeReasonMinAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    category: string | null
    isPlanned: boolean | null
    affectsOee: boolean | null
    isFailure: boolean | null
  }

  export type DimDowntimeReasonMaxAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    category: string | null
    isPlanned: boolean | null
    affectsOee: boolean | null
    isFailure: boolean | null
  }

  export type DimDowntimeReasonCountAggregateOutputType = {
    id: number
    code: number
    description: number
    category: number
    isPlanned: number
    affectsOee: number
    isFailure: number
    _all: number
  }


  export type DimDowntimeReasonAvgAggregateInputType = {
    id?: true
  }

  export type DimDowntimeReasonSumAggregateInputType = {
    id?: true
  }

  export type DimDowntimeReasonMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    category?: true
    isPlanned?: true
    affectsOee?: true
    isFailure?: true
  }

  export type DimDowntimeReasonMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    category?: true
    isPlanned?: true
    affectsOee?: true
    isFailure?: true
  }

  export type DimDowntimeReasonCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    category?: true
    isPlanned?: true
    affectsOee?: true
    isFailure?: true
    _all?: true
  }

  export type DimDowntimeReasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimDowntimeReason to aggregate.
     */
    where?: DimDowntimeReasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimDowntimeReasons to fetch.
     */
    orderBy?: DimDowntimeReasonOrderByWithRelationInput | DimDowntimeReasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimDowntimeReasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimDowntimeReasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimDowntimeReasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimDowntimeReasons
    **/
    _count?: true | DimDowntimeReasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimDowntimeReasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimDowntimeReasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimDowntimeReasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimDowntimeReasonMaxAggregateInputType
  }

  export type GetDimDowntimeReasonAggregateType<T extends DimDowntimeReasonAggregateArgs> = {
        [P in keyof T & keyof AggregateDimDowntimeReason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimDowntimeReason[P]>
      : GetScalarType<T[P], AggregateDimDowntimeReason[P]>
  }




  export type DimDowntimeReasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimDowntimeReasonWhereInput
    orderBy?: DimDowntimeReasonOrderByWithAggregationInput | DimDowntimeReasonOrderByWithAggregationInput[]
    by: DimDowntimeReasonScalarFieldEnum[] | DimDowntimeReasonScalarFieldEnum
    having?: DimDowntimeReasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimDowntimeReasonCountAggregateInputType | true
    _avg?: DimDowntimeReasonAvgAggregateInputType
    _sum?: DimDowntimeReasonSumAggregateInputType
    _min?: DimDowntimeReasonMinAggregateInputType
    _max?: DimDowntimeReasonMaxAggregateInputType
  }

  export type DimDowntimeReasonGroupByOutputType = {
    id: number
    code: string
    description: string
    category: string
    isPlanned: boolean | null
    affectsOee: boolean | null
    isFailure: boolean | null
    _count: DimDowntimeReasonCountAggregateOutputType | null
    _avg: DimDowntimeReasonAvgAggregateOutputType | null
    _sum: DimDowntimeReasonSumAggregateOutputType | null
    _min: DimDowntimeReasonMinAggregateOutputType | null
    _max: DimDowntimeReasonMaxAggregateOutputType | null
  }

  type GetDimDowntimeReasonGroupByPayload<T extends DimDowntimeReasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimDowntimeReasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimDowntimeReasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimDowntimeReasonGroupByOutputType[P]>
            : GetScalarType<T[P], DimDowntimeReasonGroupByOutputType[P]>
        }
      >
    >


  export type DimDowntimeReasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    isPlanned?: boolean
    affectsOee?: boolean
    isFailure?: boolean
    downtime?: boolean | DimDowntimeReason$downtimeArgs<ExtArgs>
    _count?: boolean | DimDowntimeReasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimDowntimeReason"]>

  export type DimDowntimeReasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    isPlanned?: boolean
    affectsOee?: boolean
    isFailure?: boolean
  }, ExtArgs["result"]["dimDowntimeReason"]>

  export type DimDowntimeReasonSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    isPlanned?: boolean
    affectsOee?: boolean
    isFailure?: boolean
  }

  export type DimDowntimeReasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    downtime?: boolean | DimDowntimeReason$downtimeArgs<ExtArgs>
    _count?: boolean | DimDowntimeReasonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DimDowntimeReasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DimDowntimeReasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimDowntimeReason"
    objects: {
      downtime: Prisma.$FactDowntimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      description: string
      category: string
      isPlanned: boolean | null
      affectsOee: boolean | null
      isFailure: boolean | null
    }, ExtArgs["result"]["dimDowntimeReason"]>
    composites: {}
  }

  type DimDowntimeReasonGetPayload<S extends boolean | null | undefined | DimDowntimeReasonDefaultArgs> = $Result.GetResult<Prisma.$DimDowntimeReasonPayload, S>

  type DimDowntimeReasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimDowntimeReasonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimDowntimeReasonCountAggregateInputType | true
    }

  export interface DimDowntimeReasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimDowntimeReason'], meta: { name: 'DimDowntimeReason' } }
    /**
     * Find zero or one DimDowntimeReason that matches the filter.
     * @param {DimDowntimeReasonFindUniqueArgs} args - Arguments to find a DimDowntimeReason
     * @example
     * // Get one DimDowntimeReason
     * const dimDowntimeReason = await prisma.dimDowntimeReason.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimDowntimeReasonFindUniqueArgs>(args: SelectSubset<T, DimDowntimeReasonFindUniqueArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimDowntimeReason that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimDowntimeReasonFindUniqueOrThrowArgs} args - Arguments to find a DimDowntimeReason
     * @example
     * // Get one DimDowntimeReason
     * const dimDowntimeReason = await prisma.dimDowntimeReason.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimDowntimeReasonFindUniqueOrThrowArgs>(args: SelectSubset<T, DimDowntimeReasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimDowntimeReason that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDowntimeReasonFindFirstArgs} args - Arguments to find a DimDowntimeReason
     * @example
     * // Get one DimDowntimeReason
     * const dimDowntimeReason = await prisma.dimDowntimeReason.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimDowntimeReasonFindFirstArgs>(args?: SelectSubset<T, DimDowntimeReasonFindFirstArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimDowntimeReason that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDowntimeReasonFindFirstOrThrowArgs} args - Arguments to find a DimDowntimeReason
     * @example
     * // Get one DimDowntimeReason
     * const dimDowntimeReason = await prisma.dimDowntimeReason.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimDowntimeReasonFindFirstOrThrowArgs>(args?: SelectSubset<T, DimDowntimeReasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimDowntimeReasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDowntimeReasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimDowntimeReasons
     * const dimDowntimeReasons = await prisma.dimDowntimeReason.findMany()
     * 
     * // Get first 10 DimDowntimeReasons
     * const dimDowntimeReasons = await prisma.dimDowntimeReason.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimDowntimeReasonWithIdOnly = await prisma.dimDowntimeReason.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimDowntimeReasonFindManyArgs>(args?: SelectSubset<T, DimDowntimeReasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimDowntimeReason.
     * @param {DimDowntimeReasonCreateArgs} args - Arguments to create a DimDowntimeReason.
     * @example
     * // Create one DimDowntimeReason
     * const DimDowntimeReason = await prisma.dimDowntimeReason.create({
     *   data: {
     *     // ... data to create a DimDowntimeReason
     *   }
     * })
     * 
     */
    create<T extends DimDowntimeReasonCreateArgs>(args: SelectSubset<T, DimDowntimeReasonCreateArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimDowntimeReasons.
     * @param {DimDowntimeReasonCreateManyArgs} args - Arguments to create many DimDowntimeReasons.
     * @example
     * // Create many DimDowntimeReasons
     * const dimDowntimeReason = await prisma.dimDowntimeReason.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimDowntimeReasonCreateManyArgs>(args?: SelectSubset<T, DimDowntimeReasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimDowntimeReasons and returns the data saved in the database.
     * @param {DimDowntimeReasonCreateManyAndReturnArgs} args - Arguments to create many DimDowntimeReasons.
     * @example
     * // Create many DimDowntimeReasons
     * const dimDowntimeReason = await prisma.dimDowntimeReason.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimDowntimeReasons and only return the `id`
     * const dimDowntimeReasonWithIdOnly = await prisma.dimDowntimeReason.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimDowntimeReasonCreateManyAndReturnArgs>(args?: SelectSubset<T, DimDowntimeReasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimDowntimeReason.
     * @param {DimDowntimeReasonDeleteArgs} args - Arguments to delete one DimDowntimeReason.
     * @example
     * // Delete one DimDowntimeReason
     * const DimDowntimeReason = await prisma.dimDowntimeReason.delete({
     *   where: {
     *     // ... filter to delete one DimDowntimeReason
     *   }
     * })
     * 
     */
    delete<T extends DimDowntimeReasonDeleteArgs>(args: SelectSubset<T, DimDowntimeReasonDeleteArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimDowntimeReason.
     * @param {DimDowntimeReasonUpdateArgs} args - Arguments to update one DimDowntimeReason.
     * @example
     * // Update one DimDowntimeReason
     * const dimDowntimeReason = await prisma.dimDowntimeReason.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimDowntimeReasonUpdateArgs>(args: SelectSubset<T, DimDowntimeReasonUpdateArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimDowntimeReasons.
     * @param {DimDowntimeReasonDeleteManyArgs} args - Arguments to filter DimDowntimeReasons to delete.
     * @example
     * // Delete a few DimDowntimeReasons
     * const { count } = await prisma.dimDowntimeReason.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimDowntimeReasonDeleteManyArgs>(args?: SelectSubset<T, DimDowntimeReasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimDowntimeReasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDowntimeReasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimDowntimeReasons
     * const dimDowntimeReason = await prisma.dimDowntimeReason.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimDowntimeReasonUpdateManyArgs>(args: SelectSubset<T, DimDowntimeReasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimDowntimeReason.
     * @param {DimDowntimeReasonUpsertArgs} args - Arguments to update or create a DimDowntimeReason.
     * @example
     * // Update or create a DimDowntimeReason
     * const dimDowntimeReason = await prisma.dimDowntimeReason.upsert({
     *   create: {
     *     // ... data to create a DimDowntimeReason
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimDowntimeReason we want to update
     *   }
     * })
     */
    upsert<T extends DimDowntimeReasonUpsertArgs>(args: SelectSubset<T, DimDowntimeReasonUpsertArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimDowntimeReasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDowntimeReasonCountArgs} args - Arguments to filter DimDowntimeReasons to count.
     * @example
     * // Count the number of DimDowntimeReasons
     * const count = await prisma.dimDowntimeReason.count({
     *   where: {
     *     // ... the filter for the DimDowntimeReasons we want to count
     *   }
     * })
    **/
    count<T extends DimDowntimeReasonCountArgs>(
      args?: Subset<T, DimDowntimeReasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimDowntimeReasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimDowntimeReason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDowntimeReasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimDowntimeReasonAggregateArgs>(args: Subset<T, DimDowntimeReasonAggregateArgs>): Prisma.PrismaPromise<GetDimDowntimeReasonAggregateType<T>>

    /**
     * Group by DimDowntimeReason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDowntimeReasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimDowntimeReasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimDowntimeReasonGroupByArgs['orderBy'] }
        : { orderBy?: DimDowntimeReasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimDowntimeReasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimDowntimeReasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimDowntimeReason model
   */
  readonly fields: DimDowntimeReasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimDowntimeReason.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimDowntimeReasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    downtime<T extends DimDowntimeReason$downtimeArgs<ExtArgs> = {}>(args?: Subset<T, DimDowntimeReason$downtimeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimDowntimeReason model
   */ 
  interface DimDowntimeReasonFieldRefs {
    readonly id: FieldRef<"DimDowntimeReason", 'Int'>
    readonly code: FieldRef<"DimDowntimeReason", 'String'>
    readonly description: FieldRef<"DimDowntimeReason", 'String'>
    readonly category: FieldRef<"DimDowntimeReason", 'String'>
    readonly isPlanned: FieldRef<"DimDowntimeReason", 'Boolean'>
    readonly affectsOee: FieldRef<"DimDowntimeReason", 'Boolean'>
    readonly isFailure: FieldRef<"DimDowntimeReason", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DimDowntimeReason findUnique
   */
  export type DimDowntimeReasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * Filter, which DimDowntimeReason to fetch.
     */
    where: DimDowntimeReasonWhereUniqueInput
  }

  /**
   * DimDowntimeReason findUniqueOrThrow
   */
  export type DimDowntimeReasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * Filter, which DimDowntimeReason to fetch.
     */
    where: DimDowntimeReasonWhereUniqueInput
  }

  /**
   * DimDowntimeReason findFirst
   */
  export type DimDowntimeReasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * Filter, which DimDowntimeReason to fetch.
     */
    where?: DimDowntimeReasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimDowntimeReasons to fetch.
     */
    orderBy?: DimDowntimeReasonOrderByWithRelationInput | DimDowntimeReasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimDowntimeReasons.
     */
    cursor?: DimDowntimeReasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimDowntimeReasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimDowntimeReasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimDowntimeReasons.
     */
    distinct?: DimDowntimeReasonScalarFieldEnum | DimDowntimeReasonScalarFieldEnum[]
  }

  /**
   * DimDowntimeReason findFirstOrThrow
   */
  export type DimDowntimeReasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * Filter, which DimDowntimeReason to fetch.
     */
    where?: DimDowntimeReasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimDowntimeReasons to fetch.
     */
    orderBy?: DimDowntimeReasonOrderByWithRelationInput | DimDowntimeReasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimDowntimeReasons.
     */
    cursor?: DimDowntimeReasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimDowntimeReasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimDowntimeReasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimDowntimeReasons.
     */
    distinct?: DimDowntimeReasonScalarFieldEnum | DimDowntimeReasonScalarFieldEnum[]
  }

  /**
   * DimDowntimeReason findMany
   */
  export type DimDowntimeReasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * Filter, which DimDowntimeReasons to fetch.
     */
    where?: DimDowntimeReasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimDowntimeReasons to fetch.
     */
    orderBy?: DimDowntimeReasonOrderByWithRelationInput | DimDowntimeReasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimDowntimeReasons.
     */
    cursor?: DimDowntimeReasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimDowntimeReasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimDowntimeReasons.
     */
    skip?: number
    distinct?: DimDowntimeReasonScalarFieldEnum | DimDowntimeReasonScalarFieldEnum[]
  }

  /**
   * DimDowntimeReason create
   */
  export type DimDowntimeReasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * The data needed to create a DimDowntimeReason.
     */
    data: XOR<DimDowntimeReasonCreateInput, DimDowntimeReasonUncheckedCreateInput>
  }

  /**
   * DimDowntimeReason createMany
   */
  export type DimDowntimeReasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimDowntimeReasons.
     */
    data: DimDowntimeReasonCreateManyInput | DimDowntimeReasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimDowntimeReason createManyAndReturn
   */
  export type DimDowntimeReasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimDowntimeReasons.
     */
    data: DimDowntimeReasonCreateManyInput | DimDowntimeReasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimDowntimeReason update
   */
  export type DimDowntimeReasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * The data needed to update a DimDowntimeReason.
     */
    data: XOR<DimDowntimeReasonUpdateInput, DimDowntimeReasonUncheckedUpdateInput>
    /**
     * Choose, which DimDowntimeReason to update.
     */
    where: DimDowntimeReasonWhereUniqueInput
  }

  /**
   * DimDowntimeReason updateMany
   */
  export type DimDowntimeReasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimDowntimeReasons.
     */
    data: XOR<DimDowntimeReasonUpdateManyMutationInput, DimDowntimeReasonUncheckedUpdateManyInput>
    /**
     * Filter which DimDowntimeReasons to update
     */
    where?: DimDowntimeReasonWhereInput
  }

  /**
   * DimDowntimeReason upsert
   */
  export type DimDowntimeReasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * The filter to search for the DimDowntimeReason to update in case it exists.
     */
    where: DimDowntimeReasonWhereUniqueInput
    /**
     * In case the DimDowntimeReason found by the `where` argument doesn't exist, create a new DimDowntimeReason with this data.
     */
    create: XOR<DimDowntimeReasonCreateInput, DimDowntimeReasonUncheckedCreateInput>
    /**
     * In case the DimDowntimeReason was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimDowntimeReasonUpdateInput, DimDowntimeReasonUncheckedUpdateInput>
  }

  /**
   * DimDowntimeReason delete
   */
  export type DimDowntimeReasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
    /**
     * Filter which DimDowntimeReason to delete.
     */
    where: DimDowntimeReasonWhereUniqueInput
  }

  /**
   * DimDowntimeReason deleteMany
   */
  export type DimDowntimeReasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimDowntimeReasons to delete
     */
    where?: DimDowntimeReasonWhereInput
  }

  /**
   * DimDowntimeReason.downtime
   */
  export type DimDowntimeReason$downtimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    where?: FactDowntimeWhereInput
    orderBy?: FactDowntimeOrderByWithRelationInput | FactDowntimeOrderByWithRelationInput[]
    cursor?: FactDowntimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactDowntimeScalarFieldEnum | FactDowntimeScalarFieldEnum[]
  }

  /**
   * DimDowntimeReason without action
   */
  export type DimDowntimeReasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDowntimeReason
     */
    select?: DimDowntimeReasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimDowntimeReasonInclude<ExtArgs> | null
  }


  /**
   * Model DimUnit
   */

  export type AggregateDimUnit = {
    _count: DimUnitCountAggregateOutputType | null
    _avg: DimUnitAvgAggregateOutputType | null
    _sum: DimUnitSumAggregateOutputType | null
    _min: DimUnitMinAggregateOutputType | null
    _max: DimUnitMaxAggregateOutputType | null
  }

  export type DimUnitAvgAggregateOutputType = {
    id: number | null
  }

  export type DimUnitSumAggregateOutputType = {
    id: number | null
  }

  export type DimUnitMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    type: string | null
  }

  export type DimUnitMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    type: string | null
  }

  export type DimUnitCountAggregateOutputType = {
    id: number
    code: number
    name: number
    type: number
    _all: number
  }


  export type DimUnitAvgAggregateInputType = {
    id?: true
  }

  export type DimUnitSumAggregateInputType = {
    id?: true
  }

  export type DimUnitMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
  }

  export type DimUnitMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
  }

  export type DimUnitCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    _all?: true
  }

  export type DimUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimUnit to aggregate.
     */
    where?: DimUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimUnits to fetch.
     */
    orderBy?: DimUnitOrderByWithRelationInput | DimUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimUnits
    **/
    _count?: true | DimUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimUnitMaxAggregateInputType
  }

  export type GetDimUnitAggregateType<T extends DimUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateDimUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimUnit[P]>
      : GetScalarType<T[P], AggregateDimUnit[P]>
  }




  export type DimUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimUnitWhereInput
    orderBy?: DimUnitOrderByWithAggregationInput | DimUnitOrderByWithAggregationInput[]
    by: DimUnitScalarFieldEnum[] | DimUnitScalarFieldEnum
    having?: DimUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimUnitCountAggregateInputType | true
    _avg?: DimUnitAvgAggregateInputType
    _sum?: DimUnitSumAggregateInputType
    _min?: DimUnitMinAggregateInputType
    _max?: DimUnitMaxAggregateInputType
  }

  export type DimUnitGroupByOutputType = {
    id: number
    code: string
    name: string
    type: string
    _count: DimUnitCountAggregateOutputType | null
    _avg: DimUnitAvgAggregateOutputType | null
    _sum: DimUnitSumAggregateOutputType | null
    _min: DimUnitMinAggregateOutputType | null
    _max: DimUnitMaxAggregateOutputType | null
  }

  type GetDimUnitGroupByPayload<T extends DimUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimUnitGroupByOutputType[P]>
            : GetScalarType<T[P], DimUnitGroupByOutputType[P]>
        }
      >
    >


  export type DimUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    sensorEvents?: boolean | DimUnit$sensorEventsArgs<ExtArgs>
    _count?: boolean | DimUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dimUnit"]>

  export type DimUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
  }, ExtArgs["result"]["dimUnit"]>

  export type DimUnitSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
  }

  export type DimUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensorEvents?: boolean | DimUnit$sensorEventsArgs<ExtArgs>
    _count?: boolean | DimUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DimUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DimUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimUnit"
    objects: {
      sensorEvents: Prisma.$FactSensorEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      type: string
    }, ExtArgs["result"]["dimUnit"]>
    composites: {}
  }

  type DimUnitGetPayload<S extends boolean | null | undefined | DimUnitDefaultArgs> = $Result.GetResult<Prisma.$DimUnitPayload, S>

  type DimUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimUnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimUnitCountAggregateInputType | true
    }

  export interface DimUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimUnit'], meta: { name: 'DimUnit' } }
    /**
     * Find zero or one DimUnit that matches the filter.
     * @param {DimUnitFindUniqueArgs} args - Arguments to find a DimUnit
     * @example
     * // Get one DimUnit
     * const dimUnit = await prisma.dimUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimUnitFindUniqueArgs>(args: SelectSubset<T, DimUnitFindUniqueArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimUnit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimUnitFindUniqueOrThrowArgs} args - Arguments to find a DimUnit
     * @example
     * // Get one DimUnit
     * const dimUnit = await prisma.dimUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, DimUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUnitFindFirstArgs} args - Arguments to find a DimUnit
     * @example
     * // Get one DimUnit
     * const dimUnit = await prisma.dimUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimUnitFindFirstArgs>(args?: SelectSubset<T, DimUnitFindFirstArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUnitFindFirstOrThrowArgs} args - Arguments to find a DimUnit
     * @example
     * // Get one DimUnit
     * const dimUnit = await prisma.dimUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, DimUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimUnits
     * const dimUnits = await prisma.dimUnit.findMany()
     * 
     * // Get first 10 DimUnits
     * const dimUnits = await prisma.dimUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimUnitWithIdOnly = await prisma.dimUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimUnitFindManyArgs>(args?: SelectSubset<T, DimUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimUnit.
     * @param {DimUnitCreateArgs} args - Arguments to create a DimUnit.
     * @example
     * // Create one DimUnit
     * const DimUnit = await prisma.dimUnit.create({
     *   data: {
     *     // ... data to create a DimUnit
     *   }
     * })
     * 
     */
    create<T extends DimUnitCreateArgs>(args: SelectSubset<T, DimUnitCreateArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimUnits.
     * @param {DimUnitCreateManyArgs} args - Arguments to create many DimUnits.
     * @example
     * // Create many DimUnits
     * const dimUnit = await prisma.dimUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimUnitCreateManyArgs>(args?: SelectSubset<T, DimUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimUnits and returns the data saved in the database.
     * @param {DimUnitCreateManyAndReturnArgs} args - Arguments to create many DimUnits.
     * @example
     * // Create many DimUnits
     * const dimUnit = await prisma.dimUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimUnits and only return the `id`
     * const dimUnitWithIdOnly = await prisma.dimUnit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, DimUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimUnit.
     * @param {DimUnitDeleteArgs} args - Arguments to delete one DimUnit.
     * @example
     * // Delete one DimUnit
     * const DimUnit = await prisma.dimUnit.delete({
     *   where: {
     *     // ... filter to delete one DimUnit
     *   }
     * })
     * 
     */
    delete<T extends DimUnitDeleteArgs>(args: SelectSubset<T, DimUnitDeleteArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimUnit.
     * @param {DimUnitUpdateArgs} args - Arguments to update one DimUnit.
     * @example
     * // Update one DimUnit
     * const dimUnit = await prisma.dimUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimUnitUpdateArgs>(args: SelectSubset<T, DimUnitUpdateArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimUnits.
     * @param {DimUnitDeleteManyArgs} args - Arguments to filter DimUnits to delete.
     * @example
     * // Delete a few DimUnits
     * const { count } = await prisma.dimUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimUnitDeleteManyArgs>(args?: SelectSubset<T, DimUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimUnits
     * const dimUnit = await prisma.dimUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimUnitUpdateManyArgs>(args: SelectSubset<T, DimUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimUnit.
     * @param {DimUnitUpsertArgs} args - Arguments to update or create a DimUnit.
     * @example
     * // Update or create a DimUnit
     * const dimUnit = await prisma.dimUnit.upsert({
     *   create: {
     *     // ... data to create a DimUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimUnit we want to update
     *   }
     * })
     */
    upsert<T extends DimUnitUpsertArgs>(args: SelectSubset<T, DimUnitUpsertArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUnitCountArgs} args - Arguments to filter DimUnits to count.
     * @example
     * // Count the number of DimUnits
     * const count = await prisma.dimUnit.count({
     *   where: {
     *     // ... the filter for the DimUnits we want to count
     *   }
     * })
    **/
    count<T extends DimUnitCountArgs>(
      args?: Subset<T, DimUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimUnitAggregateArgs>(args: Subset<T, DimUnitAggregateArgs>): Prisma.PrismaPromise<GetDimUnitAggregateType<T>>

    /**
     * Group by DimUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimUnitGroupByArgs['orderBy'] }
        : { orderBy?: DimUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimUnit model
   */
  readonly fields: DimUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sensorEvents<T extends DimUnit$sensorEventsArgs<ExtArgs> = {}>(args?: Subset<T, DimUnit$sensorEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimUnit model
   */ 
  interface DimUnitFieldRefs {
    readonly id: FieldRef<"DimUnit", 'Int'>
    readonly code: FieldRef<"DimUnit", 'String'>
    readonly name: FieldRef<"DimUnit", 'String'>
    readonly type: FieldRef<"DimUnit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DimUnit findUnique
   */
  export type DimUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * Filter, which DimUnit to fetch.
     */
    where: DimUnitWhereUniqueInput
  }

  /**
   * DimUnit findUniqueOrThrow
   */
  export type DimUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * Filter, which DimUnit to fetch.
     */
    where: DimUnitWhereUniqueInput
  }

  /**
   * DimUnit findFirst
   */
  export type DimUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * Filter, which DimUnit to fetch.
     */
    where?: DimUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimUnits to fetch.
     */
    orderBy?: DimUnitOrderByWithRelationInput | DimUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimUnits.
     */
    cursor?: DimUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimUnits.
     */
    distinct?: DimUnitScalarFieldEnum | DimUnitScalarFieldEnum[]
  }

  /**
   * DimUnit findFirstOrThrow
   */
  export type DimUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * Filter, which DimUnit to fetch.
     */
    where?: DimUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimUnits to fetch.
     */
    orderBy?: DimUnitOrderByWithRelationInput | DimUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimUnits.
     */
    cursor?: DimUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimUnits.
     */
    distinct?: DimUnitScalarFieldEnum | DimUnitScalarFieldEnum[]
  }

  /**
   * DimUnit findMany
   */
  export type DimUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * Filter, which DimUnits to fetch.
     */
    where?: DimUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimUnits to fetch.
     */
    orderBy?: DimUnitOrderByWithRelationInput | DimUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimUnits.
     */
    cursor?: DimUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimUnits.
     */
    skip?: number
    distinct?: DimUnitScalarFieldEnum | DimUnitScalarFieldEnum[]
  }

  /**
   * DimUnit create
   */
  export type DimUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a DimUnit.
     */
    data: XOR<DimUnitCreateInput, DimUnitUncheckedCreateInput>
  }

  /**
   * DimUnit createMany
   */
  export type DimUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimUnits.
     */
    data: DimUnitCreateManyInput | DimUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimUnit createManyAndReturn
   */
  export type DimUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimUnits.
     */
    data: DimUnitCreateManyInput | DimUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimUnit update
   */
  export type DimUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a DimUnit.
     */
    data: XOR<DimUnitUpdateInput, DimUnitUncheckedUpdateInput>
    /**
     * Choose, which DimUnit to update.
     */
    where: DimUnitWhereUniqueInput
  }

  /**
   * DimUnit updateMany
   */
  export type DimUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimUnits.
     */
    data: XOR<DimUnitUpdateManyMutationInput, DimUnitUncheckedUpdateManyInput>
    /**
     * Filter which DimUnits to update
     */
    where?: DimUnitWhereInput
  }

  /**
   * DimUnit upsert
   */
  export type DimUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the DimUnit to update in case it exists.
     */
    where: DimUnitWhereUniqueInput
    /**
     * In case the DimUnit found by the `where` argument doesn't exist, create a new DimUnit with this data.
     */
    create: XOR<DimUnitCreateInput, DimUnitUncheckedCreateInput>
    /**
     * In case the DimUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimUnitUpdateInput, DimUnitUncheckedUpdateInput>
  }

  /**
   * DimUnit delete
   */
  export type DimUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    /**
     * Filter which DimUnit to delete.
     */
    where: DimUnitWhereUniqueInput
  }

  /**
   * DimUnit deleteMany
   */
  export type DimUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimUnits to delete
     */
    where?: DimUnitWhereInput
  }

  /**
   * DimUnit.sensorEvents
   */
  export type DimUnit$sensorEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    where?: FactSensorEventWhereInput
    orderBy?: FactSensorEventOrderByWithRelationInput | FactSensorEventOrderByWithRelationInput[]
    cursor?: FactSensorEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactSensorEventScalarFieldEnum | FactSensorEventScalarFieldEnum[]
  }

  /**
   * DimUnit without action
   */
  export type DimUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
  }


  /**
   * Model FactProduction
   */

  export type AggregateFactProduction = {
    _count: FactProductionCountAggregateOutputType | null
    _avg: FactProductionAvgAggregateOutputType | null
    _sum: FactProductionSumAggregateOutputType | null
    _min: FactProductionMinAggregateOutputType | null
    _max: FactProductionMaxAggregateOutputType | null
  }

  export type FactProductionAvgAggregateOutputType = {
    id: number | null
    dateId: number | null
    shiftId: number | null
    equipmentId: number | null
    productId: number | null
    plannedProductionTime: number | null
    operatingTime: number | null
    plannedParts: number | null
    totalPartsProduced: number | null
    goodParts: number | null
    scrapParts: number | null
    reworkParts: number | null
  }

  export type FactProductionSumAggregateOutputType = {
    id: number | null
    dateId: number | null
    shiftId: number | null
    equipmentId: number | null
    productId: number | null
    plannedProductionTime: bigint | null
    operatingTime: bigint | null
    plannedParts: number | null
    totalPartsProduced: number | null
    goodParts: number | null
    scrapParts: number | null
    reworkParts: number | null
  }

  export type FactProductionMinAggregateOutputType = {
    id: number | null
    dateId: number | null
    shiftId: number | null
    equipmentId: number | null
    productId: number | null
    orderNumber: string | null
    startTime: Date | null
    endTime: Date | null
    plannedProductionTime: bigint | null
    operatingTime: bigint | null
    plannedParts: number | null
    totalPartsProduced: number | null
    goodParts: number | null
    scrapParts: number | null
    reworkParts: number | null
    operatorId: string | null
    createdAt: Date | null
  }

  export type FactProductionMaxAggregateOutputType = {
    id: number | null
    dateId: number | null
    shiftId: number | null
    equipmentId: number | null
    productId: number | null
    orderNumber: string | null
    startTime: Date | null
    endTime: Date | null
    plannedProductionTime: bigint | null
    operatingTime: bigint | null
    plannedParts: number | null
    totalPartsProduced: number | null
    goodParts: number | null
    scrapParts: number | null
    reworkParts: number | null
    operatorId: string | null
    createdAt: Date | null
  }

  export type FactProductionCountAggregateOutputType = {
    id: number
    dateId: number
    shiftId: number
    equipmentId: number
    productId: number
    orderNumber: number
    startTime: number
    endTime: number
    plannedProductionTime: number
    operatingTime: number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts: number
    reworkParts: number
    operatorId: number
    createdAt: number
    _all: number
  }


  export type FactProductionAvgAggregateInputType = {
    id?: true
    dateId?: true
    shiftId?: true
    equipmentId?: true
    productId?: true
    plannedProductionTime?: true
    operatingTime?: true
    plannedParts?: true
    totalPartsProduced?: true
    goodParts?: true
    scrapParts?: true
    reworkParts?: true
  }

  export type FactProductionSumAggregateInputType = {
    id?: true
    dateId?: true
    shiftId?: true
    equipmentId?: true
    productId?: true
    plannedProductionTime?: true
    operatingTime?: true
    plannedParts?: true
    totalPartsProduced?: true
    goodParts?: true
    scrapParts?: true
    reworkParts?: true
  }

  export type FactProductionMinAggregateInputType = {
    id?: true
    dateId?: true
    shiftId?: true
    equipmentId?: true
    productId?: true
    orderNumber?: true
    startTime?: true
    endTime?: true
    plannedProductionTime?: true
    operatingTime?: true
    plannedParts?: true
    totalPartsProduced?: true
    goodParts?: true
    scrapParts?: true
    reworkParts?: true
    operatorId?: true
    createdAt?: true
  }

  export type FactProductionMaxAggregateInputType = {
    id?: true
    dateId?: true
    shiftId?: true
    equipmentId?: true
    productId?: true
    orderNumber?: true
    startTime?: true
    endTime?: true
    plannedProductionTime?: true
    operatingTime?: true
    plannedParts?: true
    totalPartsProduced?: true
    goodParts?: true
    scrapParts?: true
    reworkParts?: true
    operatorId?: true
    createdAt?: true
  }

  export type FactProductionCountAggregateInputType = {
    id?: true
    dateId?: true
    shiftId?: true
    equipmentId?: true
    productId?: true
    orderNumber?: true
    startTime?: true
    endTime?: true
    plannedProductionTime?: true
    operatingTime?: true
    plannedParts?: true
    totalPartsProduced?: true
    goodParts?: true
    scrapParts?: true
    reworkParts?: true
    operatorId?: true
    createdAt?: true
    _all?: true
  }

  export type FactProductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactProduction to aggregate.
     */
    where?: FactProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactProductions to fetch.
     */
    orderBy?: FactProductionOrderByWithRelationInput | FactProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FactProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FactProductions
    **/
    _count?: true | FactProductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactProductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactProductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactProductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactProductionMaxAggregateInputType
  }

  export type GetFactProductionAggregateType<T extends FactProductionAggregateArgs> = {
        [P in keyof T & keyof AggregateFactProduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactProduction[P]>
      : GetScalarType<T[P], AggregateFactProduction[P]>
  }




  export type FactProductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactProductionWhereInput
    orderBy?: FactProductionOrderByWithAggregationInput | FactProductionOrderByWithAggregationInput[]
    by: FactProductionScalarFieldEnum[] | FactProductionScalarFieldEnum
    having?: FactProductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactProductionCountAggregateInputType | true
    _avg?: FactProductionAvgAggregateInputType
    _sum?: FactProductionSumAggregateInputType
    _min?: FactProductionMinAggregateInputType
    _max?: FactProductionMaxAggregateInputType
  }

  export type FactProductionGroupByOutputType = {
    id: number
    dateId: number
    shiftId: number
    equipmentId: number
    productId: number
    orderNumber: string | null
    startTime: Date
    endTime: Date
    plannedProductionTime: bigint
    operatingTime: bigint
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts: number | null
    reworkParts: number | null
    operatorId: string | null
    createdAt: Date | null
    _count: FactProductionCountAggregateOutputType | null
    _avg: FactProductionAvgAggregateOutputType | null
    _sum: FactProductionSumAggregateOutputType | null
    _min: FactProductionMinAggregateOutputType | null
    _max: FactProductionMaxAggregateOutputType | null
  }

  type GetFactProductionGroupByPayload<T extends FactProductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactProductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactProductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactProductionGroupByOutputType[P]>
            : GetScalarType<T[P], FactProductionGroupByOutputType[P]>
        }
      >
    >


  export type FactProductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateId?: boolean
    shiftId?: boolean
    equipmentId?: boolean
    productId?: boolean
    orderNumber?: boolean
    startTime?: boolean
    endTime?: boolean
    plannedProductionTime?: boolean
    operatingTime?: boolean
    plannedParts?: boolean
    totalPartsProduced?: boolean
    goodParts?: boolean
    scrapParts?: boolean
    reworkParts?: boolean
    operatorId?: boolean
    createdAt?: boolean
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    product?: boolean | DimProductDefaultArgs<ExtArgs>
    shift?: boolean | DimShiftDefaultArgs<ExtArgs>
    downtime?: boolean | FactProduction$downtimeArgs<ExtArgs>
    scrap?: boolean | FactProduction$scrapArgs<ExtArgs>
    _count?: boolean | FactProductionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factProduction"]>

  export type FactProductionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateId?: boolean
    shiftId?: boolean
    equipmentId?: boolean
    productId?: boolean
    orderNumber?: boolean
    startTime?: boolean
    endTime?: boolean
    plannedProductionTime?: boolean
    operatingTime?: boolean
    plannedParts?: boolean
    totalPartsProduced?: boolean
    goodParts?: boolean
    scrapParts?: boolean
    reworkParts?: boolean
    operatorId?: boolean
    createdAt?: boolean
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    product?: boolean | DimProductDefaultArgs<ExtArgs>
    shift?: boolean | DimShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factProduction"]>

  export type FactProductionSelectScalar = {
    id?: boolean
    dateId?: boolean
    shiftId?: boolean
    equipmentId?: boolean
    productId?: boolean
    orderNumber?: boolean
    startTime?: boolean
    endTime?: boolean
    plannedProductionTime?: boolean
    operatingTime?: boolean
    plannedParts?: boolean
    totalPartsProduced?: boolean
    goodParts?: boolean
    scrapParts?: boolean
    reworkParts?: boolean
    operatorId?: boolean
    createdAt?: boolean
  }

  export type FactProductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    product?: boolean | DimProductDefaultArgs<ExtArgs>
    shift?: boolean | DimShiftDefaultArgs<ExtArgs>
    downtime?: boolean | FactProduction$downtimeArgs<ExtArgs>
    scrap?: boolean | FactProduction$scrapArgs<ExtArgs>
    _count?: boolean | FactProductionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FactProductionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    product?: boolean | DimProductDefaultArgs<ExtArgs>
    shift?: boolean | DimShiftDefaultArgs<ExtArgs>
  }

  export type $FactProductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FactProduction"
    objects: {
      equipment: Prisma.$DimEquipmentPayload<ExtArgs>
      product: Prisma.$DimProductPayload<ExtArgs>
      shift: Prisma.$DimShiftPayload<ExtArgs>
      downtime: Prisma.$FactDowntimePayload<ExtArgs>[]
      scrap: Prisma.$FactScrapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dateId: number
      shiftId: number
      equipmentId: number
      productId: number
      orderNumber: string | null
      startTime: Date
      endTime: Date
      plannedProductionTime: bigint
      operatingTime: bigint
      plannedParts: number
      totalPartsProduced: number
      goodParts: number
      scrapParts: number | null
      reworkParts: number | null
      operatorId: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["factProduction"]>
    composites: {}
  }

  type FactProductionGetPayload<S extends boolean | null | undefined | FactProductionDefaultArgs> = $Result.GetResult<Prisma.$FactProductionPayload, S>

  type FactProductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FactProductionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FactProductionCountAggregateInputType | true
    }

  export interface FactProductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FactProduction'], meta: { name: 'FactProduction' } }
    /**
     * Find zero or one FactProduction that matches the filter.
     * @param {FactProductionFindUniqueArgs} args - Arguments to find a FactProduction
     * @example
     * // Get one FactProduction
     * const factProduction = await prisma.factProduction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactProductionFindUniqueArgs>(args: SelectSubset<T, FactProductionFindUniqueArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FactProduction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FactProductionFindUniqueOrThrowArgs} args - Arguments to find a FactProduction
     * @example
     * // Get one FactProduction
     * const factProduction = await prisma.factProduction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactProductionFindUniqueOrThrowArgs>(args: SelectSubset<T, FactProductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FactProduction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactProductionFindFirstArgs} args - Arguments to find a FactProduction
     * @example
     * // Get one FactProduction
     * const factProduction = await prisma.factProduction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactProductionFindFirstArgs>(args?: SelectSubset<T, FactProductionFindFirstArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FactProduction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactProductionFindFirstOrThrowArgs} args - Arguments to find a FactProduction
     * @example
     * // Get one FactProduction
     * const factProduction = await prisma.factProduction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactProductionFindFirstOrThrowArgs>(args?: SelectSubset<T, FactProductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FactProductions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactProductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactProductions
     * const factProductions = await prisma.factProduction.findMany()
     * 
     * // Get first 10 FactProductions
     * const factProductions = await prisma.factProduction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factProductionWithIdOnly = await prisma.factProduction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FactProductionFindManyArgs>(args?: SelectSubset<T, FactProductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FactProduction.
     * @param {FactProductionCreateArgs} args - Arguments to create a FactProduction.
     * @example
     * // Create one FactProduction
     * const FactProduction = await prisma.factProduction.create({
     *   data: {
     *     // ... data to create a FactProduction
     *   }
     * })
     * 
     */
    create<T extends FactProductionCreateArgs>(args: SelectSubset<T, FactProductionCreateArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FactProductions.
     * @param {FactProductionCreateManyArgs} args - Arguments to create many FactProductions.
     * @example
     * // Create many FactProductions
     * const factProduction = await prisma.factProduction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FactProductionCreateManyArgs>(args?: SelectSubset<T, FactProductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactProductions and returns the data saved in the database.
     * @param {FactProductionCreateManyAndReturnArgs} args - Arguments to create many FactProductions.
     * @example
     * // Create many FactProductions
     * const factProduction = await prisma.factProduction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FactProductions and only return the `id`
     * const factProductionWithIdOnly = await prisma.factProduction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FactProductionCreateManyAndReturnArgs>(args?: SelectSubset<T, FactProductionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FactProduction.
     * @param {FactProductionDeleteArgs} args - Arguments to delete one FactProduction.
     * @example
     * // Delete one FactProduction
     * const FactProduction = await prisma.factProduction.delete({
     *   where: {
     *     // ... filter to delete one FactProduction
     *   }
     * })
     * 
     */
    delete<T extends FactProductionDeleteArgs>(args: SelectSubset<T, FactProductionDeleteArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FactProduction.
     * @param {FactProductionUpdateArgs} args - Arguments to update one FactProduction.
     * @example
     * // Update one FactProduction
     * const factProduction = await prisma.factProduction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FactProductionUpdateArgs>(args: SelectSubset<T, FactProductionUpdateArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FactProductions.
     * @param {FactProductionDeleteManyArgs} args - Arguments to filter FactProductions to delete.
     * @example
     * // Delete a few FactProductions
     * const { count } = await prisma.factProduction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FactProductionDeleteManyArgs>(args?: SelectSubset<T, FactProductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactProductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactProductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactProductions
     * const factProduction = await prisma.factProduction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FactProductionUpdateManyArgs>(args: SelectSubset<T, FactProductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FactProduction.
     * @param {FactProductionUpsertArgs} args - Arguments to update or create a FactProduction.
     * @example
     * // Update or create a FactProduction
     * const factProduction = await prisma.factProduction.upsert({
     *   create: {
     *     // ... data to create a FactProduction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactProduction we want to update
     *   }
     * })
     */
    upsert<T extends FactProductionUpsertArgs>(args: SelectSubset<T, FactProductionUpsertArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FactProductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactProductionCountArgs} args - Arguments to filter FactProductions to count.
     * @example
     * // Count the number of FactProductions
     * const count = await prisma.factProduction.count({
     *   where: {
     *     // ... the filter for the FactProductions we want to count
     *   }
     * })
    **/
    count<T extends FactProductionCountArgs>(
      args?: Subset<T, FactProductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactProductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactProduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactProductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactProductionAggregateArgs>(args: Subset<T, FactProductionAggregateArgs>): Prisma.PrismaPromise<GetFactProductionAggregateType<T>>

    /**
     * Group by FactProduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactProductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FactProductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactProductionGroupByArgs['orderBy'] }
        : { orderBy?: FactProductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FactProductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactProductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FactProduction model
   */
  readonly fields: FactProductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactProduction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactProductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends DimEquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimEquipmentDefaultArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends DimProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimProductDefaultArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shift<T extends DimShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimShiftDefaultArgs<ExtArgs>>): Prisma__DimShiftClient<$Result.GetResult<Prisma.$DimShiftPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    downtime<T extends FactProduction$downtimeArgs<ExtArgs> = {}>(args?: Subset<T, FactProduction$downtimeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "findMany"> | Null>
    scrap<T extends FactProduction$scrapArgs<ExtArgs> = {}>(args?: Subset<T, FactProduction$scrapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FactProduction model
   */ 
  interface FactProductionFieldRefs {
    readonly id: FieldRef<"FactProduction", 'Int'>
    readonly dateId: FieldRef<"FactProduction", 'Int'>
    readonly shiftId: FieldRef<"FactProduction", 'Int'>
    readonly equipmentId: FieldRef<"FactProduction", 'Int'>
    readonly productId: FieldRef<"FactProduction", 'Int'>
    readonly orderNumber: FieldRef<"FactProduction", 'String'>
    readonly startTime: FieldRef<"FactProduction", 'DateTime'>
    readonly endTime: FieldRef<"FactProduction", 'DateTime'>
    readonly plannedProductionTime: FieldRef<"FactProduction", 'BigInt'>
    readonly operatingTime: FieldRef<"FactProduction", 'BigInt'>
    readonly plannedParts: FieldRef<"FactProduction", 'Int'>
    readonly totalPartsProduced: FieldRef<"FactProduction", 'Int'>
    readonly goodParts: FieldRef<"FactProduction", 'Int'>
    readonly scrapParts: FieldRef<"FactProduction", 'Int'>
    readonly reworkParts: FieldRef<"FactProduction", 'Int'>
    readonly operatorId: FieldRef<"FactProduction", 'String'>
    readonly createdAt: FieldRef<"FactProduction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FactProduction findUnique
   */
  export type FactProductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * Filter, which FactProduction to fetch.
     */
    where: FactProductionWhereUniqueInput
  }

  /**
   * FactProduction findUniqueOrThrow
   */
  export type FactProductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * Filter, which FactProduction to fetch.
     */
    where: FactProductionWhereUniqueInput
  }

  /**
   * FactProduction findFirst
   */
  export type FactProductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * Filter, which FactProduction to fetch.
     */
    where?: FactProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactProductions to fetch.
     */
    orderBy?: FactProductionOrderByWithRelationInput | FactProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactProductions.
     */
    cursor?: FactProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactProductions.
     */
    distinct?: FactProductionScalarFieldEnum | FactProductionScalarFieldEnum[]
  }

  /**
   * FactProduction findFirstOrThrow
   */
  export type FactProductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * Filter, which FactProduction to fetch.
     */
    where?: FactProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactProductions to fetch.
     */
    orderBy?: FactProductionOrderByWithRelationInput | FactProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactProductions.
     */
    cursor?: FactProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactProductions.
     */
    distinct?: FactProductionScalarFieldEnum | FactProductionScalarFieldEnum[]
  }

  /**
   * FactProduction findMany
   */
  export type FactProductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * Filter, which FactProductions to fetch.
     */
    where?: FactProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactProductions to fetch.
     */
    orderBy?: FactProductionOrderByWithRelationInput | FactProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FactProductions.
     */
    cursor?: FactProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactProductions.
     */
    skip?: number
    distinct?: FactProductionScalarFieldEnum | FactProductionScalarFieldEnum[]
  }

  /**
   * FactProduction create
   */
  export type FactProductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * The data needed to create a FactProduction.
     */
    data: XOR<FactProductionCreateInput, FactProductionUncheckedCreateInput>
  }

  /**
   * FactProduction createMany
   */
  export type FactProductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FactProductions.
     */
    data: FactProductionCreateManyInput | FactProductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactProduction createManyAndReturn
   */
  export type FactProductionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FactProductions.
     */
    data: FactProductionCreateManyInput | FactProductionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FactProduction update
   */
  export type FactProductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * The data needed to update a FactProduction.
     */
    data: XOR<FactProductionUpdateInput, FactProductionUncheckedUpdateInput>
    /**
     * Choose, which FactProduction to update.
     */
    where: FactProductionWhereUniqueInput
  }

  /**
   * FactProduction updateMany
   */
  export type FactProductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FactProductions.
     */
    data: XOR<FactProductionUpdateManyMutationInput, FactProductionUncheckedUpdateManyInput>
    /**
     * Filter which FactProductions to update
     */
    where?: FactProductionWhereInput
  }

  /**
   * FactProduction upsert
   */
  export type FactProductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * The filter to search for the FactProduction to update in case it exists.
     */
    where: FactProductionWhereUniqueInput
    /**
     * In case the FactProduction found by the `where` argument doesn't exist, create a new FactProduction with this data.
     */
    create: XOR<FactProductionCreateInput, FactProductionUncheckedCreateInput>
    /**
     * In case the FactProduction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactProductionUpdateInput, FactProductionUncheckedUpdateInput>
  }

  /**
   * FactProduction delete
   */
  export type FactProductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    /**
     * Filter which FactProduction to delete.
     */
    where: FactProductionWhereUniqueInput
  }

  /**
   * FactProduction deleteMany
   */
  export type FactProductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactProductions to delete
     */
    where?: FactProductionWhereInput
  }

  /**
   * FactProduction.downtime
   */
  export type FactProduction$downtimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    where?: FactDowntimeWhereInput
    orderBy?: FactDowntimeOrderByWithRelationInput | FactDowntimeOrderByWithRelationInput[]
    cursor?: FactDowntimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactDowntimeScalarFieldEnum | FactDowntimeScalarFieldEnum[]
  }

  /**
   * FactProduction.scrap
   */
  export type FactProduction$scrapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    where?: FactScrapWhereInput
    orderBy?: FactScrapOrderByWithRelationInput | FactScrapOrderByWithRelationInput[]
    cursor?: FactScrapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactScrapScalarFieldEnum | FactScrapScalarFieldEnum[]
  }

  /**
   * FactProduction without action
   */
  export type FactProductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
  }


  /**
   * Model FactDowntime
   */

  export type AggregateFactDowntime = {
    _count: FactDowntimeCountAggregateOutputType | null
    _avg: FactDowntimeAvgAggregateOutputType | null
    _sum: FactDowntimeSumAggregateOutputType | null
    _min: FactDowntimeMinAggregateOutputType | null
    _max: FactDowntimeMaxAggregateOutputType | null
  }

  export type FactDowntimeAvgAggregateOutputType = {
    id: number | null
    productionId: number | null
    equipmentId: number | null
    reasonId: number | null
    downtimeDuration: number | null
  }

  export type FactDowntimeSumAggregateOutputType = {
    id: number | null
    productionId: number | null
    equipmentId: number | null
    reasonId: number | null
    downtimeDuration: bigint | null
  }

  export type FactDowntimeMinAggregateOutputType = {
    id: number | null
    productionId: number | null
    equipmentId: number | null
    reasonId: number | null
    startTime: Date | null
    endTime: Date | null
    downtimeDuration: bigint | null
    comments: string | null
    createdAt: Date | null
  }

  export type FactDowntimeMaxAggregateOutputType = {
    id: number | null
    productionId: number | null
    equipmentId: number | null
    reasonId: number | null
    startTime: Date | null
    endTime: Date | null
    downtimeDuration: bigint | null
    comments: string | null
    createdAt: Date | null
  }

  export type FactDowntimeCountAggregateOutputType = {
    id: number
    productionId: number
    equipmentId: number
    reasonId: number
    startTime: number
    endTime: number
    downtimeDuration: number
    comments: number
    createdAt: number
    _all: number
  }


  export type FactDowntimeAvgAggregateInputType = {
    id?: true
    productionId?: true
    equipmentId?: true
    reasonId?: true
    downtimeDuration?: true
  }

  export type FactDowntimeSumAggregateInputType = {
    id?: true
    productionId?: true
    equipmentId?: true
    reasonId?: true
    downtimeDuration?: true
  }

  export type FactDowntimeMinAggregateInputType = {
    id?: true
    productionId?: true
    equipmentId?: true
    reasonId?: true
    startTime?: true
    endTime?: true
    downtimeDuration?: true
    comments?: true
    createdAt?: true
  }

  export type FactDowntimeMaxAggregateInputType = {
    id?: true
    productionId?: true
    equipmentId?: true
    reasonId?: true
    startTime?: true
    endTime?: true
    downtimeDuration?: true
    comments?: true
    createdAt?: true
  }

  export type FactDowntimeCountAggregateInputType = {
    id?: true
    productionId?: true
    equipmentId?: true
    reasonId?: true
    startTime?: true
    endTime?: true
    downtimeDuration?: true
    comments?: true
    createdAt?: true
    _all?: true
  }

  export type FactDowntimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactDowntime to aggregate.
     */
    where?: FactDowntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactDowntimes to fetch.
     */
    orderBy?: FactDowntimeOrderByWithRelationInput | FactDowntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FactDowntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactDowntimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactDowntimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FactDowntimes
    **/
    _count?: true | FactDowntimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactDowntimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactDowntimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactDowntimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactDowntimeMaxAggregateInputType
  }

  export type GetFactDowntimeAggregateType<T extends FactDowntimeAggregateArgs> = {
        [P in keyof T & keyof AggregateFactDowntime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactDowntime[P]>
      : GetScalarType<T[P], AggregateFactDowntime[P]>
  }




  export type FactDowntimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactDowntimeWhereInput
    orderBy?: FactDowntimeOrderByWithAggregationInput | FactDowntimeOrderByWithAggregationInput[]
    by: FactDowntimeScalarFieldEnum[] | FactDowntimeScalarFieldEnum
    having?: FactDowntimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactDowntimeCountAggregateInputType | true
    _avg?: FactDowntimeAvgAggregateInputType
    _sum?: FactDowntimeSumAggregateInputType
    _min?: FactDowntimeMinAggregateInputType
    _max?: FactDowntimeMaxAggregateInputType
  }

  export type FactDowntimeGroupByOutputType = {
    id: number
    productionId: number | null
    equipmentId: number
    reasonId: number
    startTime: Date
    endTime: Date
    downtimeDuration: bigint
    comments: string | null
    createdAt: Date | null
    _count: FactDowntimeCountAggregateOutputType | null
    _avg: FactDowntimeAvgAggregateOutputType | null
    _sum: FactDowntimeSumAggregateOutputType | null
    _min: FactDowntimeMinAggregateOutputType | null
    _max: FactDowntimeMaxAggregateOutputType | null
  }

  type GetFactDowntimeGroupByPayload<T extends FactDowntimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactDowntimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactDowntimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactDowntimeGroupByOutputType[P]>
            : GetScalarType<T[P], FactDowntimeGroupByOutputType[P]>
        }
      >
    >


  export type FactDowntimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    equipmentId?: boolean
    reasonId?: boolean
    startTime?: boolean
    endTime?: boolean
    downtimeDuration?: boolean
    comments?: boolean
    createdAt?: boolean
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    reason?: boolean | DimDowntimeReasonDefaultArgs<ExtArgs>
    production?: boolean | FactDowntime$productionArgs<ExtArgs>
  }, ExtArgs["result"]["factDowntime"]>

  export type FactDowntimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    equipmentId?: boolean
    reasonId?: boolean
    startTime?: boolean
    endTime?: boolean
    downtimeDuration?: boolean
    comments?: boolean
    createdAt?: boolean
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    reason?: boolean | DimDowntimeReasonDefaultArgs<ExtArgs>
    production?: boolean | FactDowntime$productionArgs<ExtArgs>
  }, ExtArgs["result"]["factDowntime"]>

  export type FactDowntimeSelectScalar = {
    id?: boolean
    productionId?: boolean
    equipmentId?: boolean
    reasonId?: boolean
    startTime?: boolean
    endTime?: boolean
    downtimeDuration?: boolean
    comments?: boolean
    createdAt?: boolean
  }

  export type FactDowntimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    reason?: boolean | DimDowntimeReasonDefaultArgs<ExtArgs>
    production?: boolean | FactDowntime$productionArgs<ExtArgs>
  }
  export type FactDowntimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    reason?: boolean | DimDowntimeReasonDefaultArgs<ExtArgs>
    production?: boolean | FactDowntime$productionArgs<ExtArgs>
  }

  export type $FactDowntimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FactDowntime"
    objects: {
      equipment: Prisma.$DimEquipmentPayload<ExtArgs>
      reason: Prisma.$DimDowntimeReasonPayload<ExtArgs>
      production: Prisma.$FactProductionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionId: number | null
      equipmentId: number
      reasonId: number
      startTime: Date
      endTime: Date
      downtimeDuration: bigint
      comments: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["factDowntime"]>
    composites: {}
  }

  type FactDowntimeGetPayload<S extends boolean | null | undefined | FactDowntimeDefaultArgs> = $Result.GetResult<Prisma.$FactDowntimePayload, S>

  type FactDowntimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FactDowntimeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FactDowntimeCountAggregateInputType | true
    }

  export interface FactDowntimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FactDowntime'], meta: { name: 'FactDowntime' } }
    /**
     * Find zero or one FactDowntime that matches the filter.
     * @param {FactDowntimeFindUniqueArgs} args - Arguments to find a FactDowntime
     * @example
     * // Get one FactDowntime
     * const factDowntime = await prisma.factDowntime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactDowntimeFindUniqueArgs>(args: SelectSubset<T, FactDowntimeFindUniqueArgs<ExtArgs>>): Prisma__FactDowntimeClient<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FactDowntime that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FactDowntimeFindUniqueOrThrowArgs} args - Arguments to find a FactDowntime
     * @example
     * // Get one FactDowntime
     * const factDowntime = await prisma.factDowntime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactDowntimeFindUniqueOrThrowArgs>(args: SelectSubset<T, FactDowntimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FactDowntimeClient<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FactDowntime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactDowntimeFindFirstArgs} args - Arguments to find a FactDowntime
     * @example
     * // Get one FactDowntime
     * const factDowntime = await prisma.factDowntime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactDowntimeFindFirstArgs>(args?: SelectSubset<T, FactDowntimeFindFirstArgs<ExtArgs>>): Prisma__FactDowntimeClient<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FactDowntime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactDowntimeFindFirstOrThrowArgs} args - Arguments to find a FactDowntime
     * @example
     * // Get one FactDowntime
     * const factDowntime = await prisma.factDowntime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactDowntimeFindFirstOrThrowArgs>(args?: SelectSubset<T, FactDowntimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FactDowntimeClient<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FactDowntimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactDowntimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactDowntimes
     * const factDowntimes = await prisma.factDowntime.findMany()
     * 
     * // Get first 10 FactDowntimes
     * const factDowntimes = await prisma.factDowntime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factDowntimeWithIdOnly = await prisma.factDowntime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FactDowntimeFindManyArgs>(args?: SelectSubset<T, FactDowntimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FactDowntime.
     * @param {FactDowntimeCreateArgs} args - Arguments to create a FactDowntime.
     * @example
     * // Create one FactDowntime
     * const FactDowntime = await prisma.factDowntime.create({
     *   data: {
     *     // ... data to create a FactDowntime
     *   }
     * })
     * 
     */
    create<T extends FactDowntimeCreateArgs>(args: SelectSubset<T, FactDowntimeCreateArgs<ExtArgs>>): Prisma__FactDowntimeClient<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FactDowntimes.
     * @param {FactDowntimeCreateManyArgs} args - Arguments to create many FactDowntimes.
     * @example
     * // Create many FactDowntimes
     * const factDowntime = await prisma.factDowntime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FactDowntimeCreateManyArgs>(args?: SelectSubset<T, FactDowntimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactDowntimes and returns the data saved in the database.
     * @param {FactDowntimeCreateManyAndReturnArgs} args - Arguments to create many FactDowntimes.
     * @example
     * // Create many FactDowntimes
     * const factDowntime = await prisma.factDowntime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FactDowntimes and only return the `id`
     * const factDowntimeWithIdOnly = await prisma.factDowntime.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FactDowntimeCreateManyAndReturnArgs>(args?: SelectSubset<T, FactDowntimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FactDowntime.
     * @param {FactDowntimeDeleteArgs} args - Arguments to delete one FactDowntime.
     * @example
     * // Delete one FactDowntime
     * const FactDowntime = await prisma.factDowntime.delete({
     *   where: {
     *     // ... filter to delete one FactDowntime
     *   }
     * })
     * 
     */
    delete<T extends FactDowntimeDeleteArgs>(args: SelectSubset<T, FactDowntimeDeleteArgs<ExtArgs>>): Prisma__FactDowntimeClient<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FactDowntime.
     * @param {FactDowntimeUpdateArgs} args - Arguments to update one FactDowntime.
     * @example
     * // Update one FactDowntime
     * const factDowntime = await prisma.factDowntime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FactDowntimeUpdateArgs>(args: SelectSubset<T, FactDowntimeUpdateArgs<ExtArgs>>): Prisma__FactDowntimeClient<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FactDowntimes.
     * @param {FactDowntimeDeleteManyArgs} args - Arguments to filter FactDowntimes to delete.
     * @example
     * // Delete a few FactDowntimes
     * const { count } = await prisma.factDowntime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FactDowntimeDeleteManyArgs>(args?: SelectSubset<T, FactDowntimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactDowntimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactDowntimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactDowntimes
     * const factDowntime = await prisma.factDowntime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FactDowntimeUpdateManyArgs>(args: SelectSubset<T, FactDowntimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FactDowntime.
     * @param {FactDowntimeUpsertArgs} args - Arguments to update or create a FactDowntime.
     * @example
     * // Update or create a FactDowntime
     * const factDowntime = await prisma.factDowntime.upsert({
     *   create: {
     *     // ... data to create a FactDowntime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactDowntime we want to update
     *   }
     * })
     */
    upsert<T extends FactDowntimeUpsertArgs>(args: SelectSubset<T, FactDowntimeUpsertArgs<ExtArgs>>): Prisma__FactDowntimeClient<$Result.GetResult<Prisma.$FactDowntimePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FactDowntimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactDowntimeCountArgs} args - Arguments to filter FactDowntimes to count.
     * @example
     * // Count the number of FactDowntimes
     * const count = await prisma.factDowntime.count({
     *   where: {
     *     // ... the filter for the FactDowntimes we want to count
     *   }
     * })
    **/
    count<T extends FactDowntimeCountArgs>(
      args?: Subset<T, FactDowntimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactDowntimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactDowntime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactDowntimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactDowntimeAggregateArgs>(args: Subset<T, FactDowntimeAggregateArgs>): Prisma.PrismaPromise<GetFactDowntimeAggregateType<T>>

    /**
     * Group by FactDowntime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactDowntimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FactDowntimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactDowntimeGroupByArgs['orderBy'] }
        : { orderBy?: FactDowntimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FactDowntimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactDowntimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FactDowntime model
   */
  readonly fields: FactDowntimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactDowntime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactDowntimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends DimEquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimEquipmentDefaultArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reason<T extends DimDowntimeReasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimDowntimeReasonDefaultArgs<ExtArgs>>): Prisma__DimDowntimeReasonClient<$Result.GetResult<Prisma.$DimDowntimeReasonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    production<T extends FactDowntime$productionArgs<ExtArgs> = {}>(args?: Subset<T, FactDowntime$productionArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FactDowntime model
   */ 
  interface FactDowntimeFieldRefs {
    readonly id: FieldRef<"FactDowntime", 'Int'>
    readonly productionId: FieldRef<"FactDowntime", 'Int'>
    readonly equipmentId: FieldRef<"FactDowntime", 'Int'>
    readonly reasonId: FieldRef<"FactDowntime", 'Int'>
    readonly startTime: FieldRef<"FactDowntime", 'DateTime'>
    readonly endTime: FieldRef<"FactDowntime", 'DateTime'>
    readonly downtimeDuration: FieldRef<"FactDowntime", 'BigInt'>
    readonly comments: FieldRef<"FactDowntime", 'String'>
    readonly createdAt: FieldRef<"FactDowntime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FactDowntime findUnique
   */
  export type FactDowntimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * Filter, which FactDowntime to fetch.
     */
    where: FactDowntimeWhereUniqueInput
  }

  /**
   * FactDowntime findUniqueOrThrow
   */
  export type FactDowntimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * Filter, which FactDowntime to fetch.
     */
    where: FactDowntimeWhereUniqueInput
  }

  /**
   * FactDowntime findFirst
   */
  export type FactDowntimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * Filter, which FactDowntime to fetch.
     */
    where?: FactDowntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactDowntimes to fetch.
     */
    orderBy?: FactDowntimeOrderByWithRelationInput | FactDowntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactDowntimes.
     */
    cursor?: FactDowntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactDowntimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactDowntimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactDowntimes.
     */
    distinct?: FactDowntimeScalarFieldEnum | FactDowntimeScalarFieldEnum[]
  }

  /**
   * FactDowntime findFirstOrThrow
   */
  export type FactDowntimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * Filter, which FactDowntime to fetch.
     */
    where?: FactDowntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactDowntimes to fetch.
     */
    orderBy?: FactDowntimeOrderByWithRelationInput | FactDowntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactDowntimes.
     */
    cursor?: FactDowntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactDowntimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactDowntimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactDowntimes.
     */
    distinct?: FactDowntimeScalarFieldEnum | FactDowntimeScalarFieldEnum[]
  }

  /**
   * FactDowntime findMany
   */
  export type FactDowntimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * Filter, which FactDowntimes to fetch.
     */
    where?: FactDowntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactDowntimes to fetch.
     */
    orderBy?: FactDowntimeOrderByWithRelationInput | FactDowntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FactDowntimes.
     */
    cursor?: FactDowntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactDowntimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactDowntimes.
     */
    skip?: number
    distinct?: FactDowntimeScalarFieldEnum | FactDowntimeScalarFieldEnum[]
  }

  /**
   * FactDowntime create
   */
  export type FactDowntimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * The data needed to create a FactDowntime.
     */
    data: XOR<FactDowntimeCreateInput, FactDowntimeUncheckedCreateInput>
  }

  /**
   * FactDowntime createMany
   */
  export type FactDowntimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FactDowntimes.
     */
    data: FactDowntimeCreateManyInput | FactDowntimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactDowntime createManyAndReturn
   */
  export type FactDowntimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FactDowntimes.
     */
    data: FactDowntimeCreateManyInput | FactDowntimeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FactDowntime update
   */
  export type FactDowntimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * The data needed to update a FactDowntime.
     */
    data: XOR<FactDowntimeUpdateInput, FactDowntimeUncheckedUpdateInput>
    /**
     * Choose, which FactDowntime to update.
     */
    where: FactDowntimeWhereUniqueInput
  }

  /**
   * FactDowntime updateMany
   */
  export type FactDowntimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FactDowntimes.
     */
    data: XOR<FactDowntimeUpdateManyMutationInput, FactDowntimeUncheckedUpdateManyInput>
    /**
     * Filter which FactDowntimes to update
     */
    where?: FactDowntimeWhereInput
  }

  /**
   * FactDowntime upsert
   */
  export type FactDowntimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * The filter to search for the FactDowntime to update in case it exists.
     */
    where: FactDowntimeWhereUniqueInput
    /**
     * In case the FactDowntime found by the `where` argument doesn't exist, create a new FactDowntime with this data.
     */
    create: XOR<FactDowntimeCreateInput, FactDowntimeUncheckedCreateInput>
    /**
     * In case the FactDowntime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactDowntimeUpdateInput, FactDowntimeUncheckedUpdateInput>
  }

  /**
   * FactDowntime delete
   */
  export type FactDowntimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
    /**
     * Filter which FactDowntime to delete.
     */
    where: FactDowntimeWhereUniqueInput
  }

  /**
   * FactDowntime deleteMany
   */
  export type FactDowntimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactDowntimes to delete
     */
    where?: FactDowntimeWhereInput
  }

  /**
   * FactDowntime.production
   */
  export type FactDowntime$productionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactProduction
     */
    select?: FactProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactProductionInclude<ExtArgs> | null
    where?: FactProductionWhereInput
  }

  /**
   * FactDowntime without action
   */
  export type FactDowntimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactDowntime
     */
    select?: FactDowntimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactDowntimeInclude<ExtArgs> | null
  }


  /**
   * Model FactScrap
   */

  export type AggregateFactScrap = {
    _count: FactScrapCountAggregateOutputType | null
    _avg: FactScrapAvgAggregateOutputType | null
    _sum: FactScrapSumAggregateOutputType | null
    _min: FactScrapMinAggregateOutputType | null
    _max: FactScrapMaxAggregateOutputType | null
  }

  export type FactScrapAvgAggregateOutputType = {
    id: number | null
    productionId: number | null
    productId: number | null
    scrapQty: number | null
    scrapCost: Decimal | null
  }

  export type FactScrapSumAggregateOutputType = {
    id: number | null
    productionId: number | null
    productId: number | null
    scrapQty: number | null
    scrapCost: Decimal | null
  }

  export type FactScrapMinAggregateOutputType = {
    id: number | null
    productionId: number | null
    productId: number | null
    scrapCode: string | null
    scrapQty: number | null
    scrapCost: Decimal | null
    createdAt: Date | null
  }

  export type FactScrapMaxAggregateOutputType = {
    id: number | null
    productionId: number | null
    productId: number | null
    scrapCode: string | null
    scrapQty: number | null
    scrapCost: Decimal | null
    createdAt: Date | null
  }

  export type FactScrapCountAggregateOutputType = {
    id: number
    productionId: number
    productId: number
    scrapCode: number
    scrapQty: number
    scrapCost: number
    createdAt: number
    _all: number
  }


  export type FactScrapAvgAggregateInputType = {
    id?: true
    productionId?: true
    productId?: true
    scrapQty?: true
    scrapCost?: true
  }

  export type FactScrapSumAggregateInputType = {
    id?: true
    productionId?: true
    productId?: true
    scrapQty?: true
    scrapCost?: true
  }

  export type FactScrapMinAggregateInputType = {
    id?: true
    productionId?: true
    productId?: true
    scrapCode?: true
    scrapQty?: true
    scrapCost?: true
    createdAt?: true
  }

  export type FactScrapMaxAggregateInputType = {
    id?: true
    productionId?: true
    productId?: true
    scrapCode?: true
    scrapQty?: true
    scrapCost?: true
    createdAt?: true
  }

  export type FactScrapCountAggregateInputType = {
    id?: true
    productionId?: true
    productId?: true
    scrapCode?: true
    scrapQty?: true
    scrapCost?: true
    createdAt?: true
    _all?: true
  }

  export type FactScrapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactScrap to aggregate.
     */
    where?: FactScrapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactScraps to fetch.
     */
    orderBy?: FactScrapOrderByWithRelationInput | FactScrapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FactScrapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactScraps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactScraps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FactScraps
    **/
    _count?: true | FactScrapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactScrapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactScrapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactScrapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactScrapMaxAggregateInputType
  }

  export type GetFactScrapAggregateType<T extends FactScrapAggregateArgs> = {
        [P in keyof T & keyof AggregateFactScrap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactScrap[P]>
      : GetScalarType<T[P], AggregateFactScrap[P]>
  }




  export type FactScrapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactScrapWhereInput
    orderBy?: FactScrapOrderByWithAggregationInput | FactScrapOrderByWithAggregationInput[]
    by: FactScrapScalarFieldEnum[] | FactScrapScalarFieldEnum
    having?: FactScrapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactScrapCountAggregateInputType | true
    _avg?: FactScrapAvgAggregateInputType
    _sum?: FactScrapSumAggregateInputType
    _min?: FactScrapMinAggregateInputType
    _max?: FactScrapMaxAggregateInputType
  }

  export type FactScrapGroupByOutputType = {
    id: number
    productionId: number
    productId: number
    scrapCode: string
    scrapQty: number
    scrapCost: Decimal | null
    createdAt: Date | null
    _count: FactScrapCountAggregateOutputType | null
    _avg: FactScrapAvgAggregateOutputType | null
    _sum: FactScrapSumAggregateOutputType | null
    _min: FactScrapMinAggregateOutputType | null
    _max: FactScrapMaxAggregateOutputType | null
  }

  type GetFactScrapGroupByPayload<T extends FactScrapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactScrapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactScrapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactScrapGroupByOutputType[P]>
            : GetScalarType<T[P], FactScrapGroupByOutputType[P]>
        }
      >
    >


  export type FactScrapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    productId?: boolean
    scrapCode?: boolean
    scrapQty?: boolean
    scrapCost?: boolean
    createdAt?: boolean
    product?: boolean | DimProductDefaultArgs<ExtArgs>
    production?: boolean | FactProductionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factScrap"]>

  export type FactScrapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    productId?: boolean
    scrapCode?: boolean
    scrapQty?: boolean
    scrapCost?: boolean
    createdAt?: boolean
    product?: boolean | DimProductDefaultArgs<ExtArgs>
    production?: boolean | FactProductionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factScrap"]>

  export type FactScrapSelectScalar = {
    id?: boolean
    productionId?: boolean
    productId?: boolean
    scrapCode?: boolean
    scrapQty?: boolean
    scrapCost?: boolean
    createdAt?: boolean
  }

  export type FactScrapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | DimProductDefaultArgs<ExtArgs>
    production?: boolean | FactProductionDefaultArgs<ExtArgs>
  }
  export type FactScrapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | DimProductDefaultArgs<ExtArgs>
    production?: boolean | FactProductionDefaultArgs<ExtArgs>
  }

  export type $FactScrapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FactScrap"
    objects: {
      product: Prisma.$DimProductPayload<ExtArgs>
      production: Prisma.$FactProductionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionId: number
      productId: number
      scrapCode: string
      scrapQty: number
      scrapCost: Prisma.Decimal | null
      createdAt: Date | null
    }, ExtArgs["result"]["factScrap"]>
    composites: {}
  }

  type FactScrapGetPayload<S extends boolean | null | undefined | FactScrapDefaultArgs> = $Result.GetResult<Prisma.$FactScrapPayload, S>

  type FactScrapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FactScrapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FactScrapCountAggregateInputType | true
    }

  export interface FactScrapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FactScrap'], meta: { name: 'FactScrap' } }
    /**
     * Find zero or one FactScrap that matches the filter.
     * @param {FactScrapFindUniqueArgs} args - Arguments to find a FactScrap
     * @example
     * // Get one FactScrap
     * const factScrap = await prisma.factScrap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactScrapFindUniqueArgs>(args: SelectSubset<T, FactScrapFindUniqueArgs<ExtArgs>>): Prisma__FactScrapClient<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FactScrap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FactScrapFindUniqueOrThrowArgs} args - Arguments to find a FactScrap
     * @example
     * // Get one FactScrap
     * const factScrap = await prisma.factScrap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactScrapFindUniqueOrThrowArgs>(args: SelectSubset<T, FactScrapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FactScrapClient<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FactScrap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactScrapFindFirstArgs} args - Arguments to find a FactScrap
     * @example
     * // Get one FactScrap
     * const factScrap = await prisma.factScrap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactScrapFindFirstArgs>(args?: SelectSubset<T, FactScrapFindFirstArgs<ExtArgs>>): Prisma__FactScrapClient<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FactScrap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactScrapFindFirstOrThrowArgs} args - Arguments to find a FactScrap
     * @example
     * // Get one FactScrap
     * const factScrap = await prisma.factScrap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactScrapFindFirstOrThrowArgs>(args?: SelectSubset<T, FactScrapFindFirstOrThrowArgs<ExtArgs>>): Prisma__FactScrapClient<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FactScraps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactScrapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactScraps
     * const factScraps = await prisma.factScrap.findMany()
     * 
     * // Get first 10 FactScraps
     * const factScraps = await prisma.factScrap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factScrapWithIdOnly = await prisma.factScrap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FactScrapFindManyArgs>(args?: SelectSubset<T, FactScrapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FactScrap.
     * @param {FactScrapCreateArgs} args - Arguments to create a FactScrap.
     * @example
     * // Create one FactScrap
     * const FactScrap = await prisma.factScrap.create({
     *   data: {
     *     // ... data to create a FactScrap
     *   }
     * })
     * 
     */
    create<T extends FactScrapCreateArgs>(args: SelectSubset<T, FactScrapCreateArgs<ExtArgs>>): Prisma__FactScrapClient<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FactScraps.
     * @param {FactScrapCreateManyArgs} args - Arguments to create many FactScraps.
     * @example
     * // Create many FactScraps
     * const factScrap = await prisma.factScrap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FactScrapCreateManyArgs>(args?: SelectSubset<T, FactScrapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactScraps and returns the data saved in the database.
     * @param {FactScrapCreateManyAndReturnArgs} args - Arguments to create many FactScraps.
     * @example
     * // Create many FactScraps
     * const factScrap = await prisma.factScrap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FactScraps and only return the `id`
     * const factScrapWithIdOnly = await prisma.factScrap.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FactScrapCreateManyAndReturnArgs>(args?: SelectSubset<T, FactScrapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FactScrap.
     * @param {FactScrapDeleteArgs} args - Arguments to delete one FactScrap.
     * @example
     * // Delete one FactScrap
     * const FactScrap = await prisma.factScrap.delete({
     *   where: {
     *     // ... filter to delete one FactScrap
     *   }
     * })
     * 
     */
    delete<T extends FactScrapDeleteArgs>(args: SelectSubset<T, FactScrapDeleteArgs<ExtArgs>>): Prisma__FactScrapClient<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FactScrap.
     * @param {FactScrapUpdateArgs} args - Arguments to update one FactScrap.
     * @example
     * // Update one FactScrap
     * const factScrap = await prisma.factScrap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FactScrapUpdateArgs>(args: SelectSubset<T, FactScrapUpdateArgs<ExtArgs>>): Prisma__FactScrapClient<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FactScraps.
     * @param {FactScrapDeleteManyArgs} args - Arguments to filter FactScraps to delete.
     * @example
     * // Delete a few FactScraps
     * const { count } = await prisma.factScrap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FactScrapDeleteManyArgs>(args?: SelectSubset<T, FactScrapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactScraps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactScrapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactScraps
     * const factScrap = await prisma.factScrap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FactScrapUpdateManyArgs>(args: SelectSubset<T, FactScrapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FactScrap.
     * @param {FactScrapUpsertArgs} args - Arguments to update or create a FactScrap.
     * @example
     * // Update or create a FactScrap
     * const factScrap = await prisma.factScrap.upsert({
     *   create: {
     *     // ... data to create a FactScrap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactScrap we want to update
     *   }
     * })
     */
    upsert<T extends FactScrapUpsertArgs>(args: SelectSubset<T, FactScrapUpsertArgs<ExtArgs>>): Prisma__FactScrapClient<$Result.GetResult<Prisma.$FactScrapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FactScraps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactScrapCountArgs} args - Arguments to filter FactScraps to count.
     * @example
     * // Count the number of FactScraps
     * const count = await prisma.factScrap.count({
     *   where: {
     *     // ... the filter for the FactScraps we want to count
     *   }
     * })
    **/
    count<T extends FactScrapCountArgs>(
      args?: Subset<T, FactScrapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactScrapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactScrap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactScrapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactScrapAggregateArgs>(args: Subset<T, FactScrapAggregateArgs>): Prisma.PrismaPromise<GetFactScrapAggregateType<T>>

    /**
     * Group by FactScrap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactScrapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FactScrapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactScrapGroupByArgs['orderBy'] }
        : { orderBy?: FactScrapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FactScrapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactScrapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FactScrap model
   */
  readonly fields: FactScrapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactScrap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactScrapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends DimProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimProductDefaultArgs<ExtArgs>>): Prisma__DimProductClient<$Result.GetResult<Prisma.$DimProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    production<T extends FactProductionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FactProductionDefaultArgs<ExtArgs>>): Prisma__FactProductionClient<$Result.GetResult<Prisma.$FactProductionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FactScrap model
   */ 
  interface FactScrapFieldRefs {
    readonly id: FieldRef<"FactScrap", 'Int'>
    readonly productionId: FieldRef<"FactScrap", 'Int'>
    readonly productId: FieldRef<"FactScrap", 'Int'>
    readonly scrapCode: FieldRef<"FactScrap", 'String'>
    readonly scrapQty: FieldRef<"FactScrap", 'Int'>
    readonly scrapCost: FieldRef<"FactScrap", 'Decimal'>
    readonly createdAt: FieldRef<"FactScrap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FactScrap findUnique
   */
  export type FactScrapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * Filter, which FactScrap to fetch.
     */
    where: FactScrapWhereUniqueInput
  }

  /**
   * FactScrap findUniqueOrThrow
   */
  export type FactScrapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * Filter, which FactScrap to fetch.
     */
    where: FactScrapWhereUniqueInput
  }

  /**
   * FactScrap findFirst
   */
  export type FactScrapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * Filter, which FactScrap to fetch.
     */
    where?: FactScrapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactScraps to fetch.
     */
    orderBy?: FactScrapOrderByWithRelationInput | FactScrapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactScraps.
     */
    cursor?: FactScrapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactScraps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactScraps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactScraps.
     */
    distinct?: FactScrapScalarFieldEnum | FactScrapScalarFieldEnum[]
  }

  /**
   * FactScrap findFirstOrThrow
   */
  export type FactScrapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * Filter, which FactScrap to fetch.
     */
    where?: FactScrapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactScraps to fetch.
     */
    orderBy?: FactScrapOrderByWithRelationInput | FactScrapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactScraps.
     */
    cursor?: FactScrapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactScraps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactScraps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactScraps.
     */
    distinct?: FactScrapScalarFieldEnum | FactScrapScalarFieldEnum[]
  }

  /**
   * FactScrap findMany
   */
  export type FactScrapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * Filter, which FactScraps to fetch.
     */
    where?: FactScrapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactScraps to fetch.
     */
    orderBy?: FactScrapOrderByWithRelationInput | FactScrapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FactScraps.
     */
    cursor?: FactScrapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactScraps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactScraps.
     */
    skip?: number
    distinct?: FactScrapScalarFieldEnum | FactScrapScalarFieldEnum[]
  }

  /**
   * FactScrap create
   */
  export type FactScrapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * The data needed to create a FactScrap.
     */
    data: XOR<FactScrapCreateInput, FactScrapUncheckedCreateInput>
  }

  /**
   * FactScrap createMany
   */
  export type FactScrapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FactScraps.
     */
    data: FactScrapCreateManyInput | FactScrapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactScrap createManyAndReturn
   */
  export type FactScrapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FactScraps.
     */
    data: FactScrapCreateManyInput | FactScrapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FactScrap update
   */
  export type FactScrapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * The data needed to update a FactScrap.
     */
    data: XOR<FactScrapUpdateInput, FactScrapUncheckedUpdateInput>
    /**
     * Choose, which FactScrap to update.
     */
    where: FactScrapWhereUniqueInput
  }

  /**
   * FactScrap updateMany
   */
  export type FactScrapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FactScraps.
     */
    data: XOR<FactScrapUpdateManyMutationInput, FactScrapUncheckedUpdateManyInput>
    /**
     * Filter which FactScraps to update
     */
    where?: FactScrapWhereInput
  }

  /**
   * FactScrap upsert
   */
  export type FactScrapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * The filter to search for the FactScrap to update in case it exists.
     */
    where: FactScrapWhereUniqueInput
    /**
     * In case the FactScrap found by the `where` argument doesn't exist, create a new FactScrap with this data.
     */
    create: XOR<FactScrapCreateInput, FactScrapUncheckedCreateInput>
    /**
     * In case the FactScrap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactScrapUpdateInput, FactScrapUncheckedUpdateInput>
  }

  /**
   * FactScrap delete
   */
  export type FactScrapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
    /**
     * Filter which FactScrap to delete.
     */
    where: FactScrapWhereUniqueInput
  }

  /**
   * FactScrap deleteMany
   */
  export type FactScrapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactScraps to delete
     */
    where?: FactScrapWhereInput
  }

  /**
   * FactScrap without action
   */
  export type FactScrapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactScrap
     */
    select?: FactScrapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactScrapInclude<ExtArgs> | null
  }


  /**
   * Model FactMaintenance
   */

  export type AggregateFactMaintenance = {
    _count: FactMaintenanceCountAggregateOutputType | null
    _avg: FactMaintenanceAvgAggregateOutputType | null
    _sum: FactMaintenanceSumAggregateOutputType | null
    _min: FactMaintenanceMinAggregateOutputType | null
    _max: FactMaintenanceMaxAggregateOutputType | null
  }

  export type FactMaintenanceAvgAggregateOutputType = {
    id: number | null
    equipmentId: number | null
    laborHours: Decimal | null
    materialCost: Decimal | null
  }

  export type FactMaintenanceSumAggregateOutputType = {
    id: number | null
    equipmentId: number | null
    laborHours: Decimal | null
    materialCost: Decimal | null
  }

  export type FactMaintenanceMinAggregateOutputType = {
    id: number | null
    equipmentId: number | null
    workOrderNumber: string | null
    maintenanceType: string | null
    startTime: Date | null
    endTime: Date | null
    laborHours: Decimal | null
    materialCost: Decimal | null
    description: string | null
    createdAt: Date | null
  }

  export type FactMaintenanceMaxAggregateOutputType = {
    id: number | null
    equipmentId: number | null
    workOrderNumber: string | null
    maintenanceType: string | null
    startTime: Date | null
    endTime: Date | null
    laborHours: Decimal | null
    materialCost: Decimal | null
    description: string | null
    createdAt: Date | null
  }

  export type FactMaintenanceCountAggregateOutputType = {
    id: number
    equipmentId: number
    workOrderNumber: number
    maintenanceType: number
    startTime: number
    endTime: number
    laborHours: number
    materialCost: number
    description: number
    createdAt: number
    _all: number
  }


  export type FactMaintenanceAvgAggregateInputType = {
    id?: true
    equipmentId?: true
    laborHours?: true
    materialCost?: true
  }

  export type FactMaintenanceSumAggregateInputType = {
    id?: true
    equipmentId?: true
    laborHours?: true
    materialCost?: true
  }

  export type FactMaintenanceMinAggregateInputType = {
    id?: true
    equipmentId?: true
    workOrderNumber?: true
    maintenanceType?: true
    startTime?: true
    endTime?: true
    laborHours?: true
    materialCost?: true
    description?: true
    createdAt?: true
  }

  export type FactMaintenanceMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    workOrderNumber?: true
    maintenanceType?: true
    startTime?: true
    endTime?: true
    laborHours?: true
    materialCost?: true
    description?: true
    createdAt?: true
  }

  export type FactMaintenanceCountAggregateInputType = {
    id?: true
    equipmentId?: true
    workOrderNumber?: true
    maintenanceType?: true
    startTime?: true
    endTime?: true
    laborHours?: true
    materialCost?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type FactMaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactMaintenance to aggregate.
     */
    where?: FactMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactMaintenances to fetch.
     */
    orderBy?: FactMaintenanceOrderByWithRelationInput | FactMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FactMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FactMaintenances
    **/
    _count?: true | FactMaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactMaintenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactMaintenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactMaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactMaintenanceMaxAggregateInputType
  }

  export type GetFactMaintenanceAggregateType<T extends FactMaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateFactMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactMaintenance[P]>
      : GetScalarType<T[P], AggregateFactMaintenance[P]>
  }




  export type FactMaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactMaintenanceWhereInput
    orderBy?: FactMaintenanceOrderByWithAggregationInput | FactMaintenanceOrderByWithAggregationInput[]
    by: FactMaintenanceScalarFieldEnum[] | FactMaintenanceScalarFieldEnum
    having?: FactMaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactMaintenanceCountAggregateInputType | true
    _avg?: FactMaintenanceAvgAggregateInputType
    _sum?: FactMaintenanceSumAggregateInputType
    _min?: FactMaintenanceMinAggregateInputType
    _max?: FactMaintenanceMaxAggregateInputType
  }

  export type FactMaintenanceGroupByOutputType = {
    id: number
    equipmentId: number
    workOrderNumber: string
    maintenanceType: string
    startTime: Date
    endTime: Date
    laborHours: Decimal | null
    materialCost: Decimal | null
    description: string | null
    createdAt: Date | null
    _count: FactMaintenanceCountAggregateOutputType | null
    _avg: FactMaintenanceAvgAggregateOutputType | null
    _sum: FactMaintenanceSumAggregateOutputType | null
    _min: FactMaintenanceMinAggregateOutputType | null
    _max: FactMaintenanceMaxAggregateOutputType | null
  }

  type GetFactMaintenanceGroupByPayload<T extends FactMaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactMaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactMaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactMaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], FactMaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type FactMaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    workOrderNumber?: boolean
    maintenanceType?: boolean
    startTime?: boolean
    endTime?: boolean
    laborHours?: boolean
    materialCost?: boolean
    description?: boolean
    createdAt?: boolean
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factMaintenance"]>

  export type FactMaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    workOrderNumber?: boolean
    maintenanceType?: boolean
    startTime?: boolean
    endTime?: boolean
    laborHours?: boolean
    materialCost?: boolean
    description?: boolean
    createdAt?: boolean
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factMaintenance"]>

  export type FactMaintenanceSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    workOrderNumber?: boolean
    maintenanceType?: boolean
    startTime?: boolean
    endTime?: boolean
    laborHours?: boolean
    materialCost?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type FactMaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
  }
  export type FactMaintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
  }

  export type $FactMaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FactMaintenance"
    objects: {
      equipment: Prisma.$DimEquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      equipmentId: number
      workOrderNumber: string
      maintenanceType: string
      startTime: Date
      endTime: Date
      laborHours: Prisma.Decimal | null
      materialCost: Prisma.Decimal | null
      description: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["factMaintenance"]>
    composites: {}
  }

  type FactMaintenanceGetPayload<S extends boolean | null | undefined | FactMaintenanceDefaultArgs> = $Result.GetResult<Prisma.$FactMaintenancePayload, S>

  type FactMaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FactMaintenanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FactMaintenanceCountAggregateInputType | true
    }

  export interface FactMaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FactMaintenance'], meta: { name: 'FactMaintenance' } }
    /**
     * Find zero or one FactMaintenance that matches the filter.
     * @param {FactMaintenanceFindUniqueArgs} args - Arguments to find a FactMaintenance
     * @example
     * // Get one FactMaintenance
     * const factMaintenance = await prisma.factMaintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactMaintenanceFindUniqueArgs>(args: SelectSubset<T, FactMaintenanceFindUniqueArgs<ExtArgs>>): Prisma__FactMaintenanceClient<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FactMaintenance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FactMaintenanceFindUniqueOrThrowArgs} args - Arguments to find a FactMaintenance
     * @example
     * // Get one FactMaintenance
     * const factMaintenance = await prisma.factMaintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactMaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, FactMaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FactMaintenanceClient<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FactMaintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactMaintenanceFindFirstArgs} args - Arguments to find a FactMaintenance
     * @example
     * // Get one FactMaintenance
     * const factMaintenance = await prisma.factMaintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactMaintenanceFindFirstArgs>(args?: SelectSubset<T, FactMaintenanceFindFirstArgs<ExtArgs>>): Prisma__FactMaintenanceClient<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FactMaintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactMaintenanceFindFirstOrThrowArgs} args - Arguments to find a FactMaintenance
     * @example
     * // Get one FactMaintenance
     * const factMaintenance = await prisma.factMaintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactMaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, FactMaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FactMaintenanceClient<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FactMaintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactMaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactMaintenances
     * const factMaintenances = await prisma.factMaintenance.findMany()
     * 
     * // Get first 10 FactMaintenances
     * const factMaintenances = await prisma.factMaintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factMaintenanceWithIdOnly = await prisma.factMaintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FactMaintenanceFindManyArgs>(args?: SelectSubset<T, FactMaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FactMaintenance.
     * @param {FactMaintenanceCreateArgs} args - Arguments to create a FactMaintenance.
     * @example
     * // Create one FactMaintenance
     * const FactMaintenance = await prisma.factMaintenance.create({
     *   data: {
     *     // ... data to create a FactMaintenance
     *   }
     * })
     * 
     */
    create<T extends FactMaintenanceCreateArgs>(args: SelectSubset<T, FactMaintenanceCreateArgs<ExtArgs>>): Prisma__FactMaintenanceClient<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FactMaintenances.
     * @param {FactMaintenanceCreateManyArgs} args - Arguments to create many FactMaintenances.
     * @example
     * // Create many FactMaintenances
     * const factMaintenance = await prisma.factMaintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FactMaintenanceCreateManyArgs>(args?: SelectSubset<T, FactMaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactMaintenances and returns the data saved in the database.
     * @param {FactMaintenanceCreateManyAndReturnArgs} args - Arguments to create many FactMaintenances.
     * @example
     * // Create many FactMaintenances
     * const factMaintenance = await prisma.factMaintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FactMaintenances and only return the `id`
     * const factMaintenanceWithIdOnly = await prisma.factMaintenance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FactMaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, FactMaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FactMaintenance.
     * @param {FactMaintenanceDeleteArgs} args - Arguments to delete one FactMaintenance.
     * @example
     * // Delete one FactMaintenance
     * const FactMaintenance = await prisma.factMaintenance.delete({
     *   where: {
     *     // ... filter to delete one FactMaintenance
     *   }
     * })
     * 
     */
    delete<T extends FactMaintenanceDeleteArgs>(args: SelectSubset<T, FactMaintenanceDeleteArgs<ExtArgs>>): Prisma__FactMaintenanceClient<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FactMaintenance.
     * @param {FactMaintenanceUpdateArgs} args - Arguments to update one FactMaintenance.
     * @example
     * // Update one FactMaintenance
     * const factMaintenance = await prisma.factMaintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FactMaintenanceUpdateArgs>(args: SelectSubset<T, FactMaintenanceUpdateArgs<ExtArgs>>): Prisma__FactMaintenanceClient<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FactMaintenances.
     * @param {FactMaintenanceDeleteManyArgs} args - Arguments to filter FactMaintenances to delete.
     * @example
     * // Delete a few FactMaintenances
     * const { count } = await prisma.factMaintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FactMaintenanceDeleteManyArgs>(args?: SelectSubset<T, FactMaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactMaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactMaintenances
     * const factMaintenance = await prisma.factMaintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FactMaintenanceUpdateManyArgs>(args: SelectSubset<T, FactMaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FactMaintenance.
     * @param {FactMaintenanceUpsertArgs} args - Arguments to update or create a FactMaintenance.
     * @example
     * // Update or create a FactMaintenance
     * const factMaintenance = await prisma.factMaintenance.upsert({
     *   create: {
     *     // ... data to create a FactMaintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactMaintenance we want to update
     *   }
     * })
     */
    upsert<T extends FactMaintenanceUpsertArgs>(args: SelectSubset<T, FactMaintenanceUpsertArgs<ExtArgs>>): Prisma__FactMaintenanceClient<$Result.GetResult<Prisma.$FactMaintenancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FactMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactMaintenanceCountArgs} args - Arguments to filter FactMaintenances to count.
     * @example
     * // Count the number of FactMaintenances
     * const count = await prisma.factMaintenance.count({
     *   where: {
     *     // ... the filter for the FactMaintenances we want to count
     *   }
     * })
    **/
    count<T extends FactMaintenanceCountArgs>(
      args?: Subset<T, FactMaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactMaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactMaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactMaintenanceAggregateArgs>(args: Subset<T, FactMaintenanceAggregateArgs>): Prisma.PrismaPromise<GetFactMaintenanceAggregateType<T>>

    /**
     * Group by FactMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactMaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FactMaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactMaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: FactMaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FactMaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FactMaintenance model
   */
  readonly fields: FactMaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactMaintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactMaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends DimEquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimEquipmentDefaultArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FactMaintenance model
   */ 
  interface FactMaintenanceFieldRefs {
    readonly id: FieldRef<"FactMaintenance", 'Int'>
    readonly equipmentId: FieldRef<"FactMaintenance", 'Int'>
    readonly workOrderNumber: FieldRef<"FactMaintenance", 'String'>
    readonly maintenanceType: FieldRef<"FactMaintenance", 'String'>
    readonly startTime: FieldRef<"FactMaintenance", 'DateTime'>
    readonly endTime: FieldRef<"FactMaintenance", 'DateTime'>
    readonly laborHours: FieldRef<"FactMaintenance", 'Decimal'>
    readonly materialCost: FieldRef<"FactMaintenance", 'Decimal'>
    readonly description: FieldRef<"FactMaintenance", 'String'>
    readonly createdAt: FieldRef<"FactMaintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FactMaintenance findUnique
   */
  export type FactMaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which FactMaintenance to fetch.
     */
    where: FactMaintenanceWhereUniqueInput
  }

  /**
   * FactMaintenance findUniqueOrThrow
   */
  export type FactMaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which FactMaintenance to fetch.
     */
    where: FactMaintenanceWhereUniqueInput
  }

  /**
   * FactMaintenance findFirst
   */
  export type FactMaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which FactMaintenance to fetch.
     */
    where?: FactMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactMaintenances to fetch.
     */
    orderBy?: FactMaintenanceOrderByWithRelationInput | FactMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactMaintenances.
     */
    cursor?: FactMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactMaintenances.
     */
    distinct?: FactMaintenanceScalarFieldEnum | FactMaintenanceScalarFieldEnum[]
  }

  /**
   * FactMaintenance findFirstOrThrow
   */
  export type FactMaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which FactMaintenance to fetch.
     */
    where?: FactMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactMaintenances to fetch.
     */
    orderBy?: FactMaintenanceOrderByWithRelationInput | FactMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactMaintenances.
     */
    cursor?: FactMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactMaintenances.
     */
    distinct?: FactMaintenanceScalarFieldEnum | FactMaintenanceScalarFieldEnum[]
  }

  /**
   * FactMaintenance findMany
   */
  export type FactMaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which FactMaintenances to fetch.
     */
    where?: FactMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactMaintenances to fetch.
     */
    orderBy?: FactMaintenanceOrderByWithRelationInput | FactMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FactMaintenances.
     */
    cursor?: FactMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactMaintenances.
     */
    skip?: number
    distinct?: FactMaintenanceScalarFieldEnum | FactMaintenanceScalarFieldEnum[]
  }

  /**
   * FactMaintenance create
   */
  export type FactMaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a FactMaintenance.
     */
    data: XOR<FactMaintenanceCreateInput, FactMaintenanceUncheckedCreateInput>
  }

  /**
   * FactMaintenance createMany
   */
  export type FactMaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FactMaintenances.
     */
    data: FactMaintenanceCreateManyInput | FactMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactMaintenance createManyAndReturn
   */
  export type FactMaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FactMaintenances.
     */
    data: FactMaintenanceCreateManyInput | FactMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FactMaintenance update
   */
  export type FactMaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a FactMaintenance.
     */
    data: XOR<FactMaintenanceUpdateInput, FactMaintenanceUncheckedUpdateInput>
    /**
     * Choose, which FactMaintenance to update.
     */
    where: FactMaintenanceWhereUniqueInput
  }

  /**
   * FactMaintenance updateMany
   */
  export type FactMaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FactMaintenances.
     */
    data: XOR<FactMaintenanceUpdateManyMutationInput, FactMaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which FactMaintenances to update
     */
    where?: FactMaintenanceWhereInput
  }

  /**
   * FactMaintenance upsert
   */
  export type FactMaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the FactMaintenance to update in case it exists.
     */
    where: FactMaintenanceWhereUniqueInput
    /**
     * In case the FactMaintenance found by the `where` argument doesn't exist, create a new FactMaintenance with this data.
     */
    create: XOR<FactMaintenanceCreateInput, FactMaintenanceUncheckedCreateInput>
    /**
     * In case the FactMaintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactMaintenanceUpdateInput, FactMaintenanceUncheckedUpdateInput>
  }

  /**
   * FactMaintenance delete
   */
  export type FactMaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
    /**
     * Filter which FactMaintenance to delete.
     */
    where: FactMaintenanceWhereUniqueInput
  }

  /**
   * FactMaintenance deleteMany
   */
  export type FactMaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactMaintenances to delete
     */
    where?: FactMaintenanceWhereInput
  }

  /**
   * FactMaintenance without action
   */
  export type FactMaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactMaintenance
     */
    select?: FactMaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactMaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model FactSensorEvent
   */

  export type AggregateFactSensorEvent = {
    _count: FactSensorEventCountAggregateOutputType | null
    _avg: FactSensorEventAvgAggregateOutputType | null
    _sum: FactSensorEventSumAggregateOutputType | null
    _min: FactSensorEventMinAggregateOutputType | null
    _max: FactSensorEventMaxAggregateOutputType | null
  }

  export type FactSensorEventAvgAggregateOutputType = {
    eventId: number | null
    equipmentId: number | null
    value: Decimal | null
    unitId: number | null
  }

  export type FactSensorEventSumAggregateOutputType = {
    eventId: bigint | null
    equipmentId: number | null
    value: Decimal | null
    unitId: number | null
  }

  export type FactSensorEventMinAggregateOutputType = {
    eventId: bigint | null
    equipmentId: number | null
    eventTs: Date | null
    parameter: string | null
    value: Decimal | null
    unitId: number | null
  }

  export type FactSensorEventMaxAggregateOutputType = {
    eventId: bigint | null
    equipmentId: number | null
    eventTs: Date | null
    parameter: string | null
    value: Decimal | null
    unitId: number | null
  }

  export type FactSensorEventCountAggregateOutputType = {
    eventId: number
    equipmentId: number
    eventTs: number
    parameter: number
    value: number
    unitId: number
    _all: number
  }


  export type FactSensorEventAvgAggregateInputType = {
    eventId?: true
    equipmentId?: true
    value?: true
    unitId?: true
  }

  export type FactSensorEventSumAggregateInputType = {
    eventId?: true
    equipmentId?: true
    value?: true
    unitId?: true
  }

  export type FactSensorEventMinAggregateInputType = {
    eventId?: true
    equipmentId?: true
    eventTs?: true
    parameter?: true
    value?: true
    unitId?: true
  }

  export type FactSensorEventMaxAggregateInputType = {
    eventId?: true
    equipmentId?: true
    eventTs?: true
    parameter?: true
    value?: true
    unitId?: true
  }

  export type FactSensorEventCountAggregateInputType = {
    eventId?: true
    equipmentId?: true
    eventTs?: true
    parameter?: true
    value?: true
    unitId?: true
    _all?: true
  }

  export type FactSensorEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactSensorEvent to aggregate.
     */
    where?: FactSensorEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactSensorEvents to fetch.
     */
    orderBy?: FactSensorEventOrderByWithRelationInput | FactSensorEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FactSensorEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactSensorEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactSensorEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FactSensorEvents
    **/
    _count?: true | FactSensorEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactSensorEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactSensorEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactSensorEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactSensorEventMaxAggregateInputType
  }

  export type GetFactSensorEventAggregateType<T extends FactSensorEventAggregateArgs> = {
        [P in keyof T & keyof AggregateFactSensorEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactSensorEvent[P]>
      : GetScalarType<T[P], AggregateFactSensorEvent[P]>
  }




  export type FactSensorEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactSensorEventWhereInput
    orderBy?: FactSensorEventOrderByWithAggregationInput | FactSensorEventOrderByWithAggregationInput[]
    by: FactSensorEventScalarFieldEnum[] | FactSensorEventScalarFieldEnum
    having?: FactSensorEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactSensorEventCountAggregateInputType | true
    _avg?: FactSensorEventAvgAggregateInputType
    _sum?: FactSensorEventSumAggregateInputType
    _min?: FactSensorEventMinAggregateInputType
    _max?: FactSensorEventMaxAggregateInputType
  }

  export type FactSensorEventGroupByOutputType = {
    eventId: bigint
    equipmentId: number
    eventTs: Date
    parameter: string
    value: Decimal
    unitId: number | null
    _count: FactSensorEventCountAggregateOutputType | null
    _avg: FactSensorEventAvgAggregateOutputType | null
    _sum: FactSensorEventSumAggregateOutputType | null
    _min: FactSensorEventMinAggregateOutputType | null
    _max: FactSensorEventMaxAggregateOutputType | null
  }

  type GetFactSensorEventGroupByPayload<T extends FactSensorEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactSensorEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactSensorEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactSensorEventGroupByOutputType[P]>
            : GetScalarType<T[P], FactSensorEventGroupByOutputType[P]>
        }
      >
    >


  export type FactSensorEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventId?: boolean
    equipmentId?: boolean
    eventTs?: boolean
    parameter?: boolean
    value?: boolean
    unitId?: boolean
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    unit?: boolean | FactSensorEvent$unitArgs<ExtArgs>
  }, ExtArgs["result"]["factSensorEvent"]>

  export type FactSensorEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventId?: boolean
    equipmentId?: boolean
    eventTs?: boolean
    parameter?: boolean
    value?: boolean
    unitId?: boolean
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    unit?: boolean | FactSensorEvent$unitArgs<ExtArgs>
  }, ExtArgs["result"]["factSensorEvent"]>

  export type FactSensorEventSelectScalar = {
    eventId?: boolean
    equipmentId?: boolean
    eventTs?: boolean
    parameter?: boolean
    value?: boolean
    unitId?: boolean
  }

  export type FactSensorEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    unit?: boolean | FactSensorEvent$unitArgs<ExtArgs>
  }
  export type FactSensorEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | DimEquipmentDefaultArgs<ExtArgs>
    unit?: boolean | FactSensorEvent$unitArgs<ExtArgs>
  }

  export type $FactSensorEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FactSensorEvent"
    objects: {
      equipment: Prisma.$DimEquipmentPayload<ExtArgs>
      unit: Prisma.$DimUnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      eventId: bigint
      equipmentId: number
      eventTs: Date
      parameter: string
      value: Prisma.Decimal
      unitId: number | null
    }, ExtArgs["result"]["factSensorEvent"]>
    composites: {}
  }

  type FactSensorEventGetPayload<S extends boolean | null | undefined | FactSensorEventDefaultArgs> = $Result.GetResult<Prisma.$FactSensorEventPayload, S>

  type FactSensorEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FactSensorEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FactSensorEventCountAggregateInputType | true
    }

  export interface FactSensorEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FactSensorEvent'], meta: { name: 'FactSensorEvent' } }
    /**
     * Find zero or one FactSensorEvent that matches the filter.
     * @param {FactSensorEventFindUniqueArgs} args - Arguments to find a FactSensorEvent
     * @example
     * // Get one FactSensorEvent
     * const factSensorEvent = await prisma.factSensorEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactSensorEventFindUniqueArgs>(args: SelectSubset<T, FactSensorEventFindUniqueArgs<ExtArgs>>): Prisma__FactSensorEventClient<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FactSensorEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FactSensorEventFindUniqueOrThrowArgs} args - Arguments to find a FactSensorEvent
     * @example
     * // Get one FactSensorEvent
     * const factSensorEvent = await prisma.factSensorEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactSensorEventFindUniqueOrThrowArgs>(args: SelectSubset<T, FactSensorEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FactSensorEventClient<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FactSensorEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSensorEventFindFirstArgs} args - Arguments to find a FactSensorEvent
     * @example
     * // Get one FactSensorEvent
     * const factSensorEvent = await prisma.factSensorEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactSensorEventFindFirstArgs>(args?: SelectSubset<T, FactSensorEventFindFirstArgs<ExtArgs>>): Prisma__FactSensorEventClient<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FactSensorEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSensorEventFindFirstOrThrowArgs} args - Arguments to find a FactSensorEvent
     * @example
     * // Get one FactSensorEvent
     * const factSensorEvent = await prisma.factSensorEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactSensorEventFindFirstOrThrowArgs>(args?: SelectSubset<T, FactSensorEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__FactSensorEventClient<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FactSensorEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSensorEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactSensorEvents
     * const factSensorEvents = await prisma.factSensorEvent.findMany()
     * 
     * // Get first 10 FactSensorEvents
     * const factSensorEvents = await prisma.factSensorEvent.findMany({ take: 10 })
     * 
     * // Only select the `eventId`
     * const factSensorEventWithEventIdOnly = await prisma.factSensorEvent.findMany({ select: { eventId: true } })
     * 
     */
    findMany<T extends FactSensorEventFindManyArgs>(args?: SelectSubset<T, FactSensorEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FactSensorEvent.
     * @param {FactSensorEventCreateArgs} args - Arguments to create a FactSensorEvent.
     * @example
     * // Create one FactSensorEvent
     * const FactSensorEvent = await prisma.factSensorEvent.create({
     *   data: {
     *     // ... data to create a FactSensorEvent
     *   }
     * })
     * 
     */
    create<T extends FactSensorEventCreateArgs>(args: SelectSubset<T, FactSensorEventCreateArgs<ExtArgs>>): Prisma__FactSensorEventClient<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FactSensorEvents.
     * @param {FactSensorEventCreateManyArgs} args - Arguments to create many FactSensorEvents.
     * @example
     * // Create many FactSensorEvents
     * const factSensorEvent = await prisma.factSensorEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FactSensorEventCreateManyArgs>(args?: SelectSubset<T, FactSensorEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactSensorEvents and returns the data saved in the database.
     * @param {FactSensorEventCreateManyAndReturnArgs} args - Arguments to create many FactSensorEvents.
     * @example
     * // Create many FactSensorEvents
     * const factSensorEvent = await prisma.factSensorEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FactSensorEvents and only return the `eventId`
     * const factSensorEventWithEventIdOnly = await prisma.factSensorEvent.createManyAndReturn({ 
     *   select: { eventId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FactSensorEventCreateManyAndReturnArgs>(args?: SelectSubset<T, FactSensorEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FactSensorEvent.
     * @param {FactSensorEventDeleteArgs} args - Arguments to delete one FactSensorEvent.
     * @example
     * // Delete one FactSensorEvent
     * const FactSensorEvent = await prisma.factSensorEvent.delete({
     *   where: {
     *     // ... filter to delete one FactSensorEvent
     *   }
     * })
     * 
     */
    delete<T extends FactSensorEventDeleteArgs>(args: SelectSubset<T, FactSensorEventDeleteArgs<ExtArgs>>): Prisma__FactSensorEventClient<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FactSensorEvent.
     * @param {FactSensorEventUpdateArgs} args - Arguments to update one FactSensorEvent.
     * @example
     * // Update one FactSensorEvent
     * const factSensorEvent = await prisma.factSensorEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FactSensorEventUpdateArgs>(args: SelectSubset<T, FactSensorEventUpdateArgs<ExtArgs>>): Prisma__FactSensorEventClient<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FactSensorEvents.
     * @param {FactSensorEventDeleteManyArgs} args - Arguments to filter FactSensorEvents to delete.
     * @example
     * // Delete a few FactSensorEvents
     * const { count } = await prisma.factSensorEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FactSensorEventDeleteManyArgs>(args?: SelectSubset<T, FactSensorEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactSensorEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSensorEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactSensorEvents
     * const factSensorEvent = await prisma.factSensorEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FactSensorEventUpdateManyArgs>(args: SelectSubset<T, FactSensorEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FactSensorEvent.
     * @param {FactSensorEventUpsertArgs} args - Arguments to update or create a FactSensorEvent.
     * @example
     * // Update or create a FactSensorEvent
     * const factSensorEvent = await prisma.factSensorEvent.upsert({
     *   create: {
     *     // ... data to create a FactSensorEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactSensorEvent we want to update
     *   }
     * })
     */
    upsert<T extends FactSensorEventUpsertArgs>(args: SelectSubset<T, FactSensorEventUpsertArgs<ExtArgs>>): Prisma__FactSensorEventClient<$Result.GetResult<Prisma.$FactSensorEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FactSensorEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSensorEventCountArgs} args - Arguments to filter FactSensorEvents to count.
     * @example
     * // Count the number of FactSensorEvents
     * const count = await prisma.factSensorEvent.count({
     *   where: {
     *     // ... the filter for the FactSensorEvents we want to count
     *   }
     * })
    **/
    count<T extends FactSensorEventCountArgs>(
      args?: Subset<T, FactSensorEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactSensorEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactSensorEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSensorEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactSensorEventAggregateArgs>(args: Subset<T, FactSensorEventAggregateArgs>): Prisma.PrismaPromise<GetFactSensorEventAggregateType<T>>

    /**
     * Group by FactSensorEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSensorEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FactSensorEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactSensorEventGroupByArgs['orderBy'] }
        : { orderBy?: FactSensorEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FactSensorEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactSensorEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FactSensorEvent model
   */
  readonly fields: FactSensorEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactSensorEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactSensorEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends DimEquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DimEquipmentDefaultArgs<ExtArgs>>): Prisma__DimEquipmentClient<$Result.GetResult<Prisma.$DimEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    unit<T extends FactSensorEvent$unitArgs<ExtArgs> = {}>(args?: Subset<T, FactSensorEvent$unitArgs<ExtArgs>>): Prisma__DimUnitClient<$Result.GetResult<Prisma.$DimUnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FactSensorEvent model
   */ 
  interface FactSensorEventFieldRefs {
    readonly eventId: FieldRef<"FactSensorEvent", 'BigInt'>
    readonly equipmentId: FieldRef<"FactSensorEvent", 'Int'>
    readonly eventTs: FieldRef<"FactSensorEvent", 'DateTime'>
    readonly parameter: FieldRef<"FactSensorEvent", 'String'>
    readonly value: FieldRef<"FactSensorEvent", 'Decimal'>
    readonly unitId: FieldRef<"FactSensorEvent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FactSensorEvent findUnique
   */
  export type FactSensorEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * Filter, which FactSensorEvent to fetch.
     */
    where: FactSensorEventWhereUniqueInput
  }

  /**
   * FactSensorEvent findUniqueOrThrow
   */
  export type FactSensorEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * Filter, which FactSensorEvent to fetch.
     */
    where: FactSensorEventWhereUniqueInput
  }

  /**
   * FactSensorEvent findFirst
   */
  export type FactSensorEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * Filter, which FactSensorEvent to fetch.
     */
    where?: FactSensorEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactSensorEvents to fetch.
     */
    orderBy?: FactSensorEventOrderByWithRelationInput | FactSensorEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactSensorEvents.
     */
    cursor?: FactSensorEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactSensorEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactSensorEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactSensorEvents.
     */
    distinct?: FactSensorEventScalarFieldEnum | FactSensorEventScalarFieldEnum[]
  }

  /**
   * FactSensorEvent findFirstOrThrow
   */
  export type FactSensorEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * Filter, which FactSensorEvent to fetch.
     */
    where?: FactSensorEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactSensorEvents to fetch.
     */
    orderBy?: FactSensorEventOrderByWithRelationInput | FactSensorEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactSensorEvents.
     */
    cursor?: FactSensorEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactSensorEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactSensorEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactSensorEvents.
     */
    distinct?: FactSensorEventScalarFieldEnum | FactSensorEventScalarFieldEnum[]
  }

  /**
   * FactSensorEvent findMany
   */
  export type FactSensorEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * Filter, which FactSensorEvents to fetch.
     */
    where?: FactSensorEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactSensorEvents to fetch.
     */
    orderBy?: FactSensorEventOrderByWithRelationInput | FactSensorEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FactSensorEvents.
     */
    cursor?: FactSensorEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactSensorEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactSensorEvents.
     */
    skip?: number
    distinct?: FactSensorEventScalarFieldEnum | FactSensorEventScalarFieldEnum[]
  }

  /**
   * FactSensorEvent create
   */
  export type FactSensorEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * The data needed to create a FactSensorEvent.
     */
    data: XOR<FactSensorEventCreateInput, FactSensorEventUncheckedCreateInput>
  }

  /**
   * FactSensorEvent createMany
   */
  export type FactSensorEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FactSensorEvents.
     */
    data: FactSensorEventCreateManyInput | FactSensorEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactSensorEvent createManyAndReturn
   */
  export type FactSensorEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FactSensorEvents.
     */
    data: FactSensorEventCreateManyInput | FactSensorEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FactSensorEvent update
   */
  export type FactSensorEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * The data needed to update a FactSensorEvent.
     */
    data: XOR<FactSensorEventUpdateInput, FactSensorEventUncheckedUpdateInput>
    /**
     * Choose, which FactSensorEvent to update.
     */
    where: FactSensorEventWhereUniqueInput
  }

  /**
   * FactSensorEvent updateMany
   */
  export type FactSensorEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FactSensorEvents.
     */
    data: XOR<FactSensorEventUpdateManyMutationInput, FactSensorEventUncheckedUpdateManyInput>
    /**
     * Filter which FactSensorEvents to update
     */
    where?: FactSensorEventWhereInput
  }

  /**
   * FactSensorEvent upsert
   */
  export type FactSensorEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * The filter to search for the FactSensorEvent to update in case it exists.
     */
    where: FactSensorEventWhereUniqueInput
    /**
     * In case the FactSensorEvent found by the `where` argument doesn't exist, create a new FactSensorEvent with this data.
     */
    create: XOR<FactSensorEventCreateInput, FactSensorEventUncheckedCreateInput>
    /**
     * In case the FactSensorEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactSensorEventUpdateInput, FactSensorEventUncheckedUpdateInput>
  }

  /**
   * FactSensorEvent delete
   */
  export type FactSensorEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
    /**
     * Filter which FactSensorEvent to delete.
     */
    where: FactSensorEventWhereUniqueInput
  }

  /**
   * FactSensorEvent deleteMany
   */
  export type FactSensorEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactSensorEvents to delete
     */
    where?: FactSensorEventWhereInput
  }

  /**
   * FactSensorEvent.unit
   */
  export type FactSensorEvent$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimUnit
     */
    select?: DimUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DimUnitInclude<ExtArgs> | null
    where?: DimUnitWhereInput
  }

  /**
   * FactSensorEvent without action
   */
  export type FactSensorEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactSensorEvent
     */
    select?: FactSensorEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactSensorEventInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: bigint | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: bigint | null
    username: string | null
    action: string | null
    tableName: string | null
    recordId: string | null
    logTs: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: bigint | null
    username: string | null
    action: string | null
    tableName: string | null
    recordId: string | null
    logTs: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    username: number
    action: number
    tableName: number
    recordId: number
    logTs: number
    beforeData: number
    afterData: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    username?: true
    action?: true
    tableName?: true
    recordId?: true
    logTs?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    username?: true
    action?: true
    tableName?: true
    recordId?: true
    logTs?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    username?: true
    action?: true
    tableName?: true
    recordId?: true
    logTs?: true
    beforeData?: true
    afterData?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: bigint
    username: string | null
    action: string
    tableName: string
    recordId: string
    logTs: Date | null
    beforeData: JsonValue | null
    afterData: JsonValue | null
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    logTs?: boolean
    beforeData?: boolean
    afterData?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    logTs?: boolean
    beforeData?: boolean
    afterData?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    username?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    logTs?: boolean
    beforeData?: boolean
    afterData?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      username: string | null
      action: string
      tableName: string
      recordId: string
      logTs: Date | null
      beforeData: Prisma.JsonValue | null
      afterData: Prisma.JsonValue | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'BigInt'>
    readonly username: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly logTs: FieldRef<"AuditLog", 'DateTime'>
    readonly beforeData: FieldRef<"AuditLog", 'Json'>
    readonly afterData: FieldRef<"AuditLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model AuditEvent
   */

  export type AggregateAuditEvent = {
    _count: AuditEventCountAggregateOutputType | null
    _avg: AuditEventAvgAggregateOutputType | null
    _sum: AuditEventSumAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  export type AuditEventAvgAggregateOutputType = {
    id: number | null
  }

  export type AuditEventSumAggregateOutputType = {
    id: bigint | null
  }

  export type AuditEventMinAggregateOutputType = {
    id: bigint | null
    eventType: string | null
    aggregateId: string | null
    aggregateType: string | null
    userId: string | null
    correlationId: string | null
    causationId: string | null
    createdAt: Date | null
  }

  export type AuditEventMaxAggregateOutputType = {
    id: bigint | null
    eventType: string | null
    aggregateId: string | null
    aggregateType: string | null
    userId: string | null
    correlationId: string | null
    causationId: string | null
    createdAt: Date | null
  }

  export type AuditEventCountAggregateOutputType = {
    id: number
    eventType: number
    aggregateId: number
    aggregateType: number
    eventData: number
    eventMetadata: number
    userId: number
    correlationId: number
    causationId: number
    createdAt: number
    _all: number
  }


  export type AuditEventAvgAggregateInputType = {
    id?: true
  }

  export type AuditEventSumAggregateInputType = {
    id?: true
  }

  export type AuditEventMinAggregateInputType = {
    id?: true
    eventType?: true
    aggregateId?: true
    aggregateType?: true
    userId?: true
    correlationId?: true
    causationId?: true
    createdAt?: true
  }

  export type AuditEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    aggregateId?: true
    aggregateType?: true
    userId?: true
    correlationId?: true
    causationId?: true
    createdAt?: true
  }

  export type AuditEventCountAggregateInputType = {
    id?: true
    eventType?: true
    aggregateId?: true
    aggregateType?: true
    eventData?: true
    eventMetadata?: true
    userId?: true
    correlationId?: true
    causationId?: true
    createdAt?: true
    _all?: true
  }

  export type AuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvent to aggregate.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditEvents
    **/
    _count?: true | AuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditEventMaxAggregateInputType
  }

  export type GetAuditEventAggregateType<T extends AuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditEvent[P]>
      : GetScalarType<T[P], AggregateAuditEvent[P]>
  }




  export type AuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithAggregationInput | AuditEventOrderByWithAggregationInput[]
    by: AuditEventScalarFieldEnum[] | AuditEventScalarFieldEnum
    having?: AuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditEventCountAggregateInputType | true
    _avg?: AuditEventAvgAggregateInputType
    _sum?: AuditEventSumAggregateInputType
    _min?: AuditEventMinAggregateInputType
    _max?: AuditEventMaxAggregateInputType
  }

  export type AuditEventGroupByOutputType = {
    id: bigint
    eventType: string
    aggregateId: string
    aggregateType: string
    eventData: JsonValue
    eventMetadata: JsonValue | null
    userId: string | null
    correlationId: string | null
    causationId: string | null
    createdAt: Date
    _count: AuditEventCountAggregateOutputType | null
    _avg: AuditEventAvgAggregateOutputType | null
    _sum: AuditEventSumAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  type GetAuditEventGroupByPayload<T extends AuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
        }
      >
    >


  export type AuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    aggregateId?: boolean
    aggregateType?: boolean
    eventData?: boolean
    eventMetadata?: boolean
    userId?: boolean
    correlationId?: boolean
    causationId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    aggregateId?: boolean
    aggregateType?: boolean
    eventData?: boolean
    eventMetadata?: boolean
    userId?: boolean
    correlationId?: boolean
    causationId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    aggregateId?: boolean
    aggregateType?: boolean
    eventData?: boolean
    eventMetadata?: boolean
    userId?: boolean
    correlationId?: boolean
    causationId?: boolean
    createdAt?: boolean
  }


  export type $AuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      eventType: string
      aggregateId: string
      aggregateType: string
      eventData: Prisma.JsonValue
      eventMetadata: Prisma.JsonValue | null
      userId: string | null
      correlationId: string | null
      causationId: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditEvent"]>
    composites: {}
  }

  type AuditEventGetPayload<S extends boolean | null | undefined | AuditEventDefaultArgs> = $Result.GetResult<Prisma.$AuditEventPayload, S>

  type AuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditEventCountAggregateInputType | true
    }

  export interface AuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditEvent'], meta: { name: 'AuditEvent' } }
    /**
     * Find zero or one AuditEvent that matches the filter.
     * @param {AuditEventFindUniqueArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditEventFindUniqueArgs>(args: SelectSubset<T, AuditEventFindUniqueArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditEventFindUniqueOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditEventFindFirstArgs>(args?: SelectSubset<T, AuditEventFindFirstArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany()
     * 
     * // Get first 10 AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditEventFindManyArgs>(args?: SelectSubset<T, AuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditEvent.
     * @param {AuditEventCreateArgs} args - Arguments to create a AuditEvent.
     * @example
     * // Create one AuditEvent
     * const AuditEvent = await prisma.auditEvent.create({
     *   data: {
     *     // ... data to create a AuditEvent
     *   }
     * })
     * 
     */
    create<T extends AuditEventCreateArgs>(args: SelectSubset<T, AuditEventCreateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditEvents.
     * @param {AuditEventCreateManyArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditEventCreateManyArgs>(args?: SelectSubset<T, AuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditEvents and returns the data saved in the database.
     * @param {AuditEventCreateManyAndReturnArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditEvent.
     * @param {AuditEventDeleteArgs} args - Arguments to delete one AuditEvent.
     * @example
     * // Delete one AuditEvent
     * const AuditEvent = await prisma.auditEvent.delete({
     *   where: {
     *     // ... filter to delete one AuditEvent
     *   }
     * })
     * 
     */
    delete<T extends AuditEventDeleteArgs>(args: SelectSubset<T, AuditEventDeleteArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditEvent.
     * @param {AuditEventUpdateArgs} args - Arguments to update one AuditEvent.
     * @example
     * // Update one AuditEvent
     * const auditEvent = await prisma.auditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditEventUpdateArgs>(args: SelectSubset<T, AuditEventUpdateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditEvents.
     * @param {AuditEventDeleteManyArgs} args - Arguments to filter AuditEvents to delete.
     * @example
     * // Delete a few AuditEvents
     * const { count } = await prisma.auditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditEventDeleteManyArgs>(args?: SelectSubset<T, AuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditEventUpdateManyArgs>(args: SelectSubset<T, AuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditEvent.
     * @param {AuditEventUpsertArgs} args - Arguments to update or create a AuditEvent.
     * @example
     * // Update or create a AuditEvent
     * const auditEvent = await prisma.auditEvent.upsert({
     *   create: {
     *     // ... data to create a AuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends AuditEventUpsertArgs>(args: SelectSubset<T, AuditEventUpsertArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventCountArgs} args - Arguments to filter AuditEvents to count.
     * @example
     * // Count the number of AuditEvents
     * const count = await prisma.auditEvent.count({
     *   where: {
     *     // ... the filter for the AuditEvents we want to count
     *   }
     * })
    **/
    count<T extends AuditEventCountArgs>(
      args?: Subset<T, AuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditEventAggregateArgs>(args: Subset<T, AuditEventAggregateArgs>): Prisma.PrismaPromise<GetAuditEventAggregateType<T>>

    /**
     * Group by AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditEventGroupByArgs['orderBy'] }
        : { orderBy?: AuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditEvent model
   */
  readonly fields: AuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditEvent model
   */ 
  interface AuditEventFieldRefs {
    readonly id: FieldRef<"AuditEvent", 'BigInt'>
    readonly eventType: FieldRef<"AuditEvent", 'String'>
    readonly aggregateId: FieldRef<"AuditEvent", 'String'>
    readonly aggregateType: FieldRef<"AuditEvent", 'String'>
    readonly eventData: FieldRef<"AuditEvent", 'Json'>
    readonly eventMetadata: FieldRef<"AuditEvent", 'Json'>
    readonly userId: FieldRef<"AuditEvent", 'String'>
    readonly correlationId: FieldRef<"AuditEvent", 'String'>
    readonly causationId: FieldRef<"AuditEvent", 'String'>
    readonly createdAt: FieldRef<"AuditEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditEvent findUnique
   */
  export type AuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findUniqueOrThrow
   */
  export type AuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findFirst
   */
  export type AuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findFirstOrThrow
   */
  export type AuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findMany
   */
  export type AuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Filter, which AuditEvents to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent create
   */
  export type AuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditEvent.
     */
    data: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
  }

  /**
   * AuditEvent createMany
   */
  export type AuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditEvent createManyAndReturn
   */
  export type AuditEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditEvent update
   */
  export type AuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditEvent.
     */
    data: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
    /**
     * Choose, which AuditEvent to update.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent updateMany
   */
  export type AuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
  }

  /**
   * AuditEvent upsert
   */
  export type AuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditEvent to update in case it exists.
     */
    where: AuditEventWhereUniqueInput
    /**
     * In case the AuditEvent found by the `where` argument doesn't exist, create a new AuditEvent with this data.
     */
    create: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
    /**
     * In case the AuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
  }

  /**
   * AuditEvent delete
   */
  export type AuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Filter which AuditEvent to delete.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent deleteMany
   */
  export type AuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvents to delete
     */
    where?: AuditEventWhereInput
  }

  /**
   * AuditEvent without action
   */
  export type AuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
  }


  /**
   * Model DataDictionary
   */

  export type AggregateDataDictionary = {
    _count: DataDictionaryCountAggregateOutputType | null
    _avg: DataDictionaryAvgAggregateOutputType | null
    _sum: DataDictionarySumAggregateOutputType | null
    _min: DataDictionaryMinAggregateOutputType | null
    _max: DataDictionaryMaxAggregateOutputType | null
  }

  export type DataDictionaryAvgAggregateOutputType = {
    id: number | null
    retentionDays: number | null
  }

  export type DataDictionarySumAggregateOutputType = {
    id: number | null
    retentionDays: number | null
  }

  export type DataDictionaryMinAggregateOutputType = {
    id: number | null
    schemaName: string | null
    tableName: string | null
    columnName: string | null
    dataType: string | null
    isNullable: boolean | null
    description: string | null
    businessName: string | null
    dataSteward: string | null
    classification: string | null
    piiFlag: boolean | null
    retentionDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataDictionaryMaxAggregateOutputType = {
    id: number | null
    schemaName: string | null
    tableName: string | null
    columnName: string | null
    dataType: string | null
    isNullable: boolean | null
    description: string | null
    businessName: string | null
    dataSteward: string | null
    classification: string | null
    piiFlag: boolean | null
    retentionDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataDictionaryCountAggregateOutputType = {
    id: number
    schemaName: number
    tableName: number
    columnName: number
    dataType: number
    isNullable: number
    description: number
    businessName: number
    dataSteward: number
    classification: number
    piiFlag: number
    retentionDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataDictionaryAvgAggregateInputType = {
    id?: true
    retentionDays?: true
  }

  export type DataDictionarySumAggregateInputType = {
    id?: true
    retentionDays?: true
  }

  export type DataDictionaryMinAggregateInputType = {
    id?: true
    schemaName?: true
    tableName?: true
    columnName?: true
    dataType?: true
    isNullable?: true
    description?: true
    businessName?: true
    dataSteward?: true
    classification?: true
    piiFlag?: true
    retentionDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataDictionaryMaxAggregateInputType = {
    id?: true
    schemaName?: true
    tableName?: true
    columnName?: true
    dataType?: true
    isNullable?: true
    description?: true
    businessName?: true
    dataSteward?: true
    classification?: true
    piiFlag?: true
    retentionDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataDictionaryCountAggregateInputType = {
    id?: true
    schemaName?: true
    tableName?: true
    columnName?: true
    dataType?: true
    isNullable?: true
    description?: true
    businessName?: true
    dataSteward?: true
    classification?: true
    piiFlag?: true
    retentionDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataDictionaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataDictionary to aggregate.
     */
    where?: DataDictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDictionaries to fetch.
     */
    orderBy?: DataDictionaryOrderByWithRelationInput | DataDictionaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataDictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDictionaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDictionaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataDictionaries
    **/
    _count?: true | DataDictionaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataDictionaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataDictionarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataDictionaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataDictionaryMaxAggregateInputType
  }

  export type GetDataDictionaryAggregateType<T extends DataDictionaryAggregateArgs> = {
        [P in keyof T & keyof AggregateDataDictionary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataDictionary[P]>
      : GetScalarType<T[P], AggregateDataDictionary[P]>
  }




  export type DataDictionaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataDictionaryWhereInput
    orderBy?: DataDictionaryOrderByWithAggregationInput | DataDictionaryOrderByWithAggregationInput[]
    by: DataDictionaryScalarFieldEnum[] | DataDictionaryScalarFieldEnum
    having?: DataDictionaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataDictionaryCountAggregateInputType | true
    _avg?: DataDictionaryAvgAggregateInputType
    _sum?: DataDictionarySumAggregateInputType
    _min?: DataDictionaryMinAggregateInputType
    _max?: DataDictionaryMaxAggregateInputType
  }

  export type DataDictionaryGroupByOutputType = {
    id: number
    schemaName: string
    tableName: string
    columnName: string
    dataType: string
    isNullable: boolean
    description: string | null
    businessName: string | null
    dataSteward: string | null
    classification: string | null
    piiFlag: boolean | null
    retentionDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: DataDictionaryCountAggregateOutputType | null
    _avg: DataDictionaryAvgAggregateOutputType | null
    _sum: DataDictionarySumAggregateOutputType | null
    _min: DataDictionaryMinAggregateOutputType | null
    _max: DataDictionaryMaxAggregateOutputType | null
  }

  type GetDataDictionaryGroupByPayload<T extends DataDictionaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataDictionaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataDictionaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataDictionaryGroupByOutputType[P]>
            : GetScalarType<T[P], DataDictionaryGroupByOutputType[P]>
        }
      >
    >


  export type DataDictionarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaName?: boolean
    tableName?: boolean
    columnName?: boolean
    dataType?: boolean
    isNullable?: boolean
    description?: boolean
    businessName?: boolean
    dataSteward?: boolean
    classification?: boolean
    piiFlag?: boolean
    retentionDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataDictionary"]>

  export type DataDictionarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaName?: boolean
    tableName?: boolean
    columnName?: boolean
    dataType?: boolean
    isNullable?: boolean
    description?: boolean
    businessName?: boolean
    dataSteward?: boolean
    classification?: boolean
    piiFlag?: boolean
    retentionDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataDictionary"]>

  export type DataDictionarySelectScalar = {
    id?: boolean
    schemaName?: boolean
    tableName?: boolean
    columnName?: boolean
    dataType?: boolean
    isNullable?: boolean
    description?: boolean
    businessName?: boolean
    dataSteward?: boolean
    classification?: boolean
    piiFlag?: boolean
    retentionDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DataDictionaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataDictionary"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      schemaName: string
      tableName: string
      columnName: string
      dataType: string
      isNullable: boolean
      description: string | null
      businessName: string | null
      dataSteward: string | null
      classification: string | null
      piiFlag: boolean | null
      retentionDays: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dataDictionary"]>
    composites: {}
  }

  type DataDictionaryGetPayload<S extends boolean | null | undefined | DataDictionaryDefaultArgs> = $Result.GetResult<Prisma.$DataDictionaryPayload, S>

  type DataDictionaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataDictionaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataDictionaryCountAggregateInputType | true
    }

  export interface DataDictionaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataDictionary'], meta: { name: 'DataDictionary' } }
    /**
     * Find zero or one DataDictionary that matches the filter.
     * @param {DataDictionaryFindUniqueArgs} args - Arguments to find a DataDictionary
     * @example
     * // Get one DataDictionary
     * const dataDictionary = await prisma.dataDictionary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataDictionaryFindUniqueArgs>(args: SelectSubset<T, DataDictionaryFindUniqueArgs<ExtArgs>>): Prisma__DataDictionaryClient<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataDictionary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataDictionaryFindUniqueOrThrowArgs} args - Arguments to find a DataDictionary
     * @example
     * // Get one DataDictionary
     * const dataDictionary = await prisma.dataDictionary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataDictionaryFindUniqueOrThrowArgs>(args: SelectSubset<T, DataDictionaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataDictionaryClient<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataDictionary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDictionaryFindFirstArgs} args - Arguments to find a DataDictionary
     * @example
     * // Get one DataDictionary
     * const dataDictionary = await prisma.dataDictionary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataDictionaryFindFirstArgs>(args?: SelectSubset<T, DataDictionaryFindFirstArgs<ExtArgs>>): Prisma__DataDictionaryClient<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataDictionary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDictionaryFindFirstOrThrowArgs} args - Arguments to find a DataDictionary
     * @example
     * // Get one DataDictionary
     * const dataDictionary = await prisma.dataDictionary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataDictionaryFindFirstOrThrowArgs>(args?: SelectSubset<T, DataDictionaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataDictionaryClient<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataDictionaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDictionaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataDictionaries
     * const dataDictionaries = await prisma.dataDictionary.findMany()
     * 
     * // Get first 10 DataDictionaries
     * const dataDictionaries = await prisma.dataDictionary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataDictionaryWithIdOnly = await prisma.dataDictionary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataDictionaryFindManyArgs>(args?: SelectSubset<T, DataDictionaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataDictionary.
     * @param {DataDictionaryCreateArgs} args - Arguments to create a DataDictionary.
     * @example
     * // Create one DataDictionary
     * const DataDictionary = await prisma.dataDictionary.create({
     *   data: {
     *     // ... data to create a DataDictionary
     *   }
     * })
     * 
     */
    create<T extends DataDictionaryCreateArgs>(args: SelectSubset<T, DataDictionaryCreateArgs<ExtArgs>>): Prisma__DataDictionaryClient<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataDictionaries.
     * @param {DataDictionaryCreateManyArgs} args - Arguments to create many DataDictionaries.
     * @example
     * // Create many DataDictionaries
     * const dataDictionary = await prisma.dataDictionary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataDictionaryCreateManyArgs>(args?: SelectSubset<T, DataDictionaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataDictionaries and returns the data saved in the database.
     * @param {DataDictionaryCreateManyAndReturnArgs} args - Arguments to create many DataDictionaries.
     * @example
     * // Create many DataDictionaries
     * const dataDictionary = await prisma.dataDictionary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataDictionaries and only return the `id`
     * const dataDictionaryWithIdOnly = await prisma.dataDictionary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataDictionaryCreateManyAndReturnArgs>(args?: SelectSubset<T, DataDictionaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataDictionary.
     * @param {DataDictionaryDeleteArgs} args - Arguments to delete one DataDictionary.
     * @example
     * // Delete one DataDictionary
     * const DataDictionary = await prisma.dataDictionary.delete({
     *   where: {
     *     // ... filter to delete one DataDictionary
     *   }
     * })
     * 
     */
    delete<T extends DataDictionaryDeleteArgs>(args: SelectSubset<T, DataDictionaryDeleteArgs<ExtArgs>>): Prisma__DataDictionaryClient<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataDictionary.
     * @param {DataDictionaryUpdateArgs} args - Arguments to update one DataDictionary.
     * @example
     * // Update one DataDictionary
     * const dataDictionary = await prisma.dataDictionary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataDictionaryUpdateArgs>(args: SelectSubset<T, DataDictionaryUpdateArgs<ExtArgs>>): Prisma__DataDictionaryClient<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataDictionaries.
     * @param {DataDictionaryDeleteManyArgs} args - Arguments to filter DataDictionaries to delete.
     * @example
     * // Delete a few DataDictionaries
     * const { count } = await prisma.dataDictionary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataDictionaryDeleteManyArgs>(args?: SelectSubset<T, DataDictionaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataDictionaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDictionaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataDictionaries
     * const dataDictionary = await prisma.dataDictionary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataDictionaryUpdateManyArgs>(args: SelectSubset<T, DataDictionaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataDictionary.
     * @param {DataDictionaryUpsertArgs} args - Arguments to update or create a DataDictionary.
     * @example
     * // Update or create a DataDictionary
     * const dataDictionary = await prisma.dataDictionary.upsert({
     *   create: {
     *     // ... data to create a DataDictionary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataDictionary we want to update
     *   }
     * })
     */
    upsert<T extends DataDictionaryUpsertArgs>(args: SelectSubset<T, DataDictionaryUpsertArgs<ExtArgs>>): Prisma__DataDictionaryClient<$Result.GetResult<Prisma.$DataDictionaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataDictionaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDictionaryCountArgs} args - Arguments to filter DataDictionaries to count.
     * @example
     * // Count the number of DataDictionaries
     * const count = await prisma.dataDictionary.count({
     *   where: {
     *     // ... the filter for the DataDictionaries we want to count
     *   }
     * })
    **/
    count<T extends DataDictionaryCountArgs>(
      args?: Subset<T, DataDictionaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataDictionaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataDictionary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDictionaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataDictionaryAggregateArgs>(args: Subset<T, DataDictionaryAggregateArgs>): Prisma.PrismaPromise<GetDataDictionaryAggregateType<T>>

    /**
     * Group by DataDictionary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDictionaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataDictionaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataDictionaryGroupByArgs['orderBy'] }
        : { orderBy?: DataDictionaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataDictionaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataDictionaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataDictionary model
   */
  readonly fields: DataDictionaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataDictionary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataDictionaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataDictionary model
   */ 
  interface DataDictionaryFieldRefs {
    readonly id: FieldRef<"DataDictionary", 'Int'>
    readonly schemaName: FieldRef<"DataDictionary", 'String'>
    readonly tableName: FieldRef<"DataDictionary", 'String'>
    readonly columnName: FieldRef<"DataDictionary", 'String'>
    readonly dataType: FieldRef<"DataDictionary", 'String'>
    readonly isNullable: FieldRef<"DataDictionary", 'Boolean'>
    readonly description: FieldRef<"DataDictionary", 'String'>
    readonly businessName: FieldRef<"DataDictionary", 'String'>
    readonly dataSteward: FieldRef<"DataDictionary", 'String'>
    readonly classification: FieldRef<"DataDictionary", 'String'>
    readonly piiFlag: FieldRef<"DataDictionary", 'Boolean'>
    readonly retentionDays: FieldRef<"DataDictionary", 'Int'>
    readonly createdAt: FieldRef<"DataDictionary", 'DateTime'>
    readonly updatedAt: FieldRef<"DataDictionary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataDictionary findUnique
   */
  export type DataDictionaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * Filter, which DataDictionary to fetch.
     */
    where: DataDictionaryWhereUniqueInput
  }

  /**
   * DataDictionary findUniqueOrThrow
   */
  export type DataDictionaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * Filter, which DataDictionary to fetch.
     */
    where: DataDictionaryWhereUniqueInput
  }

  /**
   * DataDictionary findFirst
   */
  export type DataDictionaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * Filter, which DataDictionary to fetch.
     */
    where?: DataDictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDictionaries to fetch.
     */
    orderBy?: DataDictionaryOrderByWithRelationInput | DataDictionaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDictionaries.
     */
    cursor?: DataDictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDictionaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDictionaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDictionaries.
     */
    distinct?: DataDictionaryScalarFieldEnum | DataDictionaryScalarFieldEnum[]
  }

  /**
   * DataDictionary findFirstOrThrow
   */
  export type DataDictionaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * Filter, which DataDictionary to fetch.
     */
    where?: DataDictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDictionaries to fetch.
     */
    orderBy?: DataDictionaryOrderByWithRelationInput | DataDictionaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDictionaries.
     */
    cursor?: DataDictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDictionaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDictionaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDictionaries.
     */
    distinct?: DataDictionaryScalarFieldEnum | DataDictionaryScalarFieldEnum[]
  }

  /**
   * DataDictionary findMany
   */
  export type DataDictionaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * Filter, which DataDictionaries to fetch.
     */
    where?: DataDictionaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDictionaries to fetch.
     */
    orderBy?: DataDictionaryOrderByWithRelationInput | DataDictionaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataDictionaries.
     */
    cursor?: DataDictionaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDictionaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDictionaries.
     */
    skip?: number
    distinct?: DataDictionaryScalarFieldEnum | DataDictionaryScalarFieldEnum[]
  }

  /**
   * DataDictionary create
   */
  export type DataDictionaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * The data needed to create a DataDictionary.
     */
    data: XOR<DataDictionaryCreateInput, DataDictionaryUncheckedCreateInput>
  }

  /**
   * DataDictionary createMany
   */
  export type DataDictionaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataDictionaries.
     */
    data: DataDictionaryCreateManyInput | DataDictionaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataDictionary createManyAndReturn
   */
  export type DataDictionaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataDictionaries.
     */
    data: DataDictionaryCreateManyInput | DataDictionaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataDictionary update
   */
  export type DataDictionaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * The data needed to update a DataDictionary.
     */
    data: XOR<DataDictionaryUpdateInput, DataDictionaryUncheckedUpdateInput>
    /**
     * Choose, which DataDictionary to update.
     */
    where: DataDictionaryWhereUniqueInput
  }

  /**
   * DataDictionary updateMany
   */
  export type DataDictionaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataDictionaries.
     */
    data: XOR<DataDictionaryUpdateManyMutationInput, DataDictionaryUncheckedUpdateManyInput>
    /**
     * Filter which DataDictionaries to update
     */
    where?: DataDictionaryWhereInput
  }

  /**
   * DataDictionary upsert
   */
  export type DataDictionaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * The filter to search for the DataDictionary to update in case it exists.
     */
    where: DataDictionaryWhereUniqueInput
    /**
     * In case the DataDictionary found by the `where` argument doesn't exist, create a new DataDictionary with this data.
     */
    create: XOR<DataDictionaryCreateInput, DataDictionaryUncheckedCreateInput>
    /**
     * In case the DataDictionary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataDictionaryUpdateInput, DataDictionaryUncheckedUpdateInput>
  }

  /**
   * DataDictionary delete
   */
  export type DataDictionaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
    /**
     * Filter which DataDictionary to delete.
     */
    where: DataDictionaryWhereUniqueInput
  }

  /**
   * DataDictionary deleteMany
   */
  export type DataDictionaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataDictionaries to delete
     */
    where?: DataDictionaryWhereInput
  }

  /**
   * DataDictionary without action
   */
  export type DataDictionaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDictionary
     */
    select?: DataDictionarySelect<ExtArgs> | null
  }


  /**
   * Model DataRetentionPolicy
   */

  export type AggregateDataRetentionPolicy = {
    _count: DataRetentionPolicyCountAggregateOutputType | null
    _avg: DataRetentionPolicyAvgAggregateOutputType | null
    _sum: DataRetentionPolicySumAggregateOutputType | null
    _min: DataRetentionPolicyMinAggregateOutputType | null
    _max: DataRetentionPolicyMaxAggregateOutputType | null
  }

  export type DataRetentionPolicyAvgAggregateOutputType = {
    id: number | null
    retentionDays: number | null
  }

  export type DataRetentionPolicySumAggregateOutputType = {
    id: number | null
    retentionDays: number | null
  }

  export type DataRetentionPolicyMinAggregateOutputType = {
    id: number | null
    tableName: string | null
    retentionDays: number | null
    archiveEnabled: boolean | null
    archiveTableName: string | null
    lastArchived: Date | null
    createdAt: Date | null
  }

  export type DataRetentionPolicyMaxAggregateOutputType = {
    id: number | null
    tableName: string | null
    retentionDays: number | null
    archiveEnabled: boolean | null
    archiveTableName: string | null
    lastArchived: Date | null
    createdAt: Date | null
  }

  export type DataRetentionPolicyCountAggregateOutputType = {
    id: number
    tableName: number
    retentionDays: number
    archiveEnabled: number
    archiveTableName: number
    lastArchived: number
    createdAt: number
    _all: number
  }


  export type DataRetentionPolicyAvgAggregateInputType = {
    id?: true
    retentionDays?: true
  }

  export type DataRetentionPolicySumAggregateInputType = {
    id?: true
    retentionDays?: true
  }

  export type DataRetentionPolicyMinAggregateInputType = {
    id?: true
    tableName?: true
    retentionDays?: true
    archiveEnabled?: true
    archiveTableName?: true
    lastArchived?: true
    createdAt?: true
  }

  export type DataRetentionPolicyMaxAggregateInputType = {
    id?: true
    tableName?: true
    retentionDays?: true
    archiveEnabled?: true
    archiveTableName?: true
    lastArchived?: true
    createdAt?: true
  }

  export type DataRetentionPolicyCountAggregateInputType = {
    id?: true
    tableName?: true
    retentionDays?: true
    archiveEnabled?: true
    archiveTableName?: true
    lastArchived?: true
    createdAt?: true
    _all?: true
  }

  export type DataRetentionPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRetentionPolicy to aggregate.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataRetentionPolicies
    **/
    _count?: true | DataRetentionPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRetentionPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRetentionPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRetentionPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRetentionPolicyMaxAggregateInputType
  }

  export type GetDataRetentionPolicyAggregateType<T extends DataRetentionPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRetentionPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRetentionPolicy[P]>
      : GetScalarType<T[P], AggregateDataRetentionPolicy[P]>
  }




  export type DataRetentionPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRetentionPolicyWhereInput
    orderBy?: DataRetentionPolicyOrderByWithAggregationInput | DataRetentionPolicyOrderByWithAggregationInput[]
    by: DataRetentionPolicyScalarFieldEnum[] | DataRetentionPolicyScalarFieldEnum
    having?: DataRetentionPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRetentionPolicyCountAggregateInputType | true
    _avg?: DataRetentionPolicyAvgAggregateInputType
    _sum?: DataRetentionPolicySumAggregateInputType
    _min?: DataRetentionPolicyMinAggregateInputType
    _max?: DataRetentionPolicyMaxAggregateInputType
  }

  export type DataRetentionPolicyGroupByOutputType = {
    id: number
    tableName: string
    retentionDays: number
    archiveEnabled: boolean | null
    archiveTableName: string | null
    lastArchived: Date | null
    createdAt: Date | null
    _count: DataRetentionPolicyCountAggregateOutputType | null
    _avg: DataRetentionPolicyAvgAggregateOutputType | null
    _sum: DataRetentionPolicySumAggregateOutputType | null
    _min: DataRetentionPolicyMinAggregateOutputType | null
    _max: DataRetentionPolicyMaxAggregateOutputType | null
  }

  type GetDataRetentionPolicyGroupByPayload<T extends DataRetentionPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRetentionPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRetentionPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRetentionPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], DataRetentionPolicyGroupByOutputType[P]>
        }
      >
    >


  export type DataRetentionPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    retentionDays?: boolean
    archiveEnabled?: boolean
    archiveTableName?: boolean
    lastArchived?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["dataRetentionPolicy"]>

  export type DataRetentionPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    retentionDays?: boolean
    archiveEnabled?: boolean
    archiveTableName?: boolean
    lastArchived?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["dataRetentionPolicy"]>

  export type DataRetentionPolicySelectScalar = {
    id?: boolean
    tableName?: boolean
    retentionDays?: boolean
    archiveEnabled?: boolean
    archiveTableName?: boolean
    lastArchived?: boolean
    createdAt?: boolean
  }


  export type $DataRetentionPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataRetentionPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableName: string
      retentionDays: number
      archiveEnabled: boolean | null
      archiveTableName: string | null
      lastArchived: Date | null
      createdAt: Date | null
    }, ExtArgs["result"]["dataRetentionPolicy"]>
    composites: {}
  }

  type DataRetentionPolicyGetPayload<S extends boolean | null | undefined | DataRetentionPolicyDefaultArgs> = $Result.GetResult<Prisma.$DataRetentionPolicyPayload, S>

  type DataRetentionPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataRetentionPolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataRetentionPolicyCountAggregateInputType | true
    }

  export interface DataRetentionPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataRetentionPolicy'], meta: { name: 'DataRetentionPolicy' } }
    /**
     * Find zero or one DataRetentionPolicy that matches the filter.
     * @param {DataRetentionPolicyFindUniqueArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataRetentionPolicyFindUniqueArgs>(args: SelectSubset<T, DataRetentionPolicyFindUniqueArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataRetentionPolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataRetentionPolicyFindUniqueOrThrowArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataRetentionPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataRetentionPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindFirstArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataRetentionPolicyFindFirstArgs>(args?: SelectSubset<T, DataRetentionPolicyFindFirstArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataRetentionPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindFirstOrThrowArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataRetentionPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataRetentionPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRetentionPolicies
     * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany()
     * 
     * // Get first 10 DataRetentionPolicies
     * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRetentionPolicyWithIdOnly = await prisma.dataRetentionPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataRetentionPolicyFindManyArgs>(args?: SelectSubset<T, DataRetentionPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataRetentionPolicy.
     * @param {DataRetentionPolicyCreateArgs} args - Arguments to create a DataRetentionPolicy.
     * @example
     * // Create one DataRetentionPolicy
     * const DataRetentionPolicy = await prisma.dataRetentionPolicy.create({
     *   data: {
     *     // ... data to create a DataRetentionPolicy
     *   }
     * })
     * 
     */
    create<T extends DataRetentionPolicyCreateArgs>(args: SelectSubset<T, DataRetentionPolicyCreateArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataRetentionPolicies.
     * @param {DataRetentionPolicyCreateManyArgs} args - Arguments to create many DataRetentionPolicies.
     * @example
     * // Create many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataRetentionPolicyCreateManyArgs>(args?: SelectSubset<T, DataRetentionPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataRetentionPolicies and returns the data saved in the database.
     * @param {DataRetentionPolicyCreateManyAndReturnArgs} args - Arguments to create many DataRetentionPolicies.
     * @example
     * // Create many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataRetentionPolicies and only return the `id`
     * const dataRetentionPolicyWithIdOnly = await prisma.dataRetentionPolicy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataRetentionPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataRetentionPolicy.
     * @param {DataRetentionPolicyDeleteArgs} args - Arguments to delete one DataRetentionPolicy.
     * @example
     * // Delete one DataRetentionPolicy
     * const DataRetentionPolicy = await prisma.dataRetentionPolicy.delete({
     *   where: {
     *     // ... filter to delete one DataRetentionPolicy
     *   }
     * })
     * 
     */
    delete<T extends DataRetentionPolicyDeleteArgs>(args: SelectSubset<T, DataRetentionPolicyDeleteArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataRetentionPolicy.
     * @param {DataRetentionPolicyUpdateArgs} args - Arguments to update one DataRetentionPolicy.
     * @example
     * // Update one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataRetentionPolicyUpdateArgs>(args: SelectSubset<T, DataRetentionPolicyUpdateArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataRetentionPolicies.
     * @param {DataRetentionPolicyDeleteManyArgs} args - Arguments to filter DataRetentionPolicies to delete.
     * @example
     * // Delete a few DataRetentionPolicies
     * const { count } = await prisma.dataRetentionPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataRetentionPolicyDeleteManyArgs>(args?: SelectSubset<T, DataRetentionPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRetentionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataRetentionPolicyUpdateManyArgs>(args: SelectSubset<T, DataRetentionPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataRetentionPolicy.
     * @param {DataRetentionPolicyUpsertArgs} args - Arguments to update or create a DataRetentionPolicy.
     * @example
     * // Update or create a DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.upsert({
     *   create: {
     *     // ... data to create a DataRetentionPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRetentionPolicy we want to update
     *   }
     * })
     */
    upsert<T extends DataRetentionPolicyUpsertArgs>(args: SelectSubset<T, DataRetentionPolicyUpsertArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataRetentionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyCountArgs} args - Arguments to filter DataRetentionPolicies to count.
     * @example
     * // Count the number of DataRetentionPolicies
     * const count = await prisma.dataRetentionPolicy.count({
     *   where: {
     *     // ... the filter for the DataRetentionPolicies we want to count
     *   }
     * })
    **/
    count<T extends DataRetentionPolicyCountArgs>(
      args?: Subset<T, DataRetentionPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRetentionPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRetentionPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRetentionPolicyAggregateArgs>(args: Subset<T, DataRetentionPolicyAggregateArgs>): Prisma.PrismaPromise<GetDataRetentionPolicyAggregateType<T>>

    /**
     * Group by DataRetentionPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataRetentionPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataRetentionPolicyGroupByArgs['orderBy'] }
        : { orderBy?: DataRetentionPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataRetentionPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRetentionPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataRetentionPolicy model
   */
  readonly fields: DataRetentionPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataRetentionPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataRetentionPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataRetentionPolicy model
   */ 
  interface DataRetentionPolicyFieldRefs {
    readonly id: FieldRef<"DataRetentionPolicy", 'Int'>
    readonly tableName: FieldRef<"DataRetentionPolicy", 'String'>
    readonly retentionDays: FieldRef<"DataRetentionPolicy", 'Int'>
    readonly archiveEnabled: FieldRef<"DataRetentionPolicy", 'Boolean'>
    readonly archiveTableName: FieldRef<"DataRetentionPolicy", 'String'>
    readonly lastArchived: FieldRef<"DataRetentionPolicy", 'DateTime'>
    readonly createdAt: FieldRef<"DataRetentionPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataRetentionPolicy findUnique
   */
  export type DataRetentionPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy findUniqueOrThrow
   */
  export type DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy findFirst
   */
  export type DataRetentionPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRetentionPolicies.
     */
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy findFirstOrThrow
   */
  export type DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRetentionPolicies.
     */
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy findMany
   */
  export type DataRetentionPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicies to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy create
   */
  export type DataRetentionPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * The data needed to create a DataRetentionPolicy.
     */
    data: XOR<DataRetentionPolicyCreateInput, DataRetentionPolicyUncheckedCreateInput>
  }

  /**
   * DataRetentionPolicy createMany
   */
  export type DataRetentionPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataRetentionPolicies.
     */
    data: DataRetentionPolicyCreateManyInput | DataRetentionPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRetentionPolicy createManyAndReturn
   */
  export type DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataRetentionPolicies.
     */
    data: DataRetentionPolicyCreateManyInput | DataRetentionPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRetentionPolicy update
   */
  export type DataRetentionPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * The data needed to update a DataRetentionPolicy.
     */
    data: XOR<DataRetentionPolicyUpdateInput, DataRetentionPolicyUncheckedUpdateInput>
    /**
     * Choose, which DataRetentionPolicy to update.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy updateMany
   */
  export type DataRetentionPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataRetentionPolicies.
     */
    data: XOR<DataRetentionPolicyUpdateManyMutationInput, DataRetentionPolicyUncheckedUpdateManyInput>
    /**
     * Filter which DataRetentionPolicies to update
     */
    where?: DataRetentionPolicyWhereInput
  }

  /**
   * DataRetentionPolicy upsert
   */
  export type DataRetentionPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * The filter to search for the DataRetentionPolicy to update in case it exists.
     */
    where: DataRetentionPolicyWhereUniqueInput
    /**
     * In case the DataRetentionPolicy found by the `where` argument doesn't exist, create a new DataRetentionPolicy with this data.
     */
    create: XOR<DataRetentionPolicyCreateInput, DataRetentionPolicyUncheckedCreateInput>
    /**
     * In case the DataRetentionPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataRetentionPolicyUpdateInput, DataRetentionPolicyUncheckedUpdateInput>
  }

  /**
   * DataRetentionPolicy delete
   */
  export type DataRetentionPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Filter which DataRetentionPolicy to delete.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy deleteMany
   */
  export type DataRetentionPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRetentionPolicies to delete
     */
    where?: DataRetentionPolicyWhereInput
  }

  /**
   * DataRetentionPolicy without action
   */
  export type DataRetentionPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
  }


  /**
   * Model QueryPerformance
   */

  export type AggregateQueryPerformance = {
    _count: QueryPerformanceCountAggregateOutputType | null
    _avg: QueryPerformanceAvgAggregateOutputType | null
    _sum: QueryPerformanceSumAggregateOutputType | null
    _min: QueryPerformanceMinAggregateOutputType | null
    _max: QueryPerformanceMaxAggregateOutputType | null
  }

  export type QueryPerformanceAvgAggregateOutputType = {
    id: number | null
    totalTime: Decimal | null
    meanTime: Decimal | null
    maxTime: Decimal | null
    minTime: Decimal | null
    calls: number | null
    rows: number | null
  }

  export type QueryPerformanceSumAggregateOutputType = {
    id: number | null
    totalTime: Decimal | null
    meanTime: Decimal | null
    maxTime: Decimal | null
    minTime: Decimal | null
    calls: bigint | null
    rows: bigint | null
  }

  export type QueryPerformanceMinAggregateOutputType = {
    id: number | null
    queryHash: string | null
    queryText: string | null
    totalTime: Decimal | null
    meanTime: Decimal | null
    maxTime: Decimal | null
    minTime: Decimal | null
    calls: bigint | null
    rows: bigint | null
    capturedAt: Date | null
  }

  export type QueryPerformanceMaxAggregateOutputType = {
    id: number | null
    queryHash: string | null
    queryText: string | null
    totalTime: Decimal | null
    meanTime: Decimal | null
    maxTime: Decimal | null
    minTime: Decimal | null
    calls: bigint | null
    rows: bigint | null
    capturedAt: Date | null
  }

  export type QueryPerformanceCountAggregateOutputType = {
    id: number
    queryHash: number
    queryText: number
    totalTime: number
    meanTime: number
    maxTime: number
    minTime: number
    calls: number
    rows: number
    capturedAt: number
    _all: number
  }


  export type QueryPerformanceAvgAggregateInputType = {
    id?: true
    totalTime?: true
    meanTime?: true
    maxTime?: true
    minTime?: true
    calls?: true
    rows?: true
  }

  export type QueryPerformanceSumAggregateInputType = {
    id?: true
    totalTime?: true
    meanTime?: true
    maxTime?: true
    minTime?: true
    calls?: true
    rows?: true
  }

  export type QueryPerformanceMinAggregateInputType = {
    id?: true
    queryHash?: true
    queryText?: true
    totalTime?: true
    meanTime?: true
    maxTime?: true
    minTime?: true
    calls?: true
    rows?: true
    capturedAt?: true
  }

  export type QueryPerformanceMaxAggregateInputType = {
    id?: true
    queryHash?: true
    queryText?: true
    totalTime?: true
    meanTime?: true
    maxTime?: true
    minTime?: true
    calls?: true
    rows?: true
    capturedAt?: true
  }

  export type QueryPerformanceCountAggregateInputType = {
    id?: true
    queryHash?: true
    queryText?: true
    totalTime?: true
    meanTime?: true
    maxTime?: true
    minTime?: true
    calls?: true
    rows?: true
    capturedAt?: true
    _all?: true
  }

  export type QueryPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueryPerformance to aggregate.
     */
    where?: QueryPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryPerformances to fetch.
     */
    orderBy?: QueryPerformanceOrderByWithRelationInput | QueryPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueryPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueryPerformances
    **/
    _count?: true | QueryPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueryPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueryPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueryPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueryPerformanceMaxAggregateInputType
  }

  export type GetQueryPerformanceAggregateType<T extends QueryPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateQueryPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueryPerformance[P]>
      : GetScalarType<T[P], AggregateQueryPerformance[P]>
  }




  export type QueryPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryPerformanceWhereInput
    orderBy?: QueryPerformanceOrderByWithAggregationInput | QueryPerformanceOrderByWithAggregationInput[]
    by: QueryPerformanceScalarFieldEnum[] | QueryPerformanceScalarFieldEnum
    having?: QueryPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueryPerformanceCountAggregateInputType | true
    _avg?: QueryPerformanceAvgAggregateInputType
    _sum?: QueryPerformanceSumAggregateInputType
    _min?: QueryPerformanceMinAggregateInputType
    _max?: QueryPerformanceMaxAggregateInputType
  }

  export type QueryPerformanceGroupByOutputType = {
    id: number
    queryHash: string
    queryText: string | null
    totalTime: Decimal
    meanTime: Decimal
    maxTime: Decimal
    minTime: Decimal
    calls: bigint
    rows: bigint
    capturedAt: Date
    _count: QueryPerformanceCountAggregateOutputType | null
    _avg: QueryPerformanceAvgAggregateOutputType | null
    _sum: QueryPerformanceSumAggregateOutputType | null
    _min: QueryPerformanceMinAggregateOutputType | null
    _max: QueryPerformanceMaxAggregateOutputType | null
  }

  type GetQueryPerformanceGroupByPayload<T extends QueryPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueryPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueryPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueryPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], QueryPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type QueryPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryHash?: boolean
    queryText?: boolean
    totalTime?: boolean
    meanTime?: boolean
    maxTime?: boolean
    minTime?: boolean
    calls?: boolean
    rows?: boolean
    capturedAt?: boolean
  }, ExtArgs["result"]["queryPerformance"]>

  export type QueryPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryHash?: boolean
    queryText?: boolean
    totalTime?: boolean
    meanTime?: boolean
    maxTime?: boolean
    minTime?: boolean
    calls?: boolean
    rows?: boolean
    capturedAt?: boolean
  }, ExtArgs["result"]["queryPerformance"]>

  export type QueryPerformanceSelectScalar = {
    id?: boolean
    queryHash?: boolean
    queryText?: boolean
    totalTime?: boolean
    meanTime?: boolean
    maxTime?: boolean
    minTime?: boolean
    calls?: boolean
    rows?: boolean
    capturedAt?: boolean
  }


  export type $QueryPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueryPerformance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      queryHash: string
      queryText: string | null
      totalTime: Prisma.Decimal
      meanTime: Prisma.Decimal
      maxTime: Prisma.Decimal
      minTime: Prisma.Decimal
      calls: bigint
      rows: bigint
      capturedAt: Date
    }, ExtArgs["result"]["queryPerformance"]>
    composites: {}
  }

  type QueryPerformanceGetPayload<S extends boolean | null | undefined | QueryPerformanceDefaultArgs> = $Result.GetResult<Prisma.$QueryPerformancePayload, S>

  type QueryPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QueryPerformanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QueryPerformanceCountAggregateInputType | true
    }

  export interface QueryPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueryPerformance'], meta: { name: 'QueryPerformance' } }
    /**
     * Find zero or one QueryPerformance that matches the filter.
     * @param {QueryPerformanceFindUniqueArgs} args - Arguments to find a QueryPerformance
     * @example
     * // Get one QueryPerformance
     * const queryPerformance = await prisma.queryPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueryPerformanceFindUniqueArgs>(args: SelectSubset<T, QueryPerformanceFindUniqueArgs<ExtArgs>>): Prisma__QueryPerformanceClient<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QueryPerformance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QueryPerformanceFindUniqueOrThrowArgs} args - Arguments to find a QueryPerformance
     * @example
     * // Get one QueryPerformance
     * const queryPerformance = await prisma.queryPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueryPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, QueryPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueryPerformanceClient<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QueryPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryPerformanceFindFirstArgs} args - Arguments to find a QueryPerformance
     * @example
     * // Get one QueryPerformance
     * const queryPerformance = await prisma.queryPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueryPerformanceFindFirstArgs>(args?: SelectSubset<T, QueryPerformanceFindFirstArgs<ExtArgs>>): Prisma__QueryPerformanceClient<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QueryPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryPerformanceFindFirstOrThrowArgs} args - Arguments to find a QueryPerformance
     * @example
     * // Get one QueryPerformance
     * const queryPerformance = await prisma.queryPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueryPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, QueryPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueryPerformanceClient<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QueryPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueryPerformances
     * const queryPerformances = await prisma.queryPerformance.findMany()
     * 
     * // Get first 10 QueryPerformances
     * const queryPerformances = await prisma.queryPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queryPerformanceWithIdOnly = await prisma.queryPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueryPerformanceFindManyArgs>(args?: SelectSubset<T, QueryPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QueryPerformance.
     * @param {QueryPerformanceCreateArgs} args - Arguments to create a QueryPerformance.
     * @example
     * // Create one QueryPerformance
     * const QueryPerformance = await prisma.queryPerformance.create({
     *   data: {
     *     // ... data to create a QueryPerformance
     *   }
     * })
     * 
     */
    create<T extends QueryPerformanceCreateArgs>(args: SelectSubset<T, QueryPerformanceCreateArgs<ExtArgs>>): Prisma__QueryPerformanceClient<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QueryPerformances.
     * @param {QueryPerformanceCreateManyArgs} args - Arguments to create many QueryPerformances.
     * @example
     * // Create many QueryPerformances
     * const queryPerformance = await prisma.queryPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueryPerformanceCreateManyArgs>(args?: SelectSubset<T, QueryPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueryPerformances and returns the data saved in the database.
     * @param {QueryPerformanceCreateManyAndReturnArgs} args - Arguments to create many QueryPerformances.
     * @example
     * // Create many QueryPerformances
     * const queryPerformance = await prisma.queryPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueryPerformances and only return the `id`
     * const queryPerformanceWithIdOnly = await prisma.queryPerformance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueryPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, QueryPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QueryPerformance.
     * @param {QueryPerformanceDeleteArgs} args - Arguments to delete one QueryPerformance.
     * @example
     * // Delete one QueryPerformance
     * const QueryPerformance = await prisma.queryPerformance.delete({
     *   where: {
     *     // ... filter to delete one QueryPerformance
     *   }
     * })
     * 
     */
    delete<T extends QueryPerformanceDeleteArgs>(args: SelectSubset<T, QueryPerformanceDeleteArgs<ExtArgs>>): Prisma__QueryPerformanceClient<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QueryPerformance.
     * @param {QueryPerformanceUpdateArgs} args - Arguments to update one QueryPerformance.
     * @example
     * // Update one QueryPerformance
     * const queryPerformance = await prisma.queryPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueryPerformanceUpdateArgs>(args: SelectSubset<T, QueryPerformanceUpdateArgs<ExtArgs>>): Prisma__QueryPerformanceClient<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QueryPerformances.
     * @param {QueryPerformanceDeleteManyArgs} args - Arguments to filter QueryPerformances to delete.
     * @example
     * // Delete a few QueryPerformances
     * const { count } = await prisma.queryPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueryPerformanceDeleteManyArgs>(args?: SelectSubset<T, QueryPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueryPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueryPerformances
     * const queryPerformance = await prisma.queryPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueryPerformanceUpdateManyArgs>(args: SelectSubset<T, QueryPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QueryPerformance.
     * @param {QueryPerformanceUpsertArgs} args - Arguments to update or create a QueryPerformance.
     * @example
     * // Update or create a QueryPerformance
     * const queryPerformance = await prisma.queryPerformance.upsert({
     *   create: {
     *     // ... data to create a QueryPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueryPerformance we want to update
     *   }
     * })
     */
    upsert<T extends QueryPerformanceUpsertArgs>(args: SelectSubset<T, QueryPerformanceUpsertArgs<ExtArgs>>): Prisma__QueryPerformanceClient<$Result.GetResult<Prisma.$QueryPerformancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QueryPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryPerformanceCountArgs} args - Arguments to filter QueryPerformances to count.
     * @example
     * // Count the number of QueryPerformances
     * const count = await prisma.queryPerformance.count({
     *   where: {
     *     // ... the filter for the QueryPerformances we want to count
     *   }
     * })
    **/
    count<T extends QueryPerformanceCountArgs>(
      args?: Subset<T, QueryPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueryPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueryPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueryPerformanceAggregateArgs>(args: Subset<T, QueryPerformanceAggregateArgs>): Prisma.PrismaPromise<GetQueryPerformanceAggregateType<T>>

    /**
     * Group by QueryPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueryPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueryPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: QueryPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueryPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueryPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueryPerformance model
   */
  readonly fields: QueryPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueryPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueryPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueryPerformance model
   */ 
  interface QueryPerformanceFieldRefs {
    readonly id: FieldRef<"QueryPerformance", 'Int'>
    readonly queryHash: FieldRef<"QueryPerformance", 'String'>
    readonly queryText: FieldRef<"QueryPerformance", 'String'>
    readonly totalTime: FieldRef<"QueryPerformance", 'Decimal'>
    readonly meanTime: FieldRef<"QueryPerformance", 'Decimal'>
    readonly maxTime: FieldRef<"QueryPerformance", 'Decimal'>
    readonly minTime: FieldRef<"QueryPerformance", 'Decimal'>
    readonly calls: FieldRef<"QueryPerformance", 'BigInt'>
    readonly rows: FieldRef<"QueryPerformance", 'BigInt'>
    readonly capturedAt: FieldRef<"QueryPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueryPerformance findUnique
   */
  export type QueryPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which QueryPerformance to fetch.
     */
    where: QueryPerformanceWhereUniqueInput
  }

  /**
   * QueryPerformance findUniqueOrThrow
   */
  export type QueryPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which QueryPerformance to fetch.
     */
    where: QueryPerformanceWhereUniqueInput
  }

  /**
   * QueryPerformance findFirst
   */
  export type QueryPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which QueryPerformance to fetch.
     */
    where?: QueryPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryPerformances to fetch.
     */
    orderBy?: QueryPerformanceOrderByWithRelationInput | QueryPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueryPerformances.
     */
    cursor?: QueryPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueryPerformances.
     */
    distinct?: QueryPerformanceScalarFieldEnum | QueryPerformanceScalarFieldEnum[]
  }

  /**
   * QueryPerformance findFirstOrThrow
   */
  export type QueryPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which QueryPerformance to fetch.
     */
    where?: QueryPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryPerformances to fetch.
     */
    orderBy?: QueryPerformanceOrderByWithRelationInput | QueryPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueryPerformances.
     */
    cursor?: QueryPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueryPerformances.
     */
    distinct?: QueryPerformanceScalarFieldEnum | QueryPerformanceScalarFieldEnum[]
  }

  /**
   * QueryPerformance findMany
   */
  export type QueryPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * Filter, which QueryPerformances to fetch.
     */
    where?: QueryPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryPerformances to fetch.
     */
    orderBy?: QueryPerformanceOrderByWithRelationInput | QueryPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueryPerformances.
     */
    cursor?: QueryPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryPerformances.
     */
    skip?: number
    distinct?: QueryPerformanceScalarFieldEnum | QueryPerformanceScalarFieldEnum[]
  }

  /**
   * QueryPerformance create
   */
  export type QueryPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * The data needed to create a QueryPerformance.
     */
    data: XOR<QueryPerformanceCreateInput, QueryPerformanceUncheckedCreateInput>
  }

  /**
   * QueryPerformance createMany
   */
  export type QueryPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueryPerformances.
     */
    data: QueryPerformanceCreateManyInput | QueryPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueryPerformance createManyAndReturn
   */
  export type QueryPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QueryPerformances.
     */
    data: QueryPerformanceCreateManyInput | QueryPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueryPerformance update
   */
  export type QueryPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * The data needed to update a QueryPerformance.
     */
    data: XOR<QueryPerformanceUpdateInput, QueryPerformanceUncheckedUpdateInput>
    /**
     * Choose, which QueryPerformance to update.
     */
    where: QueryPerformanceWhereUniqueInput
  }

  /**
   * QueryPerformance updateMany
   */
  export type QueryPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueryPerformances.
     */
    data: XOR<QueryPerformanceUpdateManyMutationInput, QueryPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which QueryPerformances to update
     */
    where?: QueryPerformanceWhereInput
  }

  /**
   * QueryPerformance upsert
   */
  export type QueryPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * The filter to search for the QueryPerformance to update in case it exists.
     */
    where: QueryPerformanceWhereUniqueInput
    /**
     * In case the QueryPerformance found by the `where` argument doesn't exist, create a new QueryPerformance with this data.
     */
    create: XOR<QueryPerformanceCreateInput, QueryPerformanceUncheckedCreateInput>
    /**
     * In case the QueryPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueryPerformanceUpdateInput, QueryPerformanceUncheckedUpdateInput>
  }

  /**
   * QueryPerformance delete
   */
  export type QueryPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
    /**
     * Filter which QueryPerformance to delete.
     */
    where: QueryPerformanceWhereUniqueInput
  }

  /**
   * QueryPerformance deleteMany
   */
  export type QueryPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueryPerformances to delete
     */
    where?: QueryPerformanceWhereInput
  }

  /**
   * QueryPerformance without action
   */
  export type QueryPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryPerformance
     */
    select?: QueryPerformanceSelect<ExtArgs> | null
  }


  /**
   * Model DataQualityScores
   */

  export type AggregateDataQualityScores = {
    _count: DataQualityScoresCountAggregateOutputType | null
    _avg: DataQualityScoresAvgAggregateOutputType | null
    _sum: DataQualityScoresSumAggregateOutputType | null
    _min: DataQualityScoresMinAggregateOutputType | null
    _max: DataQualityScoresMaxAggregateOutputType | null
  }

  export type DataQualityScoresAvgAggregateOutputType = {
    id: number | null
    score: Decimal | null
    totalRows: number | null
    failedRows: number | null
  }

  export type DataQualityScoresSumAggregateOutputType = {
    id: number | null
    score: Decimal | null
    totalRows: bigint | null
    failedRows: bigint | null
  }

  export type DataQualityScoresMinAggregateOutputType = {
    id: number | null
    tableName: string | null
    checkName: string | null
    checkType: string | null
    passed: boolean | null
    score: Decimal | null
    totalRows: bigint | null
    failedRows: bigint | null
    checkedAt: Date | null
  }

  export type DataQualityScoresMaxAggregateOutputType = {
    id: number | null
    tableName: string | null
    checkName: string | null
    checkType: string | null
    passed: boolean | null
    score: Decimal | null
    totalRows: bigint | null
    failedRows: bigint | null
    checkedAt: Date | null
  }

  export type DataQualityScoresCountAggregateOutputType = {
    id: number
    tableName: number
    checkName: number
    checkType: number
    passed: number
    score: number
    totalRows: number
    failedRows: number
    details: number
    checkedAt: number
    _all: number
  }


  export type DataQualityScoresAvgAggregateInputType = {
    id?: true
    score?: true
    totalRows?: true
    failedRows?: true
  }

  export type DataQualityScoresSumAggregateInputType = {
    id?: true
    score?: true
    totalRows?: true
    failedRows?: true
  }

  export type DataQualityScoresMinAggregateInputType = {
    id?: true
    tableName?: true
    checkName?: true
    checkType?: true
    passed?: true
    score?: true
    totalRows?: true
    failedRows?: true
    checkedAt?: true
  }

  export type DataQualityScoresMaxAggregateInputType = {
    id?: true
    tableName?: true
    checkName?: true
    checkType?: true
    passed?: true
    score?: true
    totalRows?: true
    failedRows?: true
    checkedAt?: true
  }

  export type DataQualityScoresCountAggregateInputType = {
    id?: true
    tableName?: true
    checkName?: true
    checkType?: true
    passed?: true
    score?: true
    totalRows?: true
    failedRows?: true
    details?: true
    checkedAt?: true
    _all?: true
  }

  export type DataQualityScoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataQualityScores to aggregate.
     */
    where?: DataQualityScoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataQualityScores to fetch.
     */
    orderBy?: DataQualityScoresOrderByWithRelationInput | DataQualityScoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataQualityScoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataQualityScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataQualityScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataQualityScores
    **/
    _count?: true | DataQualityScoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataQualityScoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataQualityScoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataQualityScoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataQualityScoresMaxAggregateInputType
  }

  export type GetDataQualityScoresAggregateType<T extends DataQualityScoresAggregateArgs> = {
        [P in keyof T & keyof AggregateDataQualityScores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataQualityScores[P]>
      : GetScalarType<T[P], AggregateDataQualityScores[P]>
  }




  export type DataQualityScoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataQualityScoresWhereInput
    orderBy?: DataQualityScoresOrderByWithAggregationInput | DataQualityScoresOrderByWithAggregationInput[]
    by: DataQualityScoresScalarFieldEnum[] | DataQualityScoresScalarFieldEnum
    having?: DataQualityScoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataQualityScoresCountAggregateInputType | true
    _avg?: DataQualityScoresAvgAggregateInputType
    _sum?: DataQualityScoresSumAggregateInputType
    _min?: DataQualityScoresMinAggregateInputType
    _max?: DataQualityScoresMaxAggregateInputType
  }

  export type DataQualityScoresGroupByOutputType = {
    id: number
    tableName: string
    checkName: string
    checkType: string
    passed: boolean
    score: Decimal
    totalRows: bigint | null
    failedRows: bigint | null
    details: JsonValue | null
    checkedAt: Date
    _count: DataQualityScoresCountAggregateOutputType | null
    _avg: DataQualityScoresAvgAggregateOutputType | null
    _sum: DataQualityScoresSumAggregateOutputType | null
    _min: DataQualityScoresMinAggregateOutputType | null
    _max: DataQualityScoresMaxAggregateOutputType | null
  }

  type GetDataQualityScoresGroupByPayload<T extends DataQualityScoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataQualityScoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataQualityScoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataQualityScoresGroupByOutputType[P]>
            : GetScalarType<T[P], DataQualityScoresGroupByOutputType[P]>
        }
      >
    >


  export type DataQualityScoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    checkName?: boolean
    checkType?: boolean
    passed?: boolean
    score?: boolean
    totalRows?: boolean
    failedRows?: boolean
    details?: boolean
    checkedAt?: boolean
  }, ExtArgs["result"]["dataQualityScores"]>

  export type DataQualityScoresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    checkName?: boolean
    checkType?: boolean
    passed?: boolean
    score?: boolean
    totalRows?: boolean
    failedRows?: boolean
    details?: boolean
    checkedAt?: boolean
  }, ExtArgs["result"]["dataQualityScores"]>

  export type DataQualityScoresSelectScalar = {
    id?: boolean
    tableName?: boolean
    checkName?: boolean
    checkType?: boolean
    passed?: boolean
    score?: boolean
    totalRows?: boolean
    failedRows?: boolean
    details?: boolean
    checkedAt?: boolean
  }


  export type $DataQualityScoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataQualityScores"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableName: string
      checkName: string
      checkType: string
      passed: boolean
      score: Prisma.Decimal
      totalRows: bigint | null
      failedRows: bigint | null
      details: Prisma.JsonValue | null
      checkedAt: Date
    }, ExtArgs["result"]["dataQualityScores"]>
    composites: {}
  }

  type DataQualityScoresGetPayload<S extends boolean | null | undefined | DataQualityScoresDefaultArgs> = $Result.GetResult<Prisma.$DataQualityScoresPayload, S>

  type DataQualityScoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataQualityScoresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataQualityScoresCountAggregateInputType | true
    }

  export interface DataQualityScoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataQualityScores'], meta: { name: 'DataQualityScores' } }
    /**
     * Find zero or one DataQualityScores that matches the filter.
     * @param {DataQualityScoresFindUniqueArgs} args - Arguments to find a DataQualityScores
     * @example
     * // Get one DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataQualityScoresFindUniqueArgs>(args: SelectSubset<T, DataQualityScoresFindUniqueArgs<ExtArgs>>): Prisma__DataQualityScoresClient<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataQualityScores that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataQualityScoresFindUniqueOrThrowArgs} args - Arguments to find a DataQualityScores
     * @example
     * // Get one DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataQualityScoresFindUniqueOrThrowArgs>(args: SelectSubset<T, DataQualityScoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataQualityScoresClient<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataQualityScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityScoresFindFirstArgs} args - Arguments to find a DataQualityScores
     * @example
     * // Get one DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataQualityScoresFindFirstArgs>(args?: SelectSubset<T, DataQualityScoresFindFirstArgs<ExtArgs>>): Prisma__DataQualityScoresClient<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataQualityScores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityScoresFindFirstOrThrowArgs} args - Arguments to find a DataQualityScores
     * @example
     * // Get one DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataQualityScoresFindFirstOrThrowArgs>(args?: SelectSubset<T, DataQualityScoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataQualityScoresClient<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataQualityScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityScoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.findMany()
     * 
     * // Get first 10 DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataQualityScoresWithIdOnly = await prisma.dataQualityScores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataQualityScoresFindManyArgs>(args?: SelectSubset<T, DataQualityScoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataQualityScores.
     * @param {DataQualityScoresCreateArgs} args - Arguments to create a DataQualityScores.
     * @example
     * // Create one DataQualityScores
     * const DataQualityScores = await prisma.dataQualityScores.create({
     *   data: {
     *     // ... data to create a DataQualityScores
     *   }
     * })
     * 
     */
    create<T extends DataQualityScoresCreateArgs>(args: SelectSubset<T, DataQualityScoresCreateArgs<ExtArgs>>): Prisma__DataQualityScoresClient<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataQualityScores.
     * @param {DataQualityScoresCreateManyArgs} args - Arguments to create many DataQualityScores.
     * @example
     * // Create many DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataQualityScoresCreateManyArgs>(args?: SelectSubset<T, DataQualityScoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataQualityScores and returns the data saved in the database.
     * @param {DataQualityScoresCreateManyAndReturnArgs} args - Arguments to create many DataQualityScores.
     * @example
     * // Create many DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataQualityScores and only return the `id`
     * const dataQualityScoresWithIdOnly = await prisma.dataQualityScores.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataQualityScoresCreateManyAndReturnArgs>(args?: SelectSubset<T, DataQualityScoresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataQualityScores.
     * @param {DataQualityScoresDeleteArgs} args - Arguments to delete one DataQualityScores.
     * @example
     * // Delete one DataQualityScores
     * const DataQualityScores = await prisma.dataQualityScores.delete({
     *   where: {
     *     // ... filter to delete one DataQualityScores
     *   }
     * })
     * 
     */
    delete<T extends DataQualityScoresDeleteArgs>(args: SelectSubset<T, DataQualityScoresDeleteArgs<ExtArgs>>): Prisma__DataQualityScoresClient<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataQualityScores.
     * @param {DataQualityScoresUpdateArgs} args - Arguments to update one DataQualityScores.
     * @example
     * // Update one DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataQualityScoresUpdateArgs>(args: SelectSubset<T, DataQualityScoresUpdateArgs<ExtArgs>>): Prisma__DataQualityScoresClient<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataQualityScores.
     * @param {DataQualityScoresDeleteManyArgs} args - Arguments to filter DataQualityScores to delete.
     * @example
     * // Delete a few DataQualityScores
     * const { count } = await prisma.dataQualityScores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataQualityScoresDeleteManyArgs>(args?: SelectSubset<T, DataQualityScoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataQualityScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityScoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataQualityScoresUpdateManyArgs>(args: SelectSubset<T, DataQualityScoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataQualityScores.
     * @param {DataQualityScoresUpsertArgs} args - Arguments to update or create a DataQualityScores.
     * @example
     * // Update or create a DataQualityScores
     * const dataQualityScores = await prisma.dataQualityScores.upsert({
     *   create: {
     *     // ... data to create a DataQualityScores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataQualityScores we want to update
     *   }
     * })
     */
    upsert<T extends DataQualityScoresUpsertArgs>(args: SelectSubset<T, DataQualityScoresUpsertArgs<ExtArgs>>): Prisma__DataQualityScoresClient<$Result.GetResult<Prisma.$DataQualityScoresPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataQualityScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityScoresCountArgs} args - Arguments to filter DataQualityScores to count.
     * @example
     * // Count the number of DataQualityScores
     * const count = await prisma.dataQualityScores.count({
     *   where: {
     *     // ... the filter for the DataQualityScores we want to count
     *   }
     * })
    **/
    count<T extends DataQualityScoresCountArgs>(
      args?: Subset<T, DataQualityScoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataQualityScoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataQualityScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityScoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataQualityScoresAggregateArgs>(args: Subset<T, DataQualityScoresAggregateArgs>): Prisma.PrismaPromise<GetDataQualityScoresAggregateType<T>>

    /**
     * Group by DataQualityScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataQualityScoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataQualityScoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataQualityScoresGroupByArgs['orderBy'] }
        : { orderBy?: DataQualityScoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataQualityScoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataQualityScoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataQualityScores model
   */
  readonly fields: DataQualityScoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataQualityScores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataQualityScoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataQualityScores model
   */ 
  interface DataQualityScoresFieldRefs {
    readonly id: FieldRef<"DataQualityScores", 'Int'>
    readonly tableName: FieldRef<"DataQualityScores", 'String'>
    readonly checkName: FieldRef<"DataQualityScores", 'String'>
    readonly checkType: FieldRef<"DataQualityScores", 'String'>
    readonly passed: FieldRef<"DataQualityScores", 'Boolean'>
    readonly score: FieldRef<"DataQualityScores", 'Decimal'>
    readonly totalRows: FieldRef<"DataQualityScores", 'BigInt'>
    readonly failedRows: FieldRef<"DataQualityScores", 'BigInt'>
    readonly details: FieldRef<"DataQualityScores", 'Json'>
    readonly checkedAt: FieldRef<"DataQualityScores", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataQualityScores findUnique
   */
  export type DataQualityScoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * Filter, which DataQualityScores to fetch.
     */
    where: DataQualityScoresWhereUniqueInput
  }

  /**
   * DataQualityScores findUniqueOrThrow
   */
  export type DataQualityScoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * Filter, which DataQualityScores to fetch.
     */
    where: DataQualityScoresWhereUniqueInput
  }

  /**
   * DataQualityScores findFirst
   */
  export type DataQualityScoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * Filter, which DataQualityScores to fetch.
     */
    where?: DataQualityScoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataQualityScores to fetch.
     */
    orderBy?: DataQualityScoresOrderByWithRelationInput | DataQualityScoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataQualityScores.
     */
    cursor?: DataQualityScoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataQualityScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataQualityScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataQualityScores.
     */
    distinct?: DataQualityScoresScalarFieldEnum | DataQualityScoresScalarFieldEnum[]
  }

  /**
   * DataQualityScores findFirstOrThrow
   */
  export type DataQualityScoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * Filter, which DataQualityScores to fetch.
     */
    where?: DataQualityScoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataQualityScores to fetch.
     */
    orderBy?: DataQualityScoresOrderByWithRelationInput | DataQualityScoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataQualityScores.
     */
    cursor?: DataQualityScoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataQualityScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataQualityScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataQualityScores.
     */
    distinct?: DataQualityScoresScalarFieldEnum | DataQualityScoresScalarFieldEnum[]
  }

  /**
   * DataQualityScores findMany
   */
  export type DataQualityScoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * Filter, which DataQualityScores to fetch.
     */
    where?: DataQualityScoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataQualityScores to fetch.
     */
    orderBy?: DataQualityScoresOrderByWithRelationInput | DataQualityScoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataQualityScores.
     */
    cursor?: DataQualityScoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataQualityScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataQualityScores.
     */
    skip?: number
    distinct?: DataQualityScoresScalarFieldEnum | DataQualityScoresScalarFieldEnum[]
  }

  /**
   * DataQualityScores create
   */
  export type DataQualityScoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * The data needed to create a DataQualityScores.
     */
    data: XOR<DataQualityScoresCreateInput, DataQualityScoresUncheckedCreateInput>
  }

  /**
   * DataQualityScores createMany
   */
  export type DataQualityScoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataQualityScores.
     */
    data: DataQualityScoresCreateManyInput | DataQualityScoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataQualityScores createManyAndReturn
   */
  export type DataQualityScoresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataQualityScores.
     */
    data: DataQualityScoresCreateManyInput | DataQualityScoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataQualityScores update
   */
  export type DataQualityScoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * The data needed to update a DataQualityScores.
     */
    data: XOR<DataQualityScoresUpdateInput, DataQualityScoresUncheckedUpdateInput>
    /**
     * Choose, which DataQualityScores to update.
     */
    where: DataQualityScoresWhereUniqueInput
  }

  /**
   * DataQualityScores updateMany
   */
  export type DataQualityScoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataQualityScores.
     */
    data: XOR<DataQualityScoresUpdateManyMutationInput, DataQualityScoresUncheckedUpdateManyInput>
    /**
     * Filter which DataQualityScores to update
     */
    where?: DataQualityScoresWhereInput
  }

  /**
   * DataQualityScores upsert
   */
  export type DataQualityScoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * The filter to search for the DataQualityScores to update in case it exists.
     */
    where: DataQualityScoresWhereUniqueInput
    /**
     * In case the DataQualityScores found by the `where` argument doesn't exist, create a new DataQualityScores with this data.
     */
    create: XOR<DataQualityScoresCreateInput, DataQualityScoresUncheckedCreateInput>
    /**
     * In case the DataQualityScores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataQualityScoresUpdateInput, DataQualityScoresUncheckedUpdateInput>
  }

  /**
   * DataQualityScores delete
   */
  export type DataQualityScoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
    /**
     * Filter which DataQualityScores to delete.
     */
    where: DataQualityScoresWhereUniqueInput
  }

  /**
   * DataQualityScores deleteMany
   */
  export type DataQualityScoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataQualityScores to delete
     */
    where?: DataQualityScoresWhereInput
  }

  /**
   * DataQualityScores without action
   */
  export type DataQualityScoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataQualityScores
     */
    select?: DataQualityScoresSelect<ExtArgs> | null
  }


  /**
   * Model SystemMetrics
   */

  export type AggregateSystemMetrics = {
    _count: SystemMetricsCountAggregateOutputType | null
    _avg: SystemMetricsAvgAggregateOutputType | null
    _sum: SystemMetricsSumAggregateOutputType | null
    _min: SystemMetricsMinAggregateOutputType | null
    _max: SystemMetricsMaxAggregateOutputType | null
  }

  export type SystemMetricsAvgAggregateOutputType = {
    id: number | null
    metricValue: Decimal | null
  }

  export type SystemMetricsSumAggregateOutputType = {
    id: number | null
    metricValue: Decimal | null
  }

  export type SystemMetricsMinAggregateOutputType = {
    id: number | null
    metricType: string | null
    metricName: string | null
    metricValue: Decimal | null
    metricUnit: string | null
    hostName: string | null
    serviceName: string | null
    collectedAt: Date | null
  }

  export type SystemMetricsMaxAggregateOutputType = {
    id: number | null
    metricType: string | null
    metricName: string | null
    metricValue: Decimal | null
    metricUnit: string | null
    hostName: string | null
    serviceName: string | null
    collectedAt: Date | null
  }

  export type SystemMetricsCountAggregateOutputType = {
    id: number
    metricType: number
    metricName: number
    metricValue: number
    metricUnit: number
    hostName: number
    serviceName: number
    tags: number
    collectedAt: number
    _all: number
  }


  export type SystemMetricsAvgAggregateInputType = {
    id?: true
    metricValue?: true
  }

  export type SystemMetricsSumAggregateInputType = {
    id?: true
    metricValue?: true
  }

  export type SystemMetricsMinAggregateInputType = {
    id?: true
    metricType?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    hostName?: true
    serviceName?: true
    collectedAt?: true
  }

  export type SystemMetricsMaxAggregateInputType = {
    id?: true
    metricType?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    hostName?: true
    serviceName?: true
    collectedAt?: true
  }

  export type SystemMetricsCountAggregateInputType = {
    id?: true
    metricType?: true
    metricName?: true
    metricValue?: true
    metricUnit?: true
    hostName?: true
    serviceName?: true
    tags?: true
    collectedAt?: true
    _all?: true
  }

  export type SystemMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMetrics to aggregate.
     */
    where?: SystemMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricsOrderByWithRelationInput | SystemMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemMetrics
    **/
    _count?: true | SystemMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemMetricsMaxAggregateInputType
  }

  export type GetSystemMetricsAggregateType<T extends SystemMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemMetrics[P]>
      : GetScalarType<T[P], AggregateSystemMetrics[P]>
  }




  export type SystemMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemMetricsWhereInput
    orderBy?: SystemMetricsOrderByWithAggregationInput | SystemMetricsOrderByWithAggregationInput[]
    by: SystemMetricsScalarFieldEnum[] | SystemMetricsScalarFieldEnum
    having?: SystemMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemMetricsCountAggregateInputType | true
    _avg?: SystemMetricsAvgAggregateInputType
    _sum?: SystemMetricsSumAggregateInputType
    _min?: SystemMetricsMinAggregateInputType
    _max?: SystemMetricsMaxAggregateInputType
  }

  export type SystemMetricsGroupByOutputType = {
    id: number
    metricType: string
    metricName: string
    metricValue: Decimal
    metricUnit: string | null
    hostName: string | null
    serviceName: string | null
    tags: JsonValue | null
    collectedAt: Date
    _count: SystemMetricsCountAggregateOutputType | null
    _avg: SystemMetricsAvgAggregateOutputType | null
    _sum: SystemMetricsSumAggregateOutputType | null
    _min: SystemMetricsMinAggregateOutputType | null
    _max: SystemMetricsMaxAggregateOutputType | null
  }

  type GetSystemMetricsGroupByPayload<T extends SystemMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemMetricsGroupByOutputType[P]>
        }
      >
    >


  export type SystemMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricType?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    hostName?: boolean
    serviceName?: boolean
    tags?: boolean
    collectedAt?: boolean
  }, ExtArgs["result"]["systemMetrics"]>

  export type SystemMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricType?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    hostName?: boolean
    serviceName?: boolean
    tags?: boolean
    collectedAt?: boolean
  }, ExtArgs["result"]["systemMetrics"]>

  export type SystemMetricsSelectScalar = {
    id?: boolean
    metricType?: boolean
    metricName?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    hostName?: boolean
    serviceName?: boolean
    tags?: boolean
    collectedAt?: boolean
  }


  export type $SystemMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      metricType: string
      metricName: string
      metricValue: Prisma.Decimal
      metricUnit: string | null
      hostName: string | null
      serviceName: string | null
      tags: Prisma.JsonValue | null
      collectedAt: Date
    }, ExtArgs["result"]["systemMetrics"]>
    composites: {}
  }

  type SystemMetricsGetPayload<S extends boolean | null | undefined | SystemMetricsDefaultArgs> = $Result.GetResult<Prisma.$SystemMetricsPayload, S>

  type SystemMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemMetricsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemMetricsCountAggregateInputType | true
    }

  export interface SystemMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemMetrics'], meta: { name: 'SystemMetrics' } }
    /**
     * Find zero or one SystemMetrics that matches the filter.
     * @param {SystemMetricsFindUniqueArgs} args - Arguments to find a SystemMetrics
     * @example
     * // Get one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemMetricsFindUniqueArgs>(args: SelectSubset<T, SystemMetricsFindUniqueArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemMetrics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemMetricsFindUniqueOrThrowArgs} args - Arguments to find a SystemMetrics
     * @example
     * // Get one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsFindFirstArgs} args - Arguments to find a SystemMetrics
     * @example
     * // Get one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemMetricsFindFirstArgs>(args?: SelectSubset<T, SystemMetricsFindFirstArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsFindFirstOrThrowArgs} args - Arguments to find a SystemMetrics
     * @example
     * // Get one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findMany()
     * 
     * // Get first 10 SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemMetricsWithIdOnly = await prisma.systemMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemMetricsFindManyArgs>(args?: SelectSubset<T, SystemMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemMetrics.
     * @param {SystemMetricsCreateArgs} args - Arguments to create a SystemMetrics.
     * @example
     * // Create one SystemMetrics
     * const SystemMetrics = await prisma.systemMetrics.create({
     *   data: {
     *     // ... data to create a SystemMetrics
     *   }
     * })
     * 
     */
    create<T extends SystemMetricsCreateArgs>(args: SelectSubset<T, SystemMetricsCreateArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemMetrics.
     * @param {SystemMetricsCreateManyArgs} args - Arguments to create many SystemMetrics.
     * @example
     * // Create many SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemMetricsCreateManyArgs>(args?: SelectSubset<T, SystemMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemMetrics and returns the data saved in the database.
     * @param {SystemMetricsCreateManyAndReturnArgs} args - Arguments to create many SystemMetrics.
     * @example
     * // Create many SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemMetrics and only return the `id`
     * const systemMetricsWithIdOnly = await prisma.systemMetrics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemMetrics.
     * @param {SystemMetricsDeleteArgs} args - Arguments to delete one SystemMetrics.
     * @example
     * // Delete one SystemMetrics
     * const SystemMetrics = await prisma.systemMetrics.delete({
     *   where: {
     *     // ... filter to delete one SystemMetrics
     *   }
     * })
     * 
     */
    delete<T extends SystemMetricsDeleteArgs>(args: SelectSubset<T, SystemMetricsDeleteArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemMetrics.
     * @param {SystemMetricsUpdateArgs} args - Arguments to update one SystemMetrics.
     * @example
     * // Update one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemMetricsUpdateArgs>(args: SelectSubset<T, SystemMetricsUpdateArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemMetrics.
     * @param {SystemMetricsDeleteManyArgs} args - Arguments to filter SystemMetrics to delete.
     * @example
     * // Delete a few SystemMetrics
     * const { count } = await prisma.systemMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemMetricsDeleteManyArgs>(args?: SelectSubset<T, SystemMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemMetricsUpdateManyArgs>(args: SelectSubset<T, SystemMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemMetrics.
     * @param {SystemMetricsUpsertArgs} args - Arguments to update or create a SystemMetrics.
     * @example
     * // Update or create a SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.upsert({
     *   create: {
     *     // ... data to create a SystemMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemMetrics we want to update
     *   }
     * })
     */
    upsert<T extends SystemMetricsUpsertArgs>(args: SelectSubset<T, SystemMetricsUpsertArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsCountArgs} args - Arguments to filter SystemMetrics to count.
     * @example
     * // Count the number of SystemMetrics
     * const count = await prisma.systemMetrics.count({
     *   where: {
     *     // ... the filter for the SystemMetrics we want to count
     *   }
     * })
    **/
    count<T extends SystemMetricsCountArgs>(
      args?: Subset<T, SystemMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemMetricsAggregateArgs>(args: Subset<T, SystemMetricsAggregateArgs>): Prisma.PrismaPromise<GetSystemMetricsAggregateType<T>>

    /**
     * Group by SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemMetricsGroupByArgs['orderBy'] }
        : { orderBy?: SystemMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemMetrics model
   */
  readonly fields: SystemMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemMetrics model
   */ 
  interface SystemMetricsFieldRefs {
    readonly id: FieldRef<"SystemMetrics", 'Int'>
    readonly metricType: FieldRef<"SystemMetrics", 'String'>
    readonly metricName: FieldRef<"SystemMetrics", 'String'>
    readonly metricValue: FieldRef<"SystemMetrics", 'Decimal'>
    readonly metricUnit: FieldRef<"SystemMetrics", 'String'>
    readonly hostName: FieldRef<"SystemMetrics", 'String'>
    readonly serviceName: FieldRef<"SystemMetrics", 'String'>
    readonly tags: FieldRef<"SystemMetrics", 'Json'>
    readonly collectedAt: FieldRef<"SystemMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemMetrics findUnique
   */
  export type SystemMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where: SystemMetricsWhereUniqueInput
  }

  /**
   * SystemMetrics findUniqueOrThrow
   */
  export type SystemMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where: SystemMetricsWhereUniqueInput
  }

  /**
   * SystemMetrics findFirst
   */
  export type SystemMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where?: SystemMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricsOrderByWithRelationInput | SystemMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMetrics.
     */
    cursor?: SystemMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMetrics.
     */
    distinct?: SystemMetricsScalarFieldEnum | SystemMetricsScalarFieldEnum[]
  }

  /**
   * SystemMetrics findFirstOrThrow
   */
  export type SystemMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where?: SystemMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricsOrderByWithRelationInput | SystemMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMetrics.
     */
    cursor?: SystemMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMetrics.
     */
    distinct?: SystemMetricsScalarFieldEnum | SystemMetricsScalarFieldEnum[]
  }

  /**
   * SystemMetrics findMany
   */
  export type SystemMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where?: SystemMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricsOrderByWithRelationInput | SystemMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemMetrics.
     */
    cursor?: SystemMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    distinct?: SystemMetricsScalarFieldEnum | SystemMetricsScalarFieldEnum[]
  }

  /**
   * SystemMetrics create
   */
  export type SystemMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemMetrics.
     */
    data: XOR<SystemMetricsCreateInput, SystemMetricsUncheckedCreateInput>
  }

  /**
   * SystemMetrics createMany
   */
  export type SystemMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemMetrics.
     */
    data: SystemMetricsCreateManyInput | SystemMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemMetrics createManyAndReturn
   */
  export type SystemMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemMetrics.
     */
    data: SystemMetricsCreateManyInput | SystemMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemMetrics update
   */
  export type SystemMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemMetrics.
     */
    data: XOR<SystemMetricsUpdateInput, SystemMetricsUncheckedUpdateInput>
    /**
     * Choose, which SystemMetrics to update.
     */
    where: SystemMetricsWhereUniqueInput
  }

  /**
   * SystemMetrics updateMany
   */
  export type SystemMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemMetrics.
     */
    data: XOR<SystemMetricsUpdateManyMutationInput, SystemMetricsUncheckedUpdateManyInput>
    /**
     * Filter which SystemMetrics to update
     */
    where?: SystemMetricsWhereInput
  }

  /**
   * SystemMetrics upsert
   */
  export type SystemMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemMetrics to update in case it exists.
     */
    where: SystemMetricsWhereUniqueInput
    /**
     * In case the SystemMetrics found by the `where` argument doesn't exist, create a new SystemMetrics with this data.
     */
    create: XOR<SystemMetricsCreateInput, SystemMetricsUncheckedCreateInput>
    /**
     * In case the SystemMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemMetricsUpdateInput, SystemMetricsUncheckedUpdateInput>
  }

  /**
   * SystemMetrics delete
   */
  export type SystemMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter which SystemMetrics to delete.
     */
    where: SystemMetricsWhereUniqueInput
  }

  /**
   * SystemMetrics deleteMany
   */
  export type SystemMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMetrics to delete
     */
    where?: SystemMetricsWhereInput
  }

  /**
   * SystemMetrics without action
   */
  export type SystemMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
  }


  /**
   * Model DimDateRange
   */

  export type AggregateDimDateRange = {
    _count: DimDateRangeCountAggregateOutputType | null
    _avg: DimDateRangeAvgAggregateOutputType | null
    _sum: DimDateRangeSumAggregateOutputType | null
    _min: DimDateRangeMinAggregateOutputType | null
    _max: DimDateRangeMaxAggregateOutputType | null
  }

  export type DimDateRangeAvgAggregateOutputType = {
    id: number | null
  }

  export type DimDateRangeSumAggregateOutputType = {
    id: number | null
  }

  export type DimDateRangeMinAggregateOutputType = {
    id: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type DimDateRangeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type DimDateRangeCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    _all: number
  }


  export type DimDateRangeAvgAggregateInputType = {
    id?: true
  }

  export type DimDateRangeSumAggregateInputType = {
    id?: true
  }

  export type DimDateRangeMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
  }

  export type DimDateRangeMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
  }

  export type DimDateRangeCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type DimDateRangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimDateRange to aggregate.
     */
    where?: DimDateRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimDateRanges to fetch.
     */
    orderBy?: DimDateRangeOrderByWithRelationInput | DimDateRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DimDateRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimDateRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimDateRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DimDateRanges
    **/
    _count?: true | DimDateRangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DimDateRangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DimDateRangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DimDateRangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DimDateRangeMaxAggregateInputType
  }

  export type GetDimDateRangeAggregateType<T extends DimDateRangeAggregateArgs> = {
        [P in keyof T & keyof AggregateDimDateRange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimDateRange[P]>
      : GetScalarType<T[P], AggregateDimDateRange[P]>
  }




  export type DimDateRangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DimDateRangeWhereInput
    orderBy?: DimDateRangeOrderByWithAggregationInput | DimDateRangeOrderByWithAggregationInput[]
    by: DimDateRangeScalarFieldEnum[] | DimDateRangeScalarFieldEnum
    having?: DimDateRangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimDateRangeCountAggregateInputType | true
    _avg?: DimDateRangeAvgAggregateInputType
    _sum?: DimDateRangeSumAggregateInputType
    _min?: DimDateRangeMinAggregateInputType
    _max?: DimDateRangeMaxAggregateInputType
  }

  export type DimDateRangeGroupByOutputType = {
    id: number
    name: string
    startDate: Date
    endDate: Date
    _count: DimDateRangeCountAggregateOutputType | null
    _avg: DimDateRangeAvgAggregateOutputType | null
    _sum: DimDateRangeSumAggregateOutputType | null
    _min: DimDateRangeMinAggregateOutputType | null
    _max: DimDateRangeMaxAggregateOutputType | null
  }

  type GetDimDateRangeGroupByPayload<T extends DimDateRangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DimDateRangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DimDateRangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimDateRangeGroupByOutputType[P]>
            : GetScalarType<T[P], DimDateRangeGroupByOutputType[P]>
        }
      >
    >


  export type DimDateRangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
  }, ExtArgs["result"]["dimDateRange"]>

  export type DimDateRangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
  }, ExtArgs["result"]["dimDateRange"]>

  export type DimDateRangeSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
  }


  export type $DimDateRangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DimDateRange"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      startDate: Date
      endDate: Date
    }, ExtArgs["result"]["dimDateRange"]>
    composites: {}
  }

  type DimDateRangeGetPayload<S extends boolean | null | undefined | DimDateRangeDefaultArgs> = $Result.GetResult<Prisma.$DimDateRangePayload, S>

  type DimDateRangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DimDateRangeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DimDateRangeCountAggregateInputType | true
    }

  export interface DimDateRangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DimDateRange'], meta: { name: 'DimDateRange' } }
    /**
     * Find zero or one DimDateRange that matches the filter.
     * @param {DimDateRangeFindUniqueArgs} args - Arguments to find a DimDateRange
     * @example
     * // Get one DimDateRange
     * const dimDateRange = await prisma.dimDateRange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimDateRangeFindUniqueArgs>(args: SelectSubset<T, DimDateRangeFindUniqueArgs<ExtArgs>>): Prisma__DimDateRangeClient<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DimDateRange that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DimDateRangeFindUniqueOrThrowArgs} args - Arguments to find a DimDateRange
     * @example
     * // Get one DimDateRange
     * const dimDateRange = await prisma.dimDateRange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimDateRangeFindUniqueOrThrowArgs>(args: SelectSubset<T, DimDateRangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DimDateRangeClient<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DimDateRange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateRangeFindFirstArgs} args - Arguments to find a DimDateRange
     * @example
     * // Get one DimDateRange
     * const dimDateRange = await prisma.dimDateRange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimDateRangeFindFirstArgs>(args?: SelectSubset<T, DimDateRangeFindFirstArgs<ExtArgs>>): Prisma__DimDateRangeClient<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DimDateRange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateRangeFindFirstOrThrowArgs} args - Arguments to find a DimDateRange
     * @example
     * // Get one DimDateRange
     * const dimDateRange = await prisma.dimDateRange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimDateRangeFindFirstOrThrowArgs>(args?: SelectSubset<T, DimDateRangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DimDateRangeClient<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DimDateRanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateRangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimDateRanges
     * const dimDateRanges = await prisma.dimDateRange.findMany()
     * 
     * // Get first 10 DimDateRanges
     * const dimDateRanges = await prisma.dimDateRange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dimDateRangeWithIdOnly = await prisma.dimDateRange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DimDateRangeFindManyArgs>(args?: SelectSubset<T, DimDateRangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DimDateRange.
     * @param {DimDateRangeCreateArgs} args - Arguments to create a DimDateRange.
     * @example
     * // Create one DimDateRange
     * const DimDateRange = await prisma.dimDateRange.create({
     *   data: {
     *     // ... data to create a DimDateRange
     *   }
     * })
     * 
     */
    create<T extends DimDateRangeCreateArgs>(args: SelectSubset<T, DimDateRangeCreateArgs<ExtArgs>>): Prisma__DimDateRangeClient<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DimDateRanges.
     * @param {DimDateRangeCreateManyArgs} args - Arguments to create many DimDateRanges.
     * @example
     * // Create many DimDateRanges
     * const dimDateRange = await prisma.dimDateRange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DimDateRangeCreateManyArgs>(args?: SelectSubset<T, DimDateRangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimDateRanges and returns the data saved in the database.
     * @param {DimDateRangeCreateManyAndReturnArgs} args - Arguments to create many DimDateRanges.
     * @example
     * // Create many DimDateRanges
     * const dimDateRange = await prisma.dimDateRange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DimDateRanges and only return the `id`
     * const dimDateRangeWithIdOnly = await prisma.dimDateRange.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DimDateRangeCreateManyAndReturnArgs>(args?: SelectSubset<T, DimDateRangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DimDateRange.
     * @param {DimDateRangeDeleteArgs} args - Arguments to delete one DimDateRange.
     * @example
     * // Delete one DimDateRange
     * const DimDateRange = await prisma.dimDateRange.delete({
     *   where: {
     *     // ... filter to delete one DimDateRange
     *   }
     * })
     * 
     */
    delete<T extends DimDateRangeDeleteArgs>(args: SelectSubset<T, DimDateRangeDeleteArgs<ExtArgs>>): Prisma__DimDateRangeClient<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DimDateRange.
     * @param {DimDateRangeUpdateArgs} args - Arguments to update one DimDateRange.
     * @example
     * // Update one DimDateRange
     * const dimDateRange = await prisma.dimDateRange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DimDateRangeUpdateArgs>(args: SelectSubset<T, DimDateRangeUpdateArgs<ExtArgs>>): Prisma__DimDateRangeClient<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DimDateRanges.
     * @param {DimDateRangeDeleteManyArgs} args - Arguments to filter DimDateRanges to delete.
     * @example
     * // Delete a few DimDateRanges
     * const { count } = await prisma.dimDateRange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DimDateRangeDeleteManyArgs>(args?: SelectSubset<T, DimDateRangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimDateRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateRangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimDateRanges
     * const dimDateRange = await prisma.dimDateRange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DimDateRangeUpdateManyArgs>(args: SelectSubset<T, DimDateRangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DimDateRange.
     * @param {DimDateRangeUpsertArgs} args - Arguments to update or create a DimDateRange.
     * @example
     * // Update or create a DimDateRange
     * const dimDateRange = await prisma.dimDateRange.upsert({
     *   create: {
     *     // ... data to create a DimDateRange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimDateRange we want to update
     *   }
     * })
     */
    upsert<T extends DimDateRangeUpsertArgs>(args: SelectSubset<T, DimDateRangeUpsertArgs<ExtArgs>>): Prisma__DimDateRangeClient<$Result.GetResult<Prisma.$DimDateRangePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DimDateRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateRangeCountArgs} args - Arguments to filter DimDateRanges to count.
     * @example
     * // Count the number of DimDateRanges
     * const count = await prisma.dimDateRange.count({
     *   where: {
     *     // ... the filter for the DimDateRanges we want to count
     *   }
     * })
    **/
    count<T extends DimDateRangeCountArgs>(
      args?: Subset<T, DimDateRangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimDateRangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimDateRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateRangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DimDateRangeAggregateArgs>(args: Subset<T, DimDateRangeAggregateArgs>): Prisma.PrismaPromise<GetDimDateRangeAggregateType<T>>

    /**
     * Group by DimDateRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateRangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DimDateRangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimDateRangeGroupByArgs['orderBy'] }
        : { orderBy?: DimDateRangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DimDateRangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDimDateRangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DimDateRange model
   */
  readonly fields: DimDateRangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimDateRange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimDateRangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DimDateRange model
   */ 
  interface DimDateRangeFieldRefs {
    readonly id: FieldRef<"DimDateRange", 'Int'>
    readonly name: FieldRef<"DimDateRange", 'String'>
    readonly startDate: FieldRef<"DimDateRange", 'DateTime'>
    readonly endDate: FieldRef<"DimDateRange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DimDateRange findUnique
   */
  export type DimDateRangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * Filter, which DimDateRange to fetch.
     */
    where: DimDateRangeWhereUniqueInput
  }

  /**
   * DimDateRange findUniqueOrThrow
   */
  export type DimDateRangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * Filter, which DimDateRange to fetch.
     */
    where: DimDateRangeWhereUniqueInput
  }

  /**
   * DimDateRange findFirst
   */
  export type DimDateRangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * Filter, which DimDateRange to fetch.
     */
    where?: DimDateRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimDateRanges to fetch.
     */
    orderBy?: DimDateRangeOrderByWithRelationInput | DimDateRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimDateRanges.
     */
    cursor?: DimDateRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimDateRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimDateRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimDateRanges.
     */
    distinct?: DimDateRangeScalarFieldEnum | DimDateRangeScalarFieldEnum[]
  }

  /**
   * DimDateRange findFirstOrThrow
   */
  export type DimDateRangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * Filter, which DimDateRange to fetch.
     */
    where?: DimDateRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimDateRanges to fetch.
     */
    orderBy?: DimDateRangeOrderByWithRelationInput | DimDateRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DimDateRanges.
     */
    cursor?: DimDateRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimDateRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimDateRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DimDateRanges.
     */
    distinct?: DimDateRangeScalarFieldEnum | DimDateRangeScalarFieldEnum[]
  }

  /**
   * DimDateRange findMany
   */
  export type DimDateRangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * Filter, which DimDateRanges to fetch.
     */
    where?: DimDateRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DimDateRanges to fetch.
     */
    orderBy?: DimDateRangeOrderByWithRelationInput | DimDateRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DimDateRanges.
     */
    cursor?: DimDateRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DimDateRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DimDateRanges.
     */
    skip?: number
    distinct?: DimDateRangeScalarFieldEnum | DimDateRangeScalarFieldEnum[]
  }

  /**
   * DimDateRange create
   */
  export type DimDateRangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * The data needed to create a DimDateRange.
     */
    data: XOR<DimDateRangeCreateInput, DimDateRangeUncheckedCreateInput>
  }

  /**
   * DimDateRange createMany
   */
  export type DimDateRangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DimDateRanges.
     */
    data: DimDateRangeCreateManyInput | DimDateRangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimDateRange createManyAndReturn
   */
  export type DimDateRangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DimDateRanges.
     */
    data: DimDateRangeCreateManyInput | DimDateRangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimDateRange update
   */
  export type DimDateRangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * The data needed to update a DimDateRange.
     */
    data: XOR<DimDateRangeUpdateInput, DimDateRangeUncheckedUpdateInput>
    /**
     * Choose, which DimDateRange to update.
     */
    where: DimDateRangeWhereUniqueInput
  }

  /**
   * DimDateRange updateMany
   */
  export type DimDateRangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DimDateRanges.
     */
    data: XOR<DimDateRangeUpdateManyMutationInput, DimDateRangeUncheckedUpdateManyInput>
    /**
     * Filter which DimDateRanges to update
     */
    where?: DimDateRangeWhereInput
  }

  /**
   * DimDateRange upsert
   */
  export type DimDateRangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * The filter to search for the DimDateRange to update in case it exists.
     */
    where: DimDateRangeWhereUniqueInput
    /**
     * In case the DimDateRange found by the `where` argument doesn't exist, create a new DimDateRange with this data.
     */
    create: XOR<DimDateRangeCreateInput, DimDateRangeUncheckedCreateInput>
    /**
     * In case the DimDateRange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimDateRangeUpdateInput, DimDateRangeUncheckedUpdateInput>
  }

  /**
   * DimDateRange delete
   */
  export type DimDateRangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
    /**
     * Filter which DimDateRange to delete.
     */
    where: DimDateRangeWhereUniqueInput
  }

  /**
   * DimDateRange deleteMany
   */
  export type DimDateRangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DimDateRanges to delete
     */
    where?: DimDateRangeWhereInput
  }

  /**
   * DimDateRange without action
   */
  export type DimDateRangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DimDateRange
     */
    select?: DimDateRangeSelect<ExtArgs> | null
  }


  /**
   * Model OntologyTerm
   */

  export type AggregateOntologyTerm = {
    _count: OntologyTermCountAggregateOutputType | null
    _avg: OntologyTermAvgAggregateOutputType | null
    _sum: OntologyTermSumAggregateOutputType | null
    _min: OntologyTermMinAggregateOutputType | null
    _max: OntologyTermMaxAggregateOutputType | null
  }

  export type OntologyTermAvgAggregateOutputType = {
    priority: number | null
  }

  export type OntologyTermSumAggregateOutputType = {
    priority: number | null
  }

  export type OntologyTermMinAggregateOutputType = {
    term: string | null
    modelName: string | null
    fieldName: string | null
    priority: number | null
  }

  export type OntologyTermMaxAggregateOutputType = {
    term: string | null
    modelName: string | null
    fieldName: string | null
    priority: number | null
  }

  export type OntologyTermCountAggregateOutputType = {
    term: number
    modelName: number
    fieldName: number
    priority: number
    _all: number
  }


  export type OntologyTermAvgAggregateInputType = {
    priority?: true
  }

  export type OntologyTermSumAggregateInputType = {
    priority?: true
  }

  export type OntologyTermMinAggregateInputType = {
    term?: true
    modelName?: true
    fieldName?: true
    priority?: true
  }

  export type OntologyTermMaxAggregateInputType = {
    term?: true
    modelName?: true
    fieldName?: true
    priority?: true
  }

  export type OntologyTermCountAggregateInputType = {
    term?: true
    modelName?: true
    fieldName?: true
    priority?: true
    _all?: true
  }

  export type OntologyTermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OntologyTerm to aggregate.
     */
    where?: OntologyTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OntologyTerms to fetch.
     */
    orderBy?: OntologyTermOrderByWithRelationInput | OntologyTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OntologyTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OntologyTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OntologyTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OntologyTerms
    **/
    _count?: true | OntologyTermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OntologyTermAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OntologyTermSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OntologyTermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OntologyTermMaxAggregateInputType
  }

  export type GetOntologyTermAggregateType<T extends OntologyTermAggregateArgs> = {
        [P in keyof T & keyof AggregateOntologyTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOntologyTerm[P]>
      : GetScalarType<T[P], AggregateOntologyTerm[P]>
  }




  export type OntologyTermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OntologyTermWhereInput
    orderBy?: OntologyTermOrderByWithAggregationInput | OntologyTermOrderByWithAggregationInput[]
    by: OntologyTermScalarFieldEnum[] | OntologyTermScalarFieldEnum
    having?: OntologyTermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OntologyTermCountAggregateInputType | true
    _avg?: OntologyTermAvgAggregateInputType
    _sum?: OntologyTermSumAggregateInputType
    _min?: OntologyTermMinAggregateInputType
    _max?: OntologyTermMaxAggregateInputType
  }

  export type OntologyTermGroupByOutputType = {
    term: string
    modelName: string
    fieldName: string
    priority: number
    _count: OntologyTermCountAggregateOutputType | null
    _avg: OntologyTermAvgAggregateOutputType | null
    _sum: OntologyTermSumAggregateOutputType | null
    _min: OntologyTermMinAggregateOutputType | null
    _max: OntologyTermMaxAggregateOutputType | null
  }

  type GetOntologyTermGroupByPayload<T extends OntologyTermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OntologyTermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OntologyTermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OntologyTermGroupByOutputType[P]>
            : GetScalarType<T[P], OntologyTermGroupByOutputType[P]>
        }
      >
    >


  export type OntologyTermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    term?: boolean
    modelName?: boolean
    fieldName?: boolean
    priority?: boolean
  }, ExtArgs["result"]["ontologyTerm"]>

  export type OntologyTermSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    term?: boolean
    modelName?: boolean
    fieldName?: boolean
    priority?: boolean
  }, ExtArgs["result"]["ontologyTerm"]>

  export type OntologyTermSelectScalar = {
    term?: boolean
    modelName?: boolean
    fieldName?: boolean
    priority?: boolean
  }


  export type $OntologyTermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OntologyTerm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      term: string
      modelName: string
      fieldName: string
      priority: number
    }, ExtArgs["result"]["ontologyTerm"]>
    composites: {}
  }

  type OntologyTermGetPayload<S extends boolean | null | undefined | OntologyTermDefaultArgs> = $Result.GetResult<Prisma.$OntologyTermPayload, S>

  type OntologyTermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OntologyTermFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OntologyTermCountAggregateInputType | true
    }

  export interface OntologyTermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OntologyTerm'], meta: { name: 'OntologyTerm' } }
    /**
     * Find zero or one OntologyTerm that matches the filter.
     * @param {OntologyTermFindUniqueArgs} args - Arguments to find a OntologyTerm
     * @example
     * // Get one OntologyTerm
     * const ontologyTerm = await prisma.ontologyTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OntologyTermFindUniqueArgs>(args: SelectSubset<T, OntologyTermFindUniqueArgs<ExtArgs>>): Prisma__OntologyTermClient<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OntologyTerm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OntologyTermFindUniqueOrThrowArgs} args - Arguments to find a OntologyTerm
     * @example
     * // Get one OntologyTerm
     * const ontologyTerm = await prisma.ontologyTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OntologyTermFindUniqueOrThrowArgs>(args: SelectSubset<T, OntologyTermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OntologyTermClient<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OntologyTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OntologyTermFindFirstArgs} args - Arguments to find a OntologyTerm
     * @example
     * // Get one OntologyTerm
     * const ontologyTerm = await prisma.ontologyTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OntologyTermFindFirstArgs>(args?: SelectSubset<T, OntologyTermFindFirstArgs<ExtArgs>>): Prisma__OntologyTermClient<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OntologyTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OntologyTermFindFirstOrThrowArgs} args - Arguments to find a OntologyTerm
     * @example
     * // Get one OntologyTerm
     * const ontologyTerm = await prisma.ontologyTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OntologyTermFindFirstOrThrowArgs>(args?: SelectSubset<T, OntologyTermFindFirstOrThrowArgs<ExtArgs>>): Prisma__OntologyTermClient<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OntologyTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OntologyTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OntologyTerms
     * const ontologyTerms = await prisma.ontologyTerm.findMany()
     * 
     * // Get first 10 OntologyTerms
     * const ontologyTerms = await prisma.ontologyTerm.findMany({ take: 10 })
     * 
     * // Only select the `term`
     * const ontologyTermWithTermOnly = await prisma.ontologyTerm.findMany({ select: { term: true } })
     * 
     */
    findMany<T extends OntologyTermFindManyArgs>(args?: SelectSubset<T, OntologyTermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OntologyTerm.
     * @param {OntologyTermCreateArgs} args - Arguments to create a OntologyTerm.
     * @example
     * // Create one OntologyTerm
     * const OntologyTerm = await prisma.ontologyTerm.create({
     *   data: {
     *     // ... data to create a OntologyTerm
     *   }
     * })
     * 
     */
    create<T extends OntologyTermCreateArgs>(args: SelectSubset<T, OntologyTermCreateArgs<ExtArgs>>): Prisma__OntologyTermClient<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OntologyTerms.
     * @param {OntologyTermCreateManyArgs} args - Arguments to create many OntologyTerms.
     * @example
     * // Create many OntologyTerms
     * const ontologyTerm = await prisma.ontologyTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OntologyTermCreateManyArgs>(args?: SelectSubset<T, OntologyTermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OntologyTerms and returns the data saved in the database.
     * @param {OntologyTermCreateManyAndReturnArgs} args - Arguments to create many OntologyTerms.
     * @example
     * // Create many OntologyTerms
     * const ontologyTerm = await prisma.ontologyTerm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OntologyTerms and only return the `term`
     * const ontologyTermWithTermOnly = await prisma.ontologyTerm.createManyAndReturn({ 
     *   select: { term: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OntologyTermCreateManyAndReturnArgs>(args?: SelectSubset<T, OntologyTermCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OntologyTerm.
     * @param {OntologyTermDeleteArgs} args - Arguments to delete one OntologyTerm.
     * @example
     * // Delete one OntologyTerm
     * const OntologyTerm = await prisma.ontologyTerm.delete({
     *   where: {
     *     // ... filter to delete one OntologyTerm
     *   }
     * })
     * 
     */
    delete<T extends OntologyTermDeleteArgs>(args: SelectSubset<T, OntologyTermDeleteArgs<ExtArgs>>): Prisma__OntologyTermClient<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OntologyTerm.
     * @param {OntologyTermUpdateArgs} args - Arguments to update one OntologyTerm.
     * @example
     * // Update one OntologyTerm
     * const ontologyTerm = await prisma.ontologyTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OntologyTermUpdateArgs>(args: SelectSubset<T, OntologyTermUpdateArgs<ExtArgs>>): Prisma__OntologyTermClient<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OntologyTerms.
     * @param {OntologyTermDeleteManyArgs} args - Arguments to filter OntologyTerms to delete.
     * @example
     * // Delete a few OntologyTerms
     * const { count } = await prisma.ontologyTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OntologyTermDeleteManyArgs>(args?: SelectSubset<T, OntologyTermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OntologyTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OntologyTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OntologyTerms
     * const ontologyTerm = await prisma.ontologyTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OntologyTermUpdateManyArgs>(args: SelectSubset<T, OntologyTermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OntologyTerm.
     * @param {OntologyTermUpsertArgs} args - Arguments to update or create a OntologyTerm.
     * @example
     * // Update or create a OntologyTerm
     * const ontologyTerm = await prisma.ontologyTerm.upsert({
     *   create: {
     *     // ... data to create a OntologyTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OntologyTerm we want to update
     *   }
     * })
     */
    upsert<T extends OntologyTermUpsertArgs>(args: SelectSubset<T, OntologyTermUpsertArgs<ExtArgs>>): Prisma__OntologyTermClient<$Result.GetResult<Prisma.$OntologyTermPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OntologyTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OntologyTermCountArgs} args - Arguments to filter OntologyTerms to count.
     * @example
     * // Count the number of OntologyTerms
     * const count = await prisma.ontologyTerm.count({
     *   where: {
     *     // ... the filter for the OntologyTerms we want to count
     *   }
     * })
    **/
    count<T extends OntologyTermCountArgs>(
      args?: Subset<T, OntologyTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OntologyTermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OntologyTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OntologyTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OntologyTermAggregateArgs>(args: Subset<T, OntologyTermAggregateArgs>): Prisma.PrismaPromise<GetOntologyTermAggregateType<T>>

    /**
     * Group by OntologyTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OntologyTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OntologyTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OntologyTermGroupByArgs['orderBy'] }
        : { orderBy?: OntologyTermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OntologyTermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOntologyTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OntologyTerm model
   */
  readonly fields: OntologyTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OntologyTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OntologyTermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OntologyTerm model
   */ 
  interface OntologyTermFieldRefs {
    readonly term: FieldRef<"OntologyTerm", 'String'>
    readonly modelName: FieldRef<"OntologyTerm", 'String'>
    readonly fieldName: FieldRef<"OntologyTerm", 'String'>
    readonly priority: FieldRef<"OntologyTerm", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OntologyTerm findUnique
   */
  export type OntologyTermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * Filter, which OntologyTerm to fetch.
     */
    where: OntologyTermWhereUniqueInput
  }

  /**
   * OntologyTerm findUniqueOrThrow
   */
  export type OntologyTermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * Filter, which OntologyTerm to fetch.
     */
    where: OntologyTermWhereUniqueInput
  }

  /**
   * OntologyTerm findFirst
   */
  export type OntologyTermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * Filter, which OntologyTerm to fetch.
     */
    where?: OntologyTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OntologyTerms to fetch.
     */
    orderBy?: OntologyTermOrderByWithRelationInput | OntologyTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OntologyTerms.
     */
    cursor?: OntologyTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OntologyTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OntologyTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OntologyTerms.
     */
    distinct?: OntologyTermScalarFieldEnum | OntologyTermScalarFieldEnum[]
  }

  /**
   * OntologyTerm findFirstOrThrow
   */
  export type OntologyTermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * Filter, which OntologyTerm to fetch.
     */
    where?: OntologyTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OntologyTerms to fetch.
     */
    orderBy?: OntologyTermOrderByWithRelationInput | OntologyTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OntologyTerms.
     */
    cursor?: OntologyTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OntologyTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OntologyTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OntologyTerms.
     */
    distinct?: OntologyTermScalarFieldEnum | OntologyTermScalarFieldEnum[]
  }

  /**
   * OntologyTerm findMany
   */
  export type OntologyTermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * Filter, which OntologyTerms to fetch.
     */
    where?: OntologyTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OntologyTerms to fetch.
     */
    orderBy?: OntologyTermOrderByWithRelationInput | OntologyTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OntologyTerms.
     */
    cursor?: OntologyTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OntologyTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OntologyTerms.
     */
    skip?: number
    distinct?: OntologyTermScalarFieldEnum | OntologyTermScalarFieldEnum[]
  }

  /**
   * OntologyTerm create
   */
  export type OntologyTermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * The data needed to create a OntologyTerm.
     */
    data: XOR<OntologyTermCreateInput, OntologyTermUncheckedCreateInput>
  }

  /**
   * OntologyTerm createMany
   */
  export type OntologyTermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OntologyTerms.
     */
    data: OntologyTermCreateManyInput | OntologyTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OntologyTerm createManyAndReturn
   */
  export type OntologyTermCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OntologyTerms.
     */
    data: OntologyTermCreateManyInput | OntologyTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OntologyTerm update
   */
  export type OntologyTermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * The data needed to update a OntologyTerm.
     */
    data: XOR<OntologyTermUpdateInput, OntologyTermUncheckedUpdateInput>
    /**
     * Choose, which OntologyTerm to update.
     */
    where: OntologyTermWhereUniqueInput
  }

  /**
   * OntologyTerm updateMany
   */
  export type OntologyTermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OntologyTerms.
     */
    data: XOR<OntologyTermUpdateManyMutationInput, OntologyTermUncheckedUpdateManyInput>
    /**
     * Filter which OntologyTerms to update
     */
    where?: OntologyTermWhereInput
  }

  /**
   * OntologyTerm upsert
   */
  export type OntologyTermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * The filter to search for the OntologyTerm to update in case it exists.
     */
    where: OntologyTermWhereUniqueInput
    /**
     * In case the OntologyTerm found by the `where` argument doesn't exist, create a new OntologyTerm with this data.
     */
    create: XOR<OntologyTermCreateInput, OntologyTermUncheckedCreateInput>
    /**
     * In case the OntologyTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OntologyTermUpdateInput, OntologyTermUncheckedUpdateInput>
  }

  /**
   * OntologyTerm delete
   */
  export type OntologyTermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
    /**
     * Filter which OntologyTerm to delete.
     */
    where: OntologyTermWhereUniqueInput
  }

  /**
   * OntologyTerm deleteMany
   */
  export type OntologyTermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OntologyTerms to delete
     */
    where?: OntologyTermWhereInput
  }

  /**
   * OntologyTerm without action
   */
  export type OntologyTermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OntologyTerm
     */
    select?: OntologyTermSelect<ExtArgs> | null
  }


  /**
   * Model ViewOeeDaily
   */

  export type AggregateViewOeeDaily = {
    _count: ViewOeeDailyCountAggregateOutputType | null
    _avg: ViewOeeDailyAvgAggregateOutputType | null
    _sum: ViewOeeDailySumAggregateOutputType | null
    _min: ViewOeeDailyMinAggregateOutputType | null
    _max: ViewOeeDailyMaxAggregateOutputType | null
  }

  export type ViewOeeDailyAvgAggregateOutputType = {
    shiftId: number | null
    equipmentId: number | null
    availability: number | null
    performance: number | null
    quality: number | null
    oee: number | null
  }

  export type ViewOeeDailySumAggregateOutputType = {
    shiftId: number | null
    equipmentId: number | null
    availability: number | null
    performance: number | null
    quality: number | null
    oee: number | null
  }

  export type ViewOeeDailyMinAggregateOutputType = {
    dateId: Date | null
    shiftId: number | null
    equipmentId: number | null
    availability: number | null
    performance: number | null
    quality: number | null
    oee: number | null
  }

  export type ViewOeeDailyMaxAggregateOutputType = {
    dateId: Date | null
    shiftId: number | null
    equipmentId: number | null
    availability: number | null
    performance: number | null
    quality: number | null
    oee: number | null
  }

  export type ViewOeeDailyCountAggregateOutputType = {
    dateId: number
    shiftId: number
    equipmentId: number
    availability: number
    performance: number
    quality: number
    oee: number
    _all: number
  }


  export type ViewOeeDailyAvgAggregateInputType = {
    shiftId?: true
    equipmentId?: true
    availability?: true
    performance?: true
    quality?: true
    oee?: true
  }

  export type ViewOeeDailySumAggregateInputType = {
    shiftId?: true
    equipmentId?: true
    availability?: true
    performance?: true
    quality?: true
    oee?: true
  }

  export type ViewOeeDailyMinAggregateInputType = {
    dateId?: true
    shiftId?: true
    equipmentId?: true
    availability?: true
    performance?: true
    quality?: true
    oee?: true
  }

  export type ViewOeeDailyMaxAggregateInputType = {
    dateId?: true
    shiftId?: true
    equipmentId?: true
    availability?: true
    performance?: true
    quality?: true
    oee?: true
  }

  export type ViewOeeDailyCountAggregateInputType = {
    dateId?: true
    shiftId?: true
    equipmentId?: true
    availability?: true
    performance?: true
    quality?: true
    oee?: true
    _all?: true
  }

  export type ViewOeeDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewOeeDaily to aggregate.
     */
    where?: ViewOeeDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewOeeDailies to fetch.
     */
    orderBy?: ViewOeeDailyOrderByWithRelationInput | ViewOeeDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewOeeDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewOeeDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewOeeDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewOeeDailies
    **/
    _count?: true | ViewOeeDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewOeeDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewOeeDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewOeeDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewOeeDailyMaxAggregateInputType
  }

  export type GetViewOeeDailyAggregateType<T extends ViewOeeDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateViewOeeDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewOeeDaily[P]>
      : GetScalarType<T[P], AggregateViewOeeDaily[P]>
  }




  export type ViewOeeDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewOeeDailyWhereInput
    orderBy?: ViewOeeDailyOrderByWithAggregationInput | ViewOeeDailyOrderByWithAggregationInput[]
    by: ViewOeeDailyScalarFieldEnum[] | ViewOeeDailyScalarFieldEnum
    having?: ViewOeeDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewOeeDailyCountAggregateInputType | true
    _avg?: ViewOeeDailyAvgAggregateInputType
    _sum?: ViewOeeDailySumAggregateInputType
    _min?: ViewOeeDailyMinAggregateInputType
    _max?: ViewOeeDailyMaxAggregateInputType
  }

  export type ViewOeeDailyGroupByOutputType = {
    dateId: Date
    shiftId: number
    equipmentId: number
    availability: number
    performance: number
    quality: number
    oee: number
    _count: ViewOeeDailyCountAggregateOutputType | null
    _avg: ViewOeeDailyAvgAggregateOutputType | null
    _sum: ViewOeeDailySumAggregateOutputType | null
    _min: ViewOeeDailyMinAggregateOutputType | null
    _max: ViewOeeDailyMaxAggregateOutputType | null
  }

  type GetViewOeeDailyGroupByPayload<T extends ViewOeeDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewOeeDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewOeeDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewOeeDailyGroupByOutputType[P]>
            : GetScalarType<T[P], ViewOeeDailyGroupByOutputType[P]>
        }
      >
    >


  export type ViewOeeDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dateId?: boolean
    shiftId?: boolean
    equipmentId?: boolean
    availability?: boolean
    performance?: boolean
    quality?: boolean
    oee?: boolean
  }, ExtArgs["result"]["viewOeeDaily"]>

  export type ViewOeeDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dateId?: boolean
    shiftId?: boolean
    equipmentId?: boolean
    availability?: boolean
    performance?: boolean
    quality?: boolean
    oee?: boolean
  }, ExtArgs["result"]["viewOeeDaily"]>

  export type ViewOeeDailySelectScalar = {
    dateId?: boolean
    shiftId?: boolean
    equipmentId?: boolean
    availability?: boolean
    performance?: boolean
    quality?: boolean
    oee?: boolean
  }


  export type $ViewOeeDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewOeeDaily"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      dateId: Date
      shiftId: number
      equipmentId: number
      availability: number
      performance: number
      quality: number
      oee: number
    }, ExtArgs["result"]["viewOeeDaily"]>
    composites: {}
  }

  type ViewOeeDailyGetPayload<S extends boolean | null | undefined | ViewOeeDailyDefaultArgs> = $Result.GetResult<Prisma.$ViewOeeDailyPayload, S>

  type ViewOeeDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViewOeeDailyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViewOeeDailyCountAggregateInputType | true
    }

  export interface ViewOeeDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewOeeDaily'], meta: { name: 'ViewOeeDaily' } }
    /**
     * Find zero or one ViewOeeDaily that matches the filter.
     * @param {ViewOeeDailyFindUniqueArgs} args - Arguments to find a ViewOeeDaily
     * @example
     * // Get one ViewOeeDaily
     * const viewOeeDaily = await prisma.viewOeeDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewOeeDailyFindUniqueArgs>(args: SelectSubset<T, ViewOeeDailyFindUniqueArgs<ExtArgs>>): Prisma__ViewOeeDailyClient<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ViewOeeDaily that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViewOeeDailyFindUniqueOrThrowArgs} args - Arguments to find a ViewOeeDaily
     * @example
     * // Get one ViewOeeDaily
     * const viewOeeDaily = await prisma.viewOeeDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewOeeDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewOeeDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewOeeDailyClient<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ViewOeeDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewOeeDailyFindFirstArgs} args - Arguments to find a ViewOeeDaily
     * @example
     * // Get one ViewOeeDaily
     * const viewOeeDaily = await prisma.viewOeeDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewOeeDailyFindFirstArgs>(args?: SelectSubset<T, ViewOeeDailyFindFirstArgs<ExtArgs>>): Prisma__ViewOeeDailyClient<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ViewOeeDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewOeeDailyFindFirstOrThrowArgs} args - Arguments to find a ViewOeeDaily
     * @example
     * // Get one ViewOeeDaily
     * const viewOeeDaily = await prisma.viewOeeDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewOeeDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewOeeDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewOeeDailyClient<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ViewOeeDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewOeeDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewOeeDailies
     * const viewOeeDailies = await prisma.viewOeeDaily.findMany()
     * 
     * // Get first 10 ViewOeeDailies
     * const viewOeeDailies = await prisma.viewOeeDaily.findMany({ take: 10 })
     * 
     * // Only select the `dateId`
     * const viewOeeDailyWithDateIdOnly = await prisma.viewOeeDaily.findMany({ select: { dateId: true } })
     * 
     */
    findMany<T extends ViewOeeDailyFindManyArgs>(args?: SelectSubset<T, ViewOeeDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ViewOeeDaily.
     * @param {ViewOeeDailyCreateArgs} args - Arguments to create a ViewOeeDaily.
     * @example
     * // Create one ViewOeeDaily
     * const ViewOeeDaily = await prisma.viewOeeDaily.create({
     *   data: {
     *     // ... data to create a ViewOeeDaily
     *   }
     * })
     * 
     */
    create<T extends ViewOeeDailyCreateArgs>(args: SelectSubset<T, ViewOeeDailyCreateArgs<ExtArgs>>): Prisma__ViewOeeDailyClient<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ViewOeeDailies.
     * @param {ViewOeeDailyCreateManyArgs} args - Arguments to create many ViewOeeDailies.
     * @example
     * // Create many ViewOeeDailies
     * const viewOeeDaily = await prisma.viewOeeDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewOeeDailyCreateManyArgs>(args?: SelectSubset<T, ViewOeeDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewOeeDailies and returns the data saved in the database.
     * @param {ViewOeeDailyCreateManyAndReturnArgs} args - Arguments to create many ViewOeeDailies.
     * @example
     * // Create many ViewOeeDailies
     * const viewOeeDaily = await prisma.viewOeeDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewOeeDailies and only return the `dateId`
     * const viewOeeDailyWithDateIdOnly = await prisma.viewOeeDaily.createManyAndReturn({ 
     *   select: { dateId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewOeeDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewOeeDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ViewOeeDaily.
     * @param {ViewOeeDailyDeleteArgs} args - Arguments to delete one ViewOeeDaily.
     * @example
     * // Delete one ViewOeeDaily
     * const ViewOeeDaily = await prisma.viewOeeDaily.delete({
     *   where: {
     *     // ... filter to delete one ViewOeeDaily
     *   }
     * })
     * 
     */
    delete<T extends ViewOeeDailyDeleteArgs>(args: SelectSubset<T, ViewOeeDailyDeleteArgs<ExtArgs>>): Prisma__ViewOeeDailyClient<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ViewOeeDaily.
     * @param {ViewOeeDailyUpdateArgs} args - Arguments to update one ViewOeeDaily.
     * @example
     * // Update one ViewOeeDaily
     * const viewOeeDaily = await prisma.viewOeeDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewOeeDailyUpdateArgs>(args: SelectSubset<T, ViewOeeDailyUpdateArgs<ExtArgs>>): Prisma__ViewOeeDailyClient<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ViewOeeDailies.
     * @param {ViewOeeDailyDeleteManyArgs} args - Arguments to filter ViewOeeDailies to delete.
     * @example
     * // Delete a few ViewOeeDailies
     * const { count } = await prisma.viewOeeDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewOeeDailyDeleteManyArgs>(args?: SelectSubset<T, ViewOeeDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewOeeDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewOeeDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewOeeDailies
     * const viewOeeDaily = await prisma.viewOeeDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewOeeDailyUpdateManyArgs>(args: SelectSubset<T, ViewOeeDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViewOeeDaily.
     * @param {ViewOeeDailyUpsertArgs} args - Arguments to update or create a ViewOeeDaily.
     * @example
     * // Update or create a ViewOeeDaily
     * const viewOeeDaily = await prisma.viewOeeDaily.upsert({
     *   create: {
     *     // ... data to create a ViewOeeDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewOeeDaily we want to update
     *   }
     * })
     */
    upsert<T extends ViewOeeDailyUpsertArgs>(args: SelectSubset<T, ViewOeeDailyUpsertArgs<ExtArgs>>): Prisma__ViewOeeDailyClient<$Result.GetResult<Prisma.$ViewOeeDailyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ViewOeeDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewOeeDailyCountArgs} args - Arguments to filter ViewOeeDailies to count.
     * @example
     * // Count the number of ViewOeeDailies
     * const count = await prisma.viewOeeDaily.count({
     *   where: {
     *     // ... the filter for the ViewOeeDailies we want to count
     *   }
     * })
    **/
    count<T extends ViewOeeDailyCountArgs>(
      args?: Subset<T, ViewOeeDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewOeeDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewOeeDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewOeeDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewOeeDailyAggregateArgs>(args: Subset<T, ViewOeeDailyAggregateArgs>): Prisma.PrismaPromise<GetViewOeeDailyAggregateType<T>>

    /**
     * Group by ViewOeeDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewOeeDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewOeeDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewOeeDailyGroupByArgs['orderBy'] }
        : { orderBy?: ViewOeeDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewOeeDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewOeeDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewOeeDaily model
   */
  readonly fields: ViewOeeDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewOeeDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewOeeDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewOeeDaily model
   */ 
  interface ViewOeeDailyFieldRefs {
    readonly dateId: FieldRef<"ViewOeeDaily", 'DateTime'>
    readonly shiftId: FieldRef<"ViewOeeDaily", 'Int'>
    readonly equipmentId: FieldRef<"ViewOeeDaily", 'Int'>
    readonly availability: FieldRef<"ViewOeeDaily", 'Float'>
    readonly performance: FieldRef<"ViewOeeDaily", 'Float'>
    readonly quality: FieldRef<"ViewOeeDaily", 'Float'>
    readonly oee: FieldRef<"ViewOeeDaily", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ViewOeeDaily findUnique
   */
  export type ViewOeeDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * Filter, which ViewOeeDaily to fetch.
     */
    where: ViewOeeDailyWhereUniqueInput
  }

  /**
   * ViewOeeDaily findUniqueOrThrow
   */
  export type ViewOeeDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * Filter, which ViewOeeDaily to fetch.
     */
    where: ViewOeeDailyWhereUniqueInput
  }

  /**
   * ViewOeeDaily findFirst
   */
  export type ViewOeeDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * Filter, which ViewOeeDaily to fetch.
     */
    where?: ViewOeeDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewOeeDailies to fetch.
     */
    orderBy?: ViewOeeDailyOrderByWithRelationInput | ViewOeeDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewOeeDailies.
     */
    cursor?: ViewOeeDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewOeeDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewOeeDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewOeeDailies.
     */
    distinct?: ViewOeeDailyScalarFieldEnum | ViewOeeDailyScalarFieldEnum[]
  }

  /**
   * ViewOeeDaily findFirstOrThrow
   */
  export type ViewOeeDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * Filter, which ViewOeeDaily to fetch.
     */
    where?: ViewOeeDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewOeeDailies to fetch.
     */
    orderBy?: ViewOeeDailyOrderByWithRelationInput | ViewOeeDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewOeeDailies.
     */
    cursor?: ViewOeeDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewOeeDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewOeeDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewOeeDailies.
     */
    distinct?: ViewOeeDailyScalarFieldEnum | ViewOeeDailyScalarFieldEnum[]
  }

  /**
   * ViewOeeDaily findMany
   */
  export type ViewOeeDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * Filter, which ViewOeeDailies to fetch.
     */
    where?: ViewOeeDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewOeeDailies to fetch.
     */
    orderBy?: ViewOeeDailyOrderByWithRelationInput | ViewOeeDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewOeeDailies.
     */
    cursor?: ViewOeeDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewOeeDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewOeeDailies.
     */
    skip?: number
    distinct?: ViewOeeDailyScalarFieldEnum | ViewOeeDailyScalarFieldEnum[]
  }

  /**
   * ViewOeeDaily create
   */
  export type ViewOeeDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * The data needed to create a ViewOeeDaily.
     */
    data: XOR<ViewOeeDailyCreateInput, ViewOeeDailyUncheckedCreateInput>
  }

  /**
   * ViewOeeDaily createMany
   */
  export type ViewOeeDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewOeeDailies.
     */
    data: ViewOeeDailyCreateManyInput | ViewOeeDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewOeeDaily createManyAndReturn
   */
  export type ViewOeeDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ViewOeeDailies.
     */
    data: ViewOeeDailyCreateManyInput | ViewOeeDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewOeeDaily update
   */
  export type ViewOeeDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * The data needed to update a ViewOeeDaily.
     */
    data: XOR<ViewOeeDailyUpdateInput, ViewOeeDailyUncheckedUpdateInput>
    /**
     * Choose, which ViewOeeDaily to update.
     */
    where: ViewOeeDailyWhereUniqueInput
  }

  /**
   * ViewOeeDaily updateMany
   */
  export type ViewOeeDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewOeeDailies.
     */
    data: XOR<ViewOeeDailyUpdateManyMutationInput, ViewOeeDailyUncheckedUpdateManyInput>
    /**
     * Filter which ViewOeeDailies to update
     */
    where?: ViewOeeDailyWhereInput
  }

  /**
   * ViewOeeDaily upsert
   */
  export type ViewOeeDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * The filter to search for the ViewOeeDaily to update in case it exists.
     */
    where: ViewOeeDailyWhereUniqueInput
    /**
     * In case the ViewOeeDaily found by the `where` argument doesn't exist, create a new ViewOeeDaily with this data.
     */
    create: XOR<ViewOeeDailyCreateInput, ViewOeeDailyUncheckedCreateInput>
    /**
     * In case the ViewOeeDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewOeeDailyUpdateInput, ViewOeeDailyUncheckedUpdateInput>
  }

  /**
   * ViewOeeDaily delete
   */
  export type ViewOeeDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
    /**
     * Filter which ViewOeeDaily to delete.
     */
    where: ViewOeeDailyWhereUniqueInput
  }

  /**
   * ViewOeeDaily deleteMany
   */
  export type ViewOeeDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewOeeDailies to delete
     */
    where?: ViewOeeDailyWhereInput
  }

  /**
   * ViewOeeDaily without action
   */
  export type ViewOeeDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewOeeDaily
     */
    select?: ViewOeeDailySelect<ExtArgs> | null
  }


  /**
   * Model ViewReliabilitySummary
   */

  export type AggregateViewReliabilitySummary = {
    _count: ViewReliabilitySummaryCountAggregateOutputType | null
    _avg: ViewReliabilitySummaryAvgAggregateOutputType | null
    _sum: ViewReliabilitySummarySumAggregateOutputType | null
    _min: ViewReliabilitySummaryMinAggregateOutputType | null
    _max: ViewReliabilitySummaryMaxAggregateOutputType | null
  }

  export type ViewReliabilitySummaryAvgAggregateOutputType = {
    equipmentId: number | null
    mtbfHours: number | null
    mttrHours: number | null
    failureCount: number | null
  }

  export type ViewReliabilitySummarySumAggregateOutputType = {
    equipmentId: number | null
    mtbfHours: number | null
    mttrHours: number | null
    failureCount: number | null
  }

  export type ViewReliabilitySummaryMinAggregateOutputType = {
    equipmentId: number | null
    equipmentCode: string | null
    equipmentName: string | null
    mtbfHours: number | null
    mttrHours: number | null
    failureCount: number | null
  }

  export type ViewReliabilitySummaryMaxAggregateOutputType = {
    equipmentId: number | null
    equipmentCode: string | null
    equipmentName: string | null
    mtbfHours: number | null
    mttrHours: number | null
    failureCount: number | null
  }

  export type ViewReliabilitySummaryCountAggregateOutputType = {
    equipmentId: number
    equipmentCode: number
    equipmentName: number
    mtbfHours: number
    mttrHours: number
    failureCount: number
    _all: number
  }


  export type ViewReliabilitySummaryAvgAggregateInputType = {
    equipmentId?: true
    mtbfHours?: true
    mttrHours?: true
    failureCount?: true
  }

  export type ViewReliabilitySummarySumAggregateInputType = {
    equipmentId?: true
    mtbfHours?: true
    mttrHours?: true
    failureCount?: true
  }

  export type ViewReliabilitySummaryMinAggregateInputType = {
    equipmentId?: true
    equipmentCode?: true
    equipmentName?: true
    mtbfHours?: true
    mttrHours?: true
    failureCount?: true
  }

  export type ViewReliabilitySummaryMaxAggregateInputType = {
    equipmentId?: true
    equipmentCode?: true
    equipmentName?: true
    mtbfHours?: true
    mttrHours?: true
    failureCount?: true
  }

  export type ViewReliabilitySummaryCountAggregateInputType = {
    equipmentId?: true
    equipmentCode?: true
    equipmentName?: true
    mtbfHours?: true
    mttrHours?: true
    failureCount?: true
    _all?: true
  }

  export type ViewReliabilitySummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewReliabilitySummary to aggregate.
     */
    where?: ViewReliabilitySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewReliabilitySummaries to fetch.
     */
    orderBy?: ViewReliabilitySummaryOrderByWithRelationInput | ViewReliabilitySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewReliabilitySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewReliabilitySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewReliabilitySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewReliabilitySummaries
    **/
    _count?: true | ViewReliabilitySummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewReliabilitySummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewReliabilitySummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewReliabilitySummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewReliabilitySummaryMaxAggregateInputType
  }

  export type GetViewReliabilitySummaryAggregateType<T extends ViewReliabilitySummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateViewReliabilitySummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewReliabilitySummary[P]>
      : GetScalarType<T[P], AggregateViewReliabilitySummary[P]>
  }




  export type ViewReliabilitySummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewReliabilitySummaryWhereInput
    orderBy?: ViewReliabilitySummaryOrderByWithAggregationInput | ViewReliabilitySummaryOrderByWithAggregationInput[]
    by: ViewReliabilitySummaryScalarFieldEnum[] | ViewReliabilitySummaryScalarFieldEnum
    having?: ViewReliabilitySummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewReliabilitySummaryCountAggregateInputType | true
    _avg?: ViewReliabilitySummaryAvgAggregateInputType
    _sum?: ViewReliabilitySummarySumAggregateInputType
    _min?: ViewReliabilitySummaryMinAggregateInputType
    _max?: ViewReliabilitySummaryMaxAggregateInputType
  }

  export type ViewReliabilitySummaryGroupByOutputType = {
    equipmentId: number
    equipmentCode: string
    equipmentName: string
    mtbfHours: number
    mttrHours: number
    failureCount: number
    _count: ViewReliabilitySummaryCountAggregateOutputType | null
    _avg: ViewReliabilitySummaryAvgAggregateOutputType | null
    _sum: ViewReliabilitySummarySumAggregateOutputType | null
    _min: ViewReliabilitySummaryMinAggregateOutputType | null
    _max: ViewReliabilitySummaryMaxAggregateOutputType | null
  }

  type GetViewReliabilitySummaryGroupByPayload<T extends ViewReliabilitySummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewReliabilitySummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewReliabilitySummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewReliabilitySummaryGroupByOutputType[P]>
            : GetScalarType<T[P], ViewReliabilitySummaryGroupByOutputType[P]>
        }
      >
    >


  export type ViewReliabilitySummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipmentId?: boolean
    equipmentCode?: boolean
    equipmentName?: boolean
    mtbfHours?: boolean
    mttrHours?: boolean
    failureCount?: boolean
  }, ExtArgs["result"]["viewReliabilitySummary"]>

  export type ViewReliabilitySummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipmentId?: boolean
    equipmentCode?: boolean
    equipmentName?: boolean
    mtbfHours?: boolean
    mttrHours?: boolean
    failureCount?: boolean
  }, ExtArgs["result"]["viewReliabilitySummary"]>

  export type ViewReliabilitySummarySelectScalar = {
    equipmentId?: boolean
    equipmentCode?: boolean
    equipmentName?: boolean
    mtbfHours?: boolean
    mttrHours?: boolean
    failureCount?: boolean
  }


  export type $ViewReliabilitySummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewReliabilitySummary"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      equipmentId: number
      equipmentCode: string
      equipmentName: string
      mtbfHours: number
      mttrHours: number
      failureCount: number
    }, ExtArgs["result"]["viewReliabilitySummary"]>
    composites: {}
  }

  type ViewReliabilitySummaryGetPayload<S extends boolean | null | undefined | ViewReliabilitySummaryDefaultArgs> = $Result.GetResult<Prisma.$ViewReliabilitySummaryPayload, S>

  type ViewReliabilitySummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViewReliabilitySummaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViewReliabilitySummaryCountAggregateInputType | true
    }

  export interface ViewReliabilitySummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewReliabilitySummary'], meta: { name: 'ViewReliabilitySummary' } }
    /**
     * Find zero or one ViewReliabilitySummary that matches the filter.
     * @param {ViewReliabilitySummaryFindUniqueArgs} args - Arguments to find a ViewReliabilitySummary
     * @example
     * // Get one ViewReliabilitySummary
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewReliabilitySummaryFindUniqueArgs>(args: SelectSubset<T, ViewReliabilitySummaryFindUniqueArgs<ExtArgs>>): Prisma__ViewReliabilitySummaryClient<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ViewReliabilitySummary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViewReliabilitySummaryFindUniqueOrThrowArgs} args - Arguments to find a ViewReliabilitySummary
     * @example
     * // Get one ViewReliabilitySummary
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewReliabilitySummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewReliabilitySummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewReliabilitySummaryClient<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ViewReliabilitySummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewReliabilitySummaryFindFirstArgs} args - Arguments to find a ViewReliabilitySummary
     * @example
     * // Get one ViewReliabilitySummary
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewReliabilitySummaryFindFirstArgs>(args?: SelectSubset<T, ViewReliabilitySummaryFindFirstArgs<ExtArgs>>): Prisma__ViewReliabilitySummaryClient<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ViewReliabilitySummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewReliabilitySummaryFindFirstOrThrowArgs} args - Arguments to find a ViewReliabilitySummary
     * @example
     * // Get one ViewReliabilitySummary
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewReliabilitySummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewReliabilitySummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewReliabilitySummaryClient<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ViewReliabilitySummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewReliabilitySummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewReliabilitySummaries
     * const viewReliabilitySummaries = await prisma.viewReliabilitySummary.findMany()
     * 
     * // Get first 10 ViewReliabilitySummaries
     * const viewReliabilitySummaries = await prisma.viewReliabilitySummary.findMany({ take: 10 })
     * 
     * // Only select the `equipmentId`
     * const viewReliabilitySummaryWithEquipmentIdOnly = await prisma.viewReliabilitySummary.findMany({ select: { equipmentId: true } })
     * 
     */
    findMany<T extends ViewReliabilitySummaryFindManyArgs>(args?: SelectSubset<T, ViewReliabilitySummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ViewReliabilitySummary.
     * @param {ViewReliabilitySummaryCreateArgs} args - Arguments to create a ViewReliabilitySummary.
     * @example
     * // Create one ViewReliabilitySummary
     * const ViewReliabilitySummary = await prisma.viewReliabilitySummary.create({
     *   data: {
     *     // ... data to create a ViewReliabilitySummary
     *   }
     * })
     * 
     */
    create<T extends ViewReliabilitySummaryCreateArgs>(args: SelectSubset<T, ViewReliabilitySummaryCreateArgs<ExtArgs>>): Prisma__ViewReliabilitySummaryClient<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ViewReliabilitySummaries.
     * @param {ViewReliabilitySummaryCreateManyArgs} args - Arguments to create many ViewReliabilitySummaries.
     * @example
     * // Create many ViewReliabilitySummaries
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewReliabilitySummaryCreateManyArgs>(args?: SelectSubset<T, ViewReliabilitySummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewReliabilitySummaries and returns the data saved in the database.
     * @param {ViewReliabilitySummaryCreateManyAndReturnArgs} args - Arguments to create many ViewReliabilitySummaries.
     * @example
     * // Create many ViewReliabilitySummaries
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewReliabilitySummaries and only return the `equipmentId`
     * const viewReliabilitySummaryWithEquipmentIdOnly = await prisma.viewReliabilitySummary.createManyAndReturn({ 
     *   select: { equipmentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewReliabilitySummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewReliabilitySummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ViewReliabilitySummary.
     * @param {ViewReliabilitySummaryDeleteArgs} args - Arguments to delete one ViewReliabilitySummary.
     * @example
     * // Delete one ViewReliabilitySummary
     * const ViewReliabilitySummary = await prisma.viewReliabilitySummary.delete({
     *   where: {
     *     // ... filter to delete one ViewReliabilitySummary
     *   }
     * })
     * 
     */
    delete<T extends ViewReliabilitySummaryDeleteArgs>(args: SelectSubset<T, ViewReliabilitySummaryDeleteArgs<ExtArgs>>): Prisma__ViewReliabilitySummaryClient<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ViewReliabilitySummary.
     * @param {ViewReliabilitySummaryUpdateArgs} args - Arguments to update one ViewReliabilitySummary.
     * @example
     * // Update one ViewReliabilitySummary
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewReliabilitySummaryUpdateArgs>(args: SelectSubset<T, ViewReliabilitySummaryUpdateArgs<ExtArgs>>): Prisma__ViewReliabilitySummaryClient<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ViewReliabilitySummaries.
     * @param {ViewReliabilitySummaryDeleteManyArgs} args - Arguments to filter ViewReliabilitySummaries to delete.
     * @example
     * // Delete a few ViewReliabilitySummaries
     * const { count } = await prisma.viewReliabilitySummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewReliabilitySummaryDeleteManyArgs>(args?: SelectSubset<T, ViewReliabilitySummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewReliabilitySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewReliabilitySummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewReliabilitySummaries
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewReliabilitySummaryUpdateManyArgs>(args: SelectSubset<T, ViewReliabilitySummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViewReliabilitySummary.
     * @param {ViewReliabilitySummaryUpsertArgs} args - Arguments to update or create a ViewReliabilitySummary.
     * @example
     * // Update or create a ViewReliabilitySummary
     * const viewReliabilitySummary = await prisma.viewReliabilitySummary.upsert({
     *   create: {
     *     // ... data to create a ViewReliabilitySummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewReliabilitySummary we want to update
     *   }
     * })
     */
    upsert<T extends ViewReliabilitySummaryUpsertArgs>(args: SelectSubset<T, ViewReliabilitySummaryUpsertArgs<ExtArgs>>): Prisma__ViewReliabilitySummaryClient<$Result.GetResult<Prisma.$ViewReliabilitySummaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ViewReliabilitySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewReliabilitySummaryCountArgs} args - Arguments to filter ViewReliabilitySummaries to count.
     * @example
     * // Count the number of ViewReliabilitySummaries
     * const count = await prisma.viewReliabilitySummary.count({
     *   where: {
     *     // ... the filter for the ViewReliabilitySummaries we want to count
     *   }
     * })
    **/
    count<T extends ViewReliabilitySummaryCountArgs>(
      args?: Subset<T, ViewReliabilitySummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewReliabilitySummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewReliabilitySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewReliabilitySummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewReliabilitySummaryAggregateArgs>(args: Subset<T, ViewReliabilitySummaryAggregateArgs>): Prisma.PrismaPromise<GetViewReliabilitySummaryAggregateType<T>>

    /**
     * Group by ViewReliabilitySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewReliabilitySummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewReliabilitySummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewReliabilitySummaryGroupByArgs['orderBy'] }
        : { orderBy?: ViewReliabilitySummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewReliabilitySummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewReliabilitySummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewReliabilitySummary model
   */
  readonly fields: ViewReliabilitySummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewReliabilitySummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewReliabilitySummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewReliabilitySummary model
   */ 
  interface ViewReliabilitySummaryFieldRefs {
    readonly equipmentId: FieldRef<"ViewReliabilitySummary", 'Int'>
    readonly equipmentCode: FieldRef<"ViewReliabilitySummary", 'String'>
    readonly equipmentName: FieldRef<"ViewReliabilitySummary", 'String'>
    readonly mtbfHours: FieldRef<"ViewReliabilitySummary", 'Float'>
    readonly mttrHours: FieldRef<"ViewReliabilitySummary", 'Float'>
    readonly failureCount: FieldRef<"ViewReliabilitySummary", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ViewReliabilitySummary findUnique
   */
  export type ViewReliabilitySummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewReliabilitySummary to fetch.
     */
    where: ViewReliabilitySummaryWhereUniqueInput
  }

  /**
   * ViewReliabilitySummary findUniqueOrThrow
   */
  export type ViewReliabilitySummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewReliabilitySummary to fetch.
     */
    where: ViewReliabilitySummaryWhereUniqueInput
  }

  /**
   * ViewReliabilitySummary findFirst
   */
  export type ViewReliabilitySummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewReliabilitySummary to fetch.
     */
    where?: ViewReliabilitySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewReliabilitySummaries to fetch.
     */
    orderBy?: ViewReliabilitySummaryOrderByWithRelationInput | ViewReliabilitySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewReliabilitySummaries.
     */
    cursor?: ViewReliabilitySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewReliabilitySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewReliabilitySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewReliabilitySummaries.
     */
    distinct?: ViewReliabilitySummaryScalarFieldEnum | ViewReliabilitySummaryScalarFieldEnum[]
  }

  /**
   * ViewReliabilitySummary findFirstOrThrow
   */
  export type ViewReliabilitySummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewReliabilitySummary to fetch.
     */
    where?: ViewReliabilitySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewReliabilitySummaries to fetch.
     */
    orderBy?: ViewReliabilitySummaryOrderByWithRelationInput | ViewReliabilitySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewReliabilitySummaries.
     */
    cursor?: ViewReliabilitySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewReliabilitySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewReliabilitySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewReliabilitySummaries.
     */
    distinct?: ViewReliabilitySummaryScalarFieldEnum | ViewReliabilitySummaryScalarFieldEnum[]
  }

  /**
   * ViewReliabilitySummary findMany
   */
  export type ViewReliabilitySummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewReliabilitySummaries to fetch.
     */
    where?: ViewReliabilitySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewReliabilitySummaries to fetch.
     */
    orderBy?: ViewReliabilitySummaryOrderByWithRelationInput | ViewReliabilitySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewReliabilitySummaries.
     */
    cursor?: ViewReliabilitySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewReliabilitySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewReliabilitySummaries.
     */
    skip?: number
    distinct?: ViewReliabilitySummaryScalarFieldEnum | ViewReliabilitySummaryScalarFieldEnum[]
  }

  /**
   * ViewReliabilitySummary create
   */
  export type ViewReliabilitySummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * The data needed to create a ViewReliabilitySummary.
     */
    data: XOR<ViewReliabilitySummaryCreateInput, ViewReliabilitySummaryUncheckedCreateInput>
  }

  /**
   * ViewReliabilitySummary createMany
   */
  export type ViewReliabilitySummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewReliabilitySummaries.
     */
    data: ViewReliabilitySummaryCreateManyInput | ViewReliabilitySummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewReliabilitySummary createManyAndReturn
   */
  export type ViewReliabilitySummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ViewReliabilitySummaries.
     */
    data: ViewReliabilitySummaryCreateManyInput | ViewReliabilitySummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewReliabilitySummary update
   */
  export type ViewReliabilitySummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * The data needed to update a ViewReliabilitySummary.
     */
    data: XOR<ViewReliabilitySummaryUpdateInput, ViewReliabilitySummaryUncheckedUpdateInput>
    /**
     * Choose, which ViewReliabilitySummary to update.
     */
    where: ViewReliabilitySummaryWhereUniqueInput
  }

  /**
   * ViewReliabilitySummary updateMany
   */
  export type ViewReliabilitySummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewReliabilitySummaries.
     */
    data: XOR<ViewReliabilitySummaryUpdateManyMutationInput, ViewReliabilitySummaryUncheckedUpdateManyInput>
    /**
     * Filter which ViewReliabilitySummaries to update
     */
    where?: ViewReliabilitySummaryWhereInput
  }

  /**
   * ViewReliabilitySummary upsert
   */
  export type ViewReliabilitySummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * The filter to search for the ViewReliabilitySummary to update in case it exists.
     */
    where: ViewReliabilitySummaryWhereUniqueInput
    /**
     * In case the ViewReliabilitySummary found by the `where` argument doesn't exist, create a new ViewReliabilitySummary with this data.
     */
    create: XOR<ViewReliabilitySummaryCreateInput, ViewReliabilitySummaryUncheckedCreateInput>
    /**
     * In case the ViewReliabilitySummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewReliabilitySummaryUpdateInput, ViewReliabilitySummaryUncheckedUpdateInput>
  }

  /**
   * ViewReliabilitySummary delete
   */
  export type ViewReliabilitySummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
    /**
     * Filter which ViewReliabilitySummary to delete.
     */
    where: ViewReliabilitySummaryWhereUniqueInput
  }

  /**
   * ViewReliabilitySummary deleteMany
   */
  export type ViewReliabilitySummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewReliabilitySummaries to delete
     */
    where?: ViewReliabilitySummaryWhereInput
  }

  /**
   * ViewReliabilitySummary without action
   */
  export type ViewReliabilitySummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewReliabilitySummary
     */
    select?: ViewReliabilitySummarySelect<ExtArgs> | null
  }


  /**
   * Model ViewScrapSummary
   */

  export type AggregateViewScrapSummary = {
    _count: ViewScrapSummaryCountAggregateOutputType | null
    _avg: ViewScrapSummaryAvgAggregateOutputType | null
    _sum: ViewScrapSummarySumAggregateOutputType | null
    _min: ViewScrapSummaryMinAggregateOutputType | null
    _max: ViewScrapSummaryMaxAggregateOutputType | null
  }

  export type ViewScrapSummaryAvgAggregateOutputType = {
    equipmentId: number | null
    productId: number | null
    totalScrapQty: number | null
    scrapIncidents: number | null
    scrapCost: Decimal | null
  }

  export type ViewScrapSummarySumAggregateOutputType = {
    equipmentId: number | null
    productId: number | null
    totalScrapQty: number | null
    scrapIncidents: number | null
    scrapCost: Decimal | null
  }

  export type ViewScrapSummaryMinAggregateOutputType = {
    dateId: Date | null
    equipmentId: number | null
    productId: number | null
    scrapCode: string | null
    scrapReason: string | null
    totalScrapQty: number | null
    scrapIncidents: number | null
    scrapCost: Decimal | null
  }

  export type ViewScrapSummaryMaxAggregateOutputType = {
    dateId: Date | null
    equipmentId: number | null
    productId: number | null
    scrapCode: string | null
    scrapReason: string | null
    totalScrapQty: number | null
    scrapIncidents: number | null
    scrapCost: Decimal | null
  }

  export type ViewScrapSummaryCountAggregateOutputType = {
    dateId: number
    equipmentId: number
    productId: number
    scrapCode: number
    scrapReason: number
    totalScrapQty: number
    scrapIncidents: number
    scrapCost: number
    _all: number
  }


  export type ViewScrapSummaryAvgAggregateInputType = {
    equipmentId?: true
    productId?: true
    totalScrapQty?: true
    scrapIncidents?: true
    scrapCost?: true
  }

  export type ViewScrapSummarySumAggregateInputType = {
    equipmentId?: true
    productId?: true
    totalScrapQty?: true
    scrapIncidents?: true
    scrapCost?: true
  }

  export type ViewScrapSummaryMinAggregateInputType = {
    dateId?: true
    equipmentId?: true
    productId?: true
    scrapCode?: true
    scrapReason?: true
    totalScrapQty?: true
    scrapIncidents?: true
    scrapCost?: true
  }

  export type ViewScrapSummaryMaxAggregateInputType = {
    dateId?: true
    equipmentId?: true
    productId?: true
    scrapCode?: true
    scrapReason?: true
    totalScrapQty?: true
    scrapIncidents?: true
    scrapCost?: true
  }

  export type ViewScrapSummaryCountAggregateInputType = {
    dateId?: true
    equipmentId?: true
    productId?: true
    scrapCode?: true
    scrapReason?: true
    totalScrapQty?: true
    scrapIncidents?: true
    scrapCost?: true
    _all?: true
  }

  export type ViewScrapSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewScrapSummary to aggregate.
     */
    where?: ViewScrapSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewScrapSummaries to fetch.
     */
    orderBy?: ViewScrapSummaryOrderByWithRelationInput | ViewScrapSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewScrapSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewScrapSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewScrapSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewScrapSummaries
    **/
    _count?: true | ViewScrapSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewScrapSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewScrapSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewScrapSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewScrapSummaryMaxAggregateInputType
  }

  export type GetViewScrapSummaryAggregateType<T extends ViewScrapSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateViewScrapSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewScrapSummary[P]>
      : GetScalarType<T[P], AggregateViewScrapSummary[P]>
  }




  export type ViewScrapSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewScrapSummaryWhereInput
    orderBy?: ViewScrapSummaryOrderByWithAggregationInput | ViewScrapSummaryOrderByWithAggregationInput[]
    by: ViewScrapSummaryScalarFieldEnum[] | ViewScrapSummaryScalarFieldEnum
    having?: ViewScrapSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewScrapSummaryCountAggregateInputType | true
    _avg?: ViewScrapSummaryAvgAggregateInputType
    _sum?: ViewScrapSummarySumAggregateInputType
    _min?: ViewScrapSummaryMinAggregateInputType
    _max?: ViewScrapSummaryMaxAggregateInputType
  }

  export type ViewScrapSummaryGroupByOutputType = {
    dateId: Date
    equipmentId: number
    productId: number
    scrapCode: string
    scrapReason: string | null
    totalScrapQty: number
    scrapIncidents: number
    scrapCost: Decimal | null
    _count: ViewScrapSummaryCountAggregateOutputType | null
    _avg: ViewScrapSummaryAvgAggregateOutputType | null
    _sum: ViewScrapSummarySumAggregateOutputType | null
    _min: ViewScrapSummaryMinAggregateOutputType | null
    _max: ViewScrapSummaryMaxAggregateOutputType | null
  }

  type GetViewScrapSummaryGroupByPayload<T extends ViewScrapSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewScrapSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewScrapSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewScrapSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], ViewScrapSummaryGroupByOutputType[P]>
        }
      >
    >


  export type ViewScrapSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dateId?: boolean
    equipmentId?: boolean
    productId?: boolean
    scrapCode?: boolean
    scrapReason?: boolean
    totalScrapQty?: boolean
    scrapIncidents?: boolean
    scrapCost?: boolean
  }, ExtArgs["result"]["viewScrapSummary"]>

  export type ViewScrapSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dateId?: boolean
    equipmentId?: boolean
    productId?: boolean
    scrapCode?: boolean
    scrapReason?: boolean
    totalScrapQty?: boolean
    scrapIncidents?: boolean
    scrapCost?: boolean
  }, ExtArgs["result"]["viewScrapSummary"]>

  export type ViewScrapSummarySelectScalar = {
    dateId?: boolean
    equipmentId?: boolean
    productId?: boolean
    scrapCode?: boolean
    scrapReason?: boolean
    totalScrapQty?: boolean
    scrapIncidents?: boolean
    scrapCost?: boolean
  }


  export type $ViewScrapSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewScrapSummary"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      dateId: Date
      equipmentId: number
      productId: number
      scrapCode: string
      scrapReason: string | null
      totalScrapQty: number
      scrapIncidents: number
      scrapCost: Prisma.Decimal | null
    }, ExtArgs["result"]["viewScrapSummary"]>
    composites: {}
  }

  type ViewScrapSummaryGetPayload<S extends boolean | null | undefined | ViewScrapSummaryDefaultArgs> = $Result.GetResult<Prisma.$ViewScrapSummaryPayload, S>

  type ViewScrapSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViewScrapSummaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViewScrapSummaryCountAggregateInputType | true
    }

  export interface ViewScrapSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewScrapSummary'], meta: { name: 'ViewScrapSummary' } }
    /**
     * Find zero or one ViewScrapSummary that matches the filter.
     * @param {ViewScrapSummaryFindUniqueArgs} args - Arguments to find a ViewScrapSummary
     * @example
     * // Get one ViewScrapSummary
     * const viewScrapSummary = await prisma.viewScrapSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewScrapSummaryFindUniqueArgs>(args: SelectSubset<T, ViewScrapSummaryFindUniqueArgs<ExtArgs>>): Prisma__ViewScrapSummaryClient<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ViewScrapSummary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViewScrapSummaryFindUniqueOrThrowArgs} args - Arguments to find a ViewScrapSummary
     * @example
     * // Get one ViewScrapSummary
     * const viewScrapSummary = await prisma.viewScrapSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewScrapSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewScrapSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewScrapSummaryClient<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ViewScrapSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewScrapSummaryFindFirstArgs} args - Arguments to find a ViewScrapSummary
     * @example
     * // Get one ViewScrapSummary
     * const viewScrapSummary = await prisma.viewScrapSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewScrapSummaryFindFirstArgs>(args?: SelectSubset<T, ViewScrapSummaryFindFirstArgs<ExtArgs>>): Prisma__ViewScrapSummaryClient<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ViewScrapSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewScrapSummaryFindFirstOrThrowArgs} args - Arguments to find a ViewScrapSummary
     * @example
     * // Get one ViewScrapSummary
     * const viewScrapSummary = await prisma.viewScrapSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewScrapSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewScrapSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewScrapSummaryClient<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ViewScrapSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewScrapSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewScrapSummaries
     * const viewScrapSummaries = await prisma.viewScrapSummary.findMany()
     * 
     * // Get first 10 ViewScrapSummaries
     * const viewScrapSummaries = await prisma.viewScrapSummary.findMany({ take: 10 })
     * 
     * // Only select the `dateId`
     * const viewScrapSummaryWithDateIdOnly = await prisma.viewScrapSummary.findMany({ select: { dateId: true } })
     * 
     */
    findMany<T extends ViewScrapSummaryFindManyArgs>(args?: SelectSubset<T, ViewScrapSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ViewScrapSummary.
     * @param {ViewScrapSummaryCreateArgs} args - Arguments to create a ViewScrapSummary.
     * @example
     * // Create one ViewScrapSummary
     * const ViewScrapSummary = await prisma.viewScrapSummary.create({
     *   data: {
     *     // ... data to create a ViewScrapSummary
     *   }
     * })
     * 
     */
    create<T extends ViewScrapSummaryCreateArgs>(args: SelectSubset<T, ViewScrapSummaryCreateArgs<ExtArgs>>): Prisma__ViewScrapSummaryClient<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ViewScrapSummaries.
     * @param {ViewScrapSummaryCreateManyArgs} args - Arguments to create many ViewScrapSummaries.
     * @example
     * // Create many ViewScrapSummaries
     * const viewScrapSummary = await prisma.viewScrapSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewScrapSummaryCreateManyArgs>(args?: SelectSubset<T, ViewScrapSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewScrapSummaries and returns the data saved in the database.
     * @param {ViewScrapSummaryCreateManyAndReturnArgs} args - Arguments to create many ViewScrapSummaries.
     * @example
     * // Create many ViewScrapSummaries
     * const viewScrapSummary = await prisma.viewScrapSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewScrapSummaries and only return the `dateId`
     * const viewScrapSummaryWithDateIdOnly = await prisma.viewScrapSummary.createManyAndReturn({ 
     *   select: { dateId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewScrapSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewScrapSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ViewScrapSummary.
     * @param {ViewScrapSummaryDeleteArgs} args - Arguments to delete one ViewScrapSummary.
     * @example
     * // Delete one ViewScrapSummary
     * const ViewScrapSummary = await prisma.viewScrapSummary.delete({
     *   where: {
     *     // ... filter to delete one ViewScrapSummary
     *   }
     * })
     * 
     */
    delete<T extends ViewScrapSummaryDeleteArgs>(args: SelectSubset<T, ViewScrapSummaryDeleteArgs<ExtArgs>>): Prisma__ViewScrapSummaryClient<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ViewScrapSummary.
     * @param {ViewScrapSummaryUpdateArgs} args - Arguments to update one ViewScrapSummary.
     * @example
     * // Update one ViewScrapSummary
     * const viewScrapSummary = await prisma.viewScrapSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewScrapSummaryUpdateArgs>(args: SelectSubset<T, ViewScrapSummaryUpdateArgs<ExtArgs>>): Prisma__ViewScrapSummaryClient<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ViewScrapSummaries.
     * @param {ViewScrapSummaryDeleteManyArgs} args - Arguments to filter ViewScrapSummaries to delete.
     * @example
     * // Delete a few ViewScrapSummaries
     * const { count } = await prisma.viewScrapSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewScrapSummaryDeleteManyArgs>(args?: SelectSubset<T, ViewScrapSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewScrapSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewScrapSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewScrapSummaries
     * const viewScrapSummary = await prisma.viewScrapSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewScrapSummaryUpdateManyArgs>(args: SelectSubset<T, ViewScrapSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViewScrapSummary.
     * @param {ViewScrapSummaryUpsertArgs} args - Arguments to update or create a ViewScrapSummary.
     * @example
     * // Update or create a ViewScrapSummary
     * const viewScrapSummary = await prisma.viewScrapSummary.upsert({
     *   create: {
     *     // ... data to create a ViewScrapSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewScrapSummary we want to update
     *   }
     * })
     */
    upsert<T extends ViewScrapSummaryUpsertArgs>(args: SelectSubset<T, ViewScrapSummaryUpsertArgs<ExtArgs>>): Prisma__ViewScrapSummaryClient<$Result.GetResult<Prisma.$ViewScrapSummaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ViewScrapSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewScrapSummaryCountArgs} args - Arguments to filter ViewScrapSummaries to count.
     * @example
     * // Count the number of ViewScrapSummaries
     * const count = await prisma.viewScrapSummary.count({
     *   where: {
     *     // ... the filter for the ViewScrapSummaries we want to count
     *   }
     * })
    **/
    count<T extends ViewScrapSummaryCountArgs>(
      args?: Subset<T, ViewScrapSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewScrapSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewScrapSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewScrapSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewScrapSummaryAggregateArgs>(args: Subset<T, ViewScrapSummaryAggregateArgs>): Prisma.PrismaPromise<GetViewScrapSummaryAggregateType<T>>

    /**
     * Group by ViewScrapSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewScrapSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewScrapSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewScrapSummaryGroupByArgs['orderBy'] }
        : { orderBy?: ViewScrapSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewScrapSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewScrapSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewScrapSummary model
   */
  readonly fields: ViewScrapSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewScrapSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewScrapSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewScrapSummary model
   */ 
  interface ViewScrapSummaryFieldRefs {
    readonly dateId: FieldRef<"ViewScrapSummary", 'DateTime'>
    readonly equipmentId: FieldRef<"ViewScrapSummary", 'Int'>
    readonly productId: FieldRef<"ViewScrapSummary", 'Int'>
    readonly scrapCode: FieldRef<"ViewScrapSummary", 'String'>
    readonly scrapReason: FieldRef<"ViewScrapSummary", 'String'>
    readonly totalScrapQty: FieldRef<"ViewScrapSummary", 'Int'>
    readonly scrapIncidents: FieldRef<"ViewScrapSummary", 'Int'>
    readonly scrapCost: FieldRef<"ViewScrapSummary", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ViewScrapSummary findUnique
   */
  export type ViewScrapSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewScrapSummary to fetch.
     */
    where: ViewScrapSummaryWhereUniqueInput
  }

  /**
   * ViewScrapSummary findUniqueOrThrow
   */
  export type ViewScrapSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewScrapSummary to fetch.
     */
    where: ViewScrapSummaryWhereUniqueInput
  }

  /**
   * ViewScrapSummary findFirst
   */
  export type ViewScrapSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewScrapSummary to fetch.
     */
    where?: ViewScrapSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewScrapSummaries to fetch.
     */
    orderBy?: ViewScrapSummaryOrderByWithRelationInput | ViewScrapSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewScrapSummaries.
     */
    cursor?: ViewScrapSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewScrapSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewScrapSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewScrapSummaries.
     */
    distinct?: ViewScrapSummaryScalarFieldEnum | ViewScrapSummaryScalarFieldEnum[]
  }

  /**
   * ViewScrapSummary findFirstOrThrow
   */
  export type ViewScrapSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewScrapSummary to fetch.
     */
    where?: ViewScrapSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewScrapSummaries to fetch.
     */
    orderBy?: ViewScrapSummaryOrderByWithRelationInput | ViewScrapSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewScrapSummaries.
     */
    cursor?: ViewScrapSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewScrapSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewScrapSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewScrapSummaries.
     */
    distinct?: ViewScrapSummaryScalarFieldEnum | ViewScrapSummaryScalarFieldEnum[]
  }

  /**
   * ViewScrapSummary findMany
   */
  export type ViewScrapSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * Filter, which ViewScrapSummaries to fetch.
     */
    where?: ViewScrapSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewScrapSummaries to fetch.
     */
    orderBy?: ViewScrapSummaryOrderByWithRelationInput | ViewScrapSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewScrapSummaries.
     */
    cursor?: ViewScrapSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewScrapSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewScrapSummaries.
     */
    skip?: number
    distinct?: ViewScrapSummaryScalarFieldEnum | ViewScrapSummaryScalarFieldEnum[]
  }

  /**
   * ViewScrapSummary create
   */
  export type ViewScrapSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * The data needed to create a ViewScrapSummary.
     */
    data: XOR<ViewScrapSummaryCreateInput, ViewScrapSummaryUncheckedCreateInput>
  }

  /**
   * ViewScrapSummary createMany
   */
  export type ViewScrapSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewScrapSummaries.
     */
    data: ViewScrapSummaryCreateManyInput | ViewScrapSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewScrapSummary createManyAndReturn
   */
  export type ViewScrapSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ViewScrapSummaries.
     */
    data: ViewScrapSummaryCreateManyInput | ViewScrapSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewScrapSummary update
   */
  export type ViewScrapSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * The data needed to update a ViewScrapSummary.
     */
    data: XOR<ViewScrapSummaryUpdateInput, ViewScrapSummaryUncheckedUpdateInput>
    /**
     * Choose, which ViewScrapSummary to update.
     */
    where: ViewScrapSummaryWhereUniqueInput
  }

  /**
   * ViewScrapSummary updateMany
   */
  export type ViewScrapSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewScrapSummaries.
     */
    data: XOR<ViewScrapSummaryUpdateManyMutationInput, ViewScrapSummaryUncheckedUpdateManyInput>
    /**
     * Filter which ViewScrapSummaries to update
     */
    where?: ViewScrapSummaryWhereInput
  }

  /**
   * ViewScrapSummary upsert
   */
  export type ViewScrapSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * The filter to search for the ViewScrapSummary to update in case it exists.
     */
    where: ViewScrapSummaryWhereUniqueInput
    /**
     * In case the ViewScrapSummary found by the `where` argument doesn't exist, create a new ViewScrapSummary with this data.
     */
    create: XOR<ViewScrapSummaryCreateInput, ViewScrapSummaryUncheckedCreateInput>
    /**
     * In case the ViewScrapSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewScrapSummaryUpdateInput, ViewScrapSummaryUncheckedUpdateInput>
  }

  /**
   * ViewScrapSummary delete
   */
  export type ViewScrapSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
    /**
     * Filter which ViewScrapSummary to delete.
     */
    where: ViewScrapSummaryWhereUniqueInput
  }

  /**
   * ViewScrapSummary deleteMany
   */
  export type ViewScrapSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewScrapSummaries to delete
     */
    where?: ViewScrapSummaryWhereInput
  }

  /**
   * ViewScrapSummary without action
   */
  export type ViewScrapSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewScrapSummary
     */
    select?: ViewScrapSummarySelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DimSiteScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    timezone: 'timezone'
  };

  export type DimSiteScalarFieldEnum = (typeof DimSiteScalarFieldEnum)[keyof typeof DimSiteScalarFieldEnum]


  export const DimAreaScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    siteId: 'siteId'
  };

  export type DimAreaScalarFieldEnum = (typeof DimAreaScalarFieldEnum)[keyof typeof DimAreaScalarFieldEnum]


  export const DimWorkCenterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    areaId: 'areaId',
    capacity: 'capacity',
    capacityUnit: 'capacityUnit'
  };

  export type DimWorkCenterScalarFieldEnum = (typeof DimWorkCenterScalarFieldEnum)[keyof typeof DimWorkCenterScalarFieldEnum]


  export const DimEquipmentScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    type: 'type',
    workCenterId: 'workCenterId',
    manufacturer: 'manufacturer',
    model: 'model',
    serialNumber: 'serialNumber',
    installationDate: 'installationDate',
    criticalityLevel: 'criticalityLevel',
    theoreticalRate: 'theoreticalRate',
    attributes: 'attributes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DimEquipmentScalarFieldEnum = (typeof DimEquipmentScalarFieldEnum)[keyof typeof DimEquipmentScalarFieldEnum]


  export const DimProductScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    family: 'family',
    unitOfMeasure: 'unitOfMeasure',
    standardCost: 'standardCost',
    targetCycleTime: 'targetCycleTime'
  };

  export type DimProductScalarFieldEnum = (typeof DimProductScalarFieldEnum)[keyof typeof DimProductScalarFieldEnum]


  export const DimShiftScalarFieldEnum: {
    id: 'id',
    siteId: 'siteId',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    breakMinutes: 'breakMinutes',
    isActive: 'isActive'
  };

  export type DimShiftScalarFieldEnum = (typeof DimShiftScalarFieldEnum)[keyof typeof DimShiftScalarFieldEnum]


  export const DimDowntimeReasonScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    category: 'category',
    isPlanned: 'isPlanned',
    affectsOee: 'affectsOee',
    isFailure: 'isFailure'
  };

  export type DimDowntimeReasonScalarFieldEnum = (typeof DimDowntimeReasonScalarFieldEnum)[keyof typeof DimDowntimeReasonScalarFieldEnum]


  export const DimUnitScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    type: 'type'
  };

  export type DimUnitScalarFieldEnum = (typeof DimUnitScalarFieldEnum)[keyof typeof DimUnitScalarFieldEnum]


  export const FactProductionScalarFieldEnum: {
    id: 'id',
    dateId: 'dateId',
    shiftId: 'shiftId',
    equipmentId: 'equipmentId',
    productId: 'productId',
    orderNumber: 'orderNumber',
    startTime: 'startTime',
    endTime: 'endTime',
    plannedProductionTime: 'plannedProductionTime',
    operatingTime: 'operatingTime',
    plannedParts: 'plannedParts',
    totalPartsProduced: 'totalPartsProduced',
    goodParts: 'goodParts',
    scrapParts: 'scrapParts',
    reworkParts: 'reworkParts',
    operatorId: 'operatorId',
    createdAt: 'createdAt'
  };

  export type FactProductionScalarFieldEnum = (typeof FactProductionScalarFieldEnum)[keyof typeof FactProductionScalarFieldEnum]


  export const FactDowntimeScalarFieldEnum: {
    id: 'id',
    productionId: 'productionId',
    equipmentId: 'equipmentId',
    reasonId: 'reasonId',
    startTime: 'startTime',
    endTime: 'endTime',
    downtimeDuration: 'downtimeDuration',
    comments: 'comments',
    createdAt: 'createdAt'
  };

  export type FactDowntimeScalarFieldEnum = (typeof FactDowntimeScalarFieldEnum)[keyof typeof FactDowntimeScalarFieldEnum]


  export const FactScrapScalarFieldEnum: {
    id: 'id',
    productionId: 'productionId',
    productId: 'productId',
    scrapCode: 'scrapCode',
    scrapQty: 'scrapQty',
    scrapCost: 'scrapCost',
    createdAt: 'createdAt'
  };

  export type FactScrapScalarFieldEnum = (typeof FactScrapScalarFieldEnum)[keyof typeof FactScrapScalarFieldEnum]


  export const FactMaintenanceScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    workOrderNumber: 'workOrderNumber',
    maintenanceType: 'maintenanceType',
    startTime: 'startTime',
    endTime: 'endTime',
    laborHours: 'laborHours',
    materialCost: 'materialCost',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type FactMaintenanceScalarFieldEnum = (typeof FactMaintenanceScalarFieldEnum)[keyof typeof FactMaintenanceScalarFieldEnum]


  export const FactSensorEventScalarFieldEnum: {
    eventId: 'eventId',
    equipmentId: 'equipmentId',
    eventTs: 'eventTs',
    parameter: 'parameter',
    value: 'value',
    unitId: 'unitId'
  };

  export type FactSensorEventScalarFieldEnum = (typeof FactSensorEventScalarFieldEnum)[keyof typeof FactSensorEventScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    username: 'username',
    action: 'action',
    tableName: 'tableName',
    recordId: 'recordId',
    logTs: 'logTs',
    beforeData: 'beforeData',
    afterData: 'afterData'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AuditEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    aggregateId: 'aggregateId',
    aggregateType: 'aggregateType',
    eventData: 'eventData',
    eventMetadata: 'eventMetadata',
    userId: 'userId',
    correlationId: 'correlationId',
    causationId: 'causationId',
    createdAt: 'createdAt'
  };

  export type AuditEventScalarFieldEnum = (typeof AuditEventScalarFieldEnum)[keyof typeof AuditEventScalarFieldEnum]


  export const DataDictionaryScalarFieldEnum: {
    id: 'id',
    schemaName: 'schemaName',
    tableName: 'tableName',
    columnName: 'columnName',
    dataType: 'dataType',
    isNullable: 'isNullable',
    description: 'description',
    businessName: 'businessName',
    dataSteward: 'dataSteward',
    classification: 'classification',
    piiFlag: 'piiFlag',
    retentionDays: 'retentionDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataDictionaryScalarFieldEnum = (typeof DataDictionaryScalarFieldEnum)[keyof typeof DataDictionaryScalarFieldEnum]


  export const DataRetentionPolicyScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    retentionDays: 'retentionDays',
    archiveEnabled: 'archiveEnabled',
    archiveTableName: 'archiveTableName',
    lastArchived: 'lastArchived',
    createdAt: 'createdAt'
  };

  export type DataRetentionPolicyScalarFieldEnum = (typeof DataRetentionPolicyScalarFieldEnum)[keyof typeof DataRetentionPolicyScalarFieldEnum]


  export const QueryPerformanceScalarFieldEnum: {
    id: 'id',
    queryHash: 'queryHash',
    queryText: 'queryText',
    totalTime: 'totalTime',
    meanTime: 'meanTime',
    maxTime: 'maxTime',
    minTime: 'minTime',
    calls: 'calls',
    rows: 'rows',
    capturedAt: 'capturedAt'
  };

  export type QueryPerformanceScalarFieldEnum = (typeof QueryPerformanceScalarFieldEnum)[keyof typeof QueryPerformanceScalarFieldEnum]


  export const DataQualityScoresScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    checkName: 'checkName',
    checkType: 'checkType',
    passed: 'passed',
    score: 'score',
    totalRows: 'totalRows',
    failedRows: 'failedRows',
    details: 'details',
    checkedAt: 'checkedAt'
  };

  export type DataQualityScoresScalarFieldEnum = (typeof DataQualityScoresScalarFieldEnum)[keyof typeof DataQualityScoresScalarFieldEnum]


  export const SystemMetricsScalarFieldEnum: {
    id: 'id',
    metricType: 'metricType',
    metricName: 'metricName',
    metricValue: 'metricValue',
    metricUnit: 'metricUnit',
    hostName: 'hostName',
    serviceName: 'serviceName',
    tags: 'tags',
    collectedAt: 'collectedAt'
  };

  export type SystemMetricsScalarFieldEnum = (typeof SystemMetricsScalarFieldEnum)[keyof typeof SystemMetricsScalarFieldEnum]


  export const DimDateRangeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type DimDateRangeScalarFieldEnum = (typeof DimDateRangeScalarFieldEnum)[keyof typeof DimDateRangeScalarFieldEnum]


  export const OntologyTermScalarFieldEnum: {
    term: 'term',
    modelName: 'modelName',
    fieldName: 'fieldName',
    priority: 'priority'
  };

  export type OntologyTermScalarFieldEnum = (typeof OntologyTermScalarFieldEnum)[keyof typeof OntologyTermScalarFieldEnum]


  export const ViewOeeDailyScalarFieldEnum: {
    dateId: 'dateId',
    shiftId: 'shiftId',
    equipmentId: 'equipmentId',
    availability: 'availability',
    performance: 'performance',
    quality: 'quality',
    oee: 'oee'
  };

  export type ViewOeeDailyScalarFieldEnum = (typeof ViewOeeDailyScalarFieldEnum)[keyof typeof ViewOeeDailyScalarFieldEnum]


  export const ViewReliabilitySummaryScalarFieldEnum: {
    equipmentId: 'equipmentId',
    equipmentCode: 'equipmentCode',
    equipmentName: 'equipmentName',
    mtbfHours: 'mtbfHours',
    mttrHours: 'mttrHours',
    failureCount: 'failureCount'
  };

  export type ViewReliabilitySummaryScalarFieldEnum = (typeof ViewReliabilitySummaryScalarFieldEnum)[keyof typeof ViewReliabilitySummaryScalarFieldEnum]


  export const ViewScrapSummaryScalarFieldEnum: {
    dateId: 'dateId',
    equipmentId: 'equipmentId',
    productId: 'productId',
    scrapCode: 'scrapCode',
    scrapReason: 'scrapReason',
    totalScrapQty: 'totalScrapQty',
    scrapIncidents: 'scrapIncidents',
    scrapCost: 'scrapCost'
  };

  export type ViewScrapSummaryScalarFieldEnum = (typeof ViewScrapSummaryScalarFieldEnum)[keyof typeof ViewScrapSummaryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type DimSiteWhereInput = {
    AND?: DimSiteWhereInput | DimSiteWhereInput[]
    OR?: DimSiteWhereInput[]
    NOT?: DimSiteWhereInput | DimSiteWhereInput[]
    id?: IntFilter<"DimSite"> | number
    code?: StringFilter<"DimSite"> | string
    name?: StringFilter<"DimSite"> | string
    timezone?: StringNullableFilter<"DimSite"> | string | null
    areas?: DimAreaListRelationFilter
    shifts?: DimShiftListRelationFilter
  }

  export type DimSiteOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    timezone?: SortOrderInput | SortOrder
    areas?: DimAreaOrderByRelationAggregateInput
    shifts?: DimShiftOrderByRelationAggregateInput
  }

  export type DimSiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DimSiteWhereInput | DimSiteWhereInput[]
    OR?: DimSiteWhereInput[]
    NOT?: DimSiteWhereInput | DimSiteWhereInput[]
    name?: StringFilter<"DimSite"> | string
    timezone?: StringNullableFilter<"DimSite"> | string | null
    areas?: DimAreaListRelationFilter
    shifts?: DimShiftListRelationFilter
  }, "id" | "code">

  export type DimSiteOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    timezone?: SortOrderInput | SortOrder
    _count?: DimSiteCountOrderByAggregateInput
    _avg?: DimSiteAvgOrderByAggregateInput
    _max?: DimSiteMaxOrderByAggregateInput
    _min?: DimSiteMinOrderByAggregateInput
    _sum?: DimSiteSumOrderByAggregateInput
  }

  export type DimSiteScalarWhereWithAggregatesInput = {
    AND?: DimSiteScalarWhereWithAggregatesInput | DimSiteScalarWhereWithAggregatesInput[]
    OR?: DimSiteScalarWhereWithAggregatesInput[]
    NOT?: DimSiteScalarWhereWithAggregatesInput | DimSiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimSite"> | number
    code?: StringWithAggregatesFilter<"DimSite"> | string
    name?: StringWithAggregatesFilter<"DimSite"> | string
    timezone?: StringNullableWithAggregatesFilter<"DimSite"> | string | null
  }

  export type DimAreaWhereInput = {
    AND?: DimAreaWhereInput | DimAreaWhereInput[]
    OR?: DimAreaWhereInput[]
    NOT?: DimAreaWhereInput | DimAreaWhereInput[]
    id?: IntFilter<"DimArea"> | number
    code?: StringFilter<"DimArea"> | string
    name?: StringFilter<"DimArea"> | string
    siteId?: IntFilter<"DimArea"> | number
    site?: XOR<DimSiteRelationFilter, DimSiteWhereInput>
    workCenters?: DimWorkCenterListRelationFilter
  }

  export type DimAreaOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    siteId?: SortOrder
    site?: DimSiteOrderByWithRelationInput
    workCenters?: DimWorkCenterOrderByRelationAggregateInput
  }

  export type DimAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DimAreaWhereInput | DimAreaWhereInput[]
    OR?: DimAreaWhereInput[]
    NOT?: DimAreaWhereInput | DimAreaWhereInput[]
    name?: StringFilter<"DimArea"> | string
    siteId?: IntFilter<"DimArea"> | number
    site?: XOR<DimSiteRelationFilter, DimSiteWhereInput>
    workCenters?: DimWorkCenterListRelationFilter
  }, "id" | "code">

  export type DimAreaOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    siteId?: SortOrder
    _count?: DimAreaCountOrderByAggregateInput
    _avg?: DimAreaAvgOrderByAggregateInput
    _max?: DimAreaMaxOrderByAggregateInput
    _min?: DimAreaMinOrderByAggregateInput
    _sum?: DimAreaSumOrderByAggregateInput
  }

  export type DimAreaScalarWhereWithAggregatesInput = {
    AND?: DimAreaScalarWhereWithAggregatesInput | DimAreaScalarWhereWithAggregatesInput[]
    OR?: DimAreaScalarWhereWithAggregatesInput[]
    NOT?: DimAreaScalarWhereWithAggregatesInput | DimAreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimArea"> | number
    code?: StringWithAggregatesFilter<"DimArea"> | string
    name?: StringWithAggregatesFilter<"DimArea"> | string
    siteId?: IntWithAggregatesFilter<"DimArea"> | number
  }

  export type DimWorkCenterWhereInput = {
    AND?: DimWorkCenterWhereInput | DimWorkCenterWhereInput[]
    OR?: DimWorkCenterWhereInput[]
    NOT?: DimWorkCenterWhereInput | DimWorkCenterWhereInput[]
    id?: IntFilter<"DimWorkCenter"> | number
    code?: StringFilter<"DimWorkCenter"> | string
    name?: StringFilter<"DimWorkCenter"> | string
    areaId?: IntFilter<"DimWorkCenter"> | number
    capacity?: DecimalNullableFilter<"DimWorkCenter"> | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: StringNullableFilter<"DimWorkCenter"> | string | null
    area?: XOR<DimAreaRelationFilter, DimAreaWhereInput>
    equipment?: DimEquipmentListRelationFilter
  }

  export type DimWorkCenterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    areaId?: SortOrder
    capacity?: SortOrderInput | SortOrder
    capacityUnit?: SortOrderInput | SortOrder
    area?: DimAreaOrderByWithRelationInput
    equipment?: DimEquipmentOrderByRelationAggregateInput
  }

  export type DimWorkCenterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DimWorkCenterWhereInput | DimWorkCenterWhereInput[]
    OR?: DimWorkCenterWhereInput[]
    NOT?: DimWorkCenterWhereInput | DimWorkCenterWhereInput[]
    name?: StringFilter<"DimWorkCenter"> | string
    areaId?: IntFilter<"DimWorkCenter"> | number
    capacity?: DecimalNullableFilter<"DimWorkCenter"> | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: StringNullableFilter<"DimWorkCenter"> | string | null
    area?: XOR<DimAreaRelationFilter, DimAreaWhereInput>
    equipment?: DimEquipmentListRelationFilter
  }, "id" | "code">

  export type DimWorkCenterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    areaId?: SortOrder
    capacity?: SortOrderInput | SortOrder
    capacityUnit?: SortOrderInput | SortOrder
    _count?: DimWorkCenterCountOrderByAggregateInput
    _avg?: DimWorkCenterAvgOrderByAggregateInput
    _max?: DimWorkCenterMaxOrderByAggregateInput
    _min?: DimWorkCenterMinOrderByAggregateInput
    _sum?: DimWorkCenterSumOrderByAggregateInput
  }

  export type DimWorkCenterScalarWhereWithAggregatesInput = {
    AND?: DimWorkCenterScalarWhereWithAggregatesInput | DimWorkCenterScalarWhereWithAggregatesInput[]
    OR?: DimWorkCenterScalarWhereWithAggregatesInput[]
    NOT?: DimWorkCenterScalarWhereWithAggregatesInput | DimWorkCenterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimWorkCenter"> | number
    code?: StringWithAggregatesFilter<"DimWorkCenter"> | string
    name?: StringWithAggregatesFilter<"DimWorkCenter"> | string
    areaId?: IntWithAggregatesFilter<"DimWorkCenter"> | number
    capacity?: DecimalNullableWithAggregatesFilter<"DimWorkCenter"> | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: StringNullableWithAggregatesFilter<"DimWorkCenter"> | string | null
  }

  export type DimEquipmentWhereInput = {
    AND?: DimEquipmentWhereInput | DimEquipmentWhereInput[]
    OR?: DimEquipmentWhereInput[]
    NOT?: DimEquipmentWhereInput | DimEquipmentWhereInput[]
    id?: IntFilter<"DimEquipment"> | number
    code?: StringFilter<"DimEquipment"> | string
    name?: StringFilter<"DimEquipment"> | string
    type?: StringNullableFilter<"DimEquipment"> | string | null
    workCenterId?: IntFilter<"DimEquipment"> | number
    manufacturer?: StringNullableFilter<"DimEquipment"> | string | null
    model?: StringNullableFilter<"DimEquipment"> | string | null
    serialNumber?: StringNullableFilter<"DimEquipment"> | string | null
    installationDate?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
    criticalityLevel?: StringNullableFilter<"DimEquipment"> | string | null
    theoreticalRate?: DecimalNullableFilter<"DimEquipment"> | Decimal | DecimalJsLike | number | string | null
    attributes?: JsonNullableFilter<"DimEquipment">
    isActive?: BoolNullableFilter<"DimEquipment"> | boolean | null
    createdAt?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
    workCenter?: XOR<DimWorkCenterRelationFilter, DimWorkCenterWhereInput>
    production?: FactProductionListRelationFilter
    downtime?: FactDowntimeListRelationFilter
    maintenance?: FactMaintenanceListRelationFilter
    sensorEvents?: FactSensorEventListRelationFilter
  }

  export type DimEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    workCenterId?: SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    installationDate?: SortOrderInput | SortOrder
    criticalityLevel?: SortOrderInput | SortOrder
    theoreticalRate?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    workCenter?: DimWorkCenterOrderByWithRelationInput
    production?: FactProductionOrderByRelationAggregateInput
    downtime?: FactDowntimeOrderByRelationAggregateInput
    maintenance?: FactMaintenanceOrderByRelationAggregateInput
    sensorEvents?: FactSensorEventOrderByRelationAggregateInput
  }

  export type DimEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DimEquipmentWhereInput | DimEquipmentWhereInput[]
    OR?: DimEquipmentWhereInput[]
    NOT?: DimEquipmentWhereInput | DimEquipmentWhereInput[]
    name?: StringFilter<"DimEquipment"> | string
    type?: StringNullableFilter<"DimEquipment"> | string | null
    workCenterId?: IntFilter<"DimEquipment"> | number
    manufacturer?: StringNullableFilter<"DimEquipment"> | string | null
    model?: StringNullableFilter<"DimEquipment"> | string | null
    serialNumber?: StringNullableFilter<"DimEquipment"> | string | null
    installationDate?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
    criticalityLevel?: StringNullableFilter<"DimEquipment"> | string | null
    theoreticalRate?: DecimalNullableFilter<"DimEquipment"> | Decimal | DecimalJsLike | number | string | null
    attributes?: JsonNullableFilter<"DimEquipment">
    isActive?: BoolNullableFilter<"DimEquipment"> | boolean | null
    createdAt?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
    workCenter?: XOR<DimWorkCenterRelationFilter, DimWorkCenterWhereInput>
    production?: FactProductionListRelationFilter
    downtime?: FactDowntimeListRelationFilter
    maintenance?: FactMaintenanceListRelationFilter
    sensorEvents?: FactSensorEventListRelationFilter
  }, "id" | "code">

  export type DimEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    workCenterId?: SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    installationDate?: SortOrderInput | SortOrder
    criticalityLevel?: SortOrderInput | SortOrder
    theoreticalRate?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: DimEquipmentCountOrderByAggregateInput
    _avg?: DimEquipmentAvgOrderByAggregateInput
    _max?: DimEquipmentMaxOrderByAggregateInput
    _min?: DimEquipmentMinOrderByAggregateInput
    _sum?: DimEquipmentSumOrderByAggregateInput
  }

  export type DimEquipmentScalarWhereWithAggregatesInput = {
    AND?: DimEquipmentScalarWhereWithAggregatesInput | DimEquipmentScalarWhereWithAggregatesInput[]
    OR?: DimEquipmentScalarWhereWithAggregatesInput[]
    NOT?: DimEquipmentScalarWhereWithAggregatesInput | DimEquipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimEquipment"> | number
    code?: StringWithAggregatesFilter<"DimEquipment"> | string
    name?: StringWithAggregatesFilter<"DimEquipment"> | string
    type?: StringNullableWithAggregatesFilter<"DimEquipment"> | string | null
    workCenterId?: IntWithAggregatesFilter<"DimEquipment"> | number
    manufacturer?: StringNullableWithAggregatesFilter<"DimEquipment"> | string | null
    model?: StringNullableWithAggregatesFilter<"DimEquipment"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"DimEquipment"> | string | null
    installationDate?: DateTimeNullableWithAggregatesFilter<"DimEquipment"> | Date | string | null
    criticalityLevel?: StringNullableWithAggregatesFilter<"DimEquipment"> | string | null
    theoreticalRate?: DecimalNullableWithAggregatesFilter<"DimEquipment"> | Decimal | DecimalJsLike | number | string | null
    attributes?: JsonNullableWithAggregatesFilter<"DimEquipment">
    isActive?: BoolNullableWithAggregatesFilter<"DimEquipment"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"DimEquipment"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DimEquipment"> | Date | string | null
  }

  export type DimProductWhereInput = {
    AND?: DimProductWhereInput | DimProductWhereInput[]
    OR?: DimProductWhereInput[]
    NOT?: DimProductWhereInput | DimProductWhereInput[]
    id?: IntFilter<"DimProduct"> | number
    code?: StringFilter<"DimProduct"> | string
    name?: StringFilter<"DimProduct"> | string
    family?: StringNullableFilter<"DimProduct"> | string | null
    unitOfMeasure?: StringNullableFilter<"DimProduct"> | string | null
    standardCost?: DecimalNullableFilter<"DimProduct"> | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: BigIntNullableFilter<"DimProduct"> | bigint | number | null
    production?: FactProductionListRelationFilter
    scrap?: FactScrapListRelationFilter
  }

  export type DimProductOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    family?: SortOrderInput | SortOrder
    unitOfMeasure?: SortOrderInput | SortOrder
    standardCost?: SortOrderInput | SortOrder
    targetCycleTime?: SortOrderInput | SortOrder
    production?: FactProductionOrderByRelationAggregateInput
    scrap?: FactScrapOrderByRelationAggregateInput
  }

  export type DimProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DimProductWhereInput | DimProductWhereInput[]
    OR?: DimProductWhereInput[]
    NOT?: DimProductWhereInput | DimProductWhereInput[]
    name?: StringFilter<"DimProduct"> | string
    family?: StringNullableFilter<"DimProduct"> | string | null
    unitOfMeasure?: StringNullableFilter<"DimProduct"> | string | null
    standardCost?: DecimalNullableFilter<"DimProduct"> | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: BigIntNullableFilter<"DimProduct"> | bigint | number | null
    production?: FactProductionListRelationFilter
    scrap?: FactScrapListRelationFilter
  }, "id" | "code">

  export type DimProductOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    family?: SortOrderInput | SortOrder
    unitOfMeasure?: SortOrderInput | SortOrder
    standardCost?: SortOrderInput | SortOrder
    targetCycleTime?: SortOrderInput | SortOrder
    _count?: DimProductCountOrderByAggregateInput
    _avg?: DimProductAvgOrderByAggregateInput
    _max?: DimProductMaxOrderByAggregateInput
    _min?: DimProductMinOrderByAggregateInput
    _sum?: DimProductSumOrderByAggregateInput
  }

  export type DimProductScalarWhereWithAggregatesInput = {
    AND?: DimProductScalarWhereWithAggregatesInput | DimProductScalarWhereWithAggregatesInput[]
    OR?: DimProductScalarWhereWithAggregatesInput[]
    NOT?: DimProductScalarWhereWithAggregatesInput | DimProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimProduct"> | number
    code?: StringWithAggregatesFilter<"DimProduct"> | string
    name?: StringWithAggregatesFilter<"DimProduct"> | string
    family?: StringNullableWithAggregatesFilter<"DimProduct"> | string | null
    unitOfMeasure?: StringNullableWithAggregatesFilter<"DimProduct"> | string | null
    standardCost?: DecimalNullableWithAggregatesFilter<"DimProduct"> | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: BigIntNullableWithAggregatesFilter<"DimProduct"> | bigint | number | null
  }

  export type DimShiftWhereInput = {
    AND?: DimShiftWhereInput | DimShiftWhereInput[]
    OR?: DimShiftWhereInput[]
    NOT?: DimShiftWhereInput | DimShiftWhereInput[]
    id?: IntFilter<"DimShift"> | number
    siteId?: IntFilter<"DimShift"> | number
    name?: StringFilter<"DimShift"> | string
    startTime?: StringFilter<"DimShift"> | string
    endTime?: StringFilter<"DimShift"> | string
    breakMinutes?: IntNullableFilter<"DimShift"> | number | null
    isActive?: BoolNullableFilter<"DimShift"> | boolean | null
    site?: XOR<DimSiteRelationFilter, DimSiteWhereInput>
    production?: FactProductionListRelationFilter
  }

  export type DimShiftOrderByWithRelationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakMinutes?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    site?: DimSiteOrderByWithRelationInput
    production?: FactProductionOrderByRelationAggregateInput
  }

  export type DimShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    siteId_name?: DimShiftSiteIdNameCompoundUniqueInput
    AND?: DimShiftWhereInput | DimShiftWhereInput[]
    OR?: DimShiftWhereInput[]
    NOT?: DimShiftWhereInput | DimShiftWhereInput[]
    siteId?: IntFilter<"DimShift"> | number
    name?: StringFilter<"DimShift"> | string
    startTime?: StringFilter<"DimShift"> | string
    endTime?: StringFilter<"DimShift"> | string
    breakMinutes?: IntNullableFilter<"DimShift"> | number | null
    isActive?: BoolNullableFilter<"DimShift"> | boolean | null
    site?: XOR<DimSiteRelationFilter, DimSiteWhereInput>
    production?: FactProductionListRelationFilter
  }, "id" | "siteId_name">

  export type DimShiftOrderByWithAggregationInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakMinutes?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    _count?: DimShiftCountOrderByAggregateInput
    _avg?: DimShiftAvgOrderByAggregateInput
    _max?: DimShiftMaxOrderByAggregateInput
    _min?: DimShiftMinOrderByAggregateInput
    _sum?: DimShiftSumOrderByAggregateInput
  }

  export type DimShiftScalarWhereWithAggregatesInput = {
    AND?: DimShiftScalarWhereWithAggregatesInput | DimShiftScalarWhereWithAggregatesInput[]
    OR?: DimShiftScalarWhereWithAggregatesInput[]
    NOT?: DimShiftScalarWhereWithAggregatesInput | DimShiftScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimShift"> | number
    siteId?: IntWithAggregatesFilter<"DimShift"> | number
    name?: StringWithAggregatesFilter<"DimShift"> | string
    startTime?: StringWithAggregatesFilter<"DimShift"> | string
    endTime?: StringWithAggregatesFilter<"DimShift"> | string
    breakMinutes?: IntNullableWithAggregatesFilter<"DimShift"> | number | null
    isActive?: BoolNullableWithAggregatesFilter<"DimShift"> | boolean | null
  }

  export type DimDowntimeReasonWhereInput = {
    AND?: DimDowntimeReasonWhereInput | DimDowntimeReasonWhereInput[]
    OR?: DimDowntimeReasonWhereInput[]
    NOT?: DimDowntimeReasonWhereInput | DimDowntimeReasonWhereInput[]
    id?: IntFilter<"DimDowntimeReason"> | number
    code?: StringFilter<"DimDowntimeReason"> | string
    description?: StringFilter<"DimDowntimeReason"> | string
    category?: StringFilter<"DimDowntimeReason"> | string
    isPlanned?: BoolNullableFilter<"DimDowntimeReason"> | boolean | null
    affectsOee?: BoolNullableFilter<"DimDowntimeReason"> | boolean | null
    isFailure?: BoolNullableFilter<"DimDowntimeReason"> | boolean | null
    downtime?: FactDowntimeListRelationFilter
  }

  export type DimDowntimeReasonOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPlanned?: SortOrderInput | SortOrder
    affectsOee?: SortOrderInput | SortOrder
    isFailure?: SortOrderInput | SortOrder
    downtime?: FactDowntimeOrderByRelationAggregateInput
  }

  export type DimDowntimeReasonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DimDowntimeReasonWhereInput | DimDowntimeReasonWhereInput[]
    OR?: DimDowntimeReasonWhereInput[]
    NOT?: DimDowntimeReasonWhereInput | DimDowntimeReasonWhereInput[]
    description?: StringFilter<"DimDowntimeReason"> | string
    category?: StringFilter<"DimDowntimeReason"> | string
    isPlanned?: BoolNullableFilter<"DimDowntimeReason"> | boolean | null
    affectsOee?: BoolNullableFilter<"DimDowntimeReason"> | boolean | null
    isFailure?: BoolNullableFilter<"DimDowntimeReason"> | boolean | null
    downtime?: FactDowntimeListRelationFilter
  }, "id" | "code">

  export type DimDowntimeReasonOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPlanned?: SortOrderInput | SortOrder
    affectsOee?: SortOrderInput | SortOrder
    isFailure?: SortOrderInput | SortOrder
    _count?: DimDowntimeReasonCountOrderByAggregateInput
    _avg?: DimDowntimeReasonAvgOrderByAggregateInput
    _max?: DimDowntimeReasonMaxOrderByAggregateInput
    _min?: DimDowntimeReasonMinOrderByAggregateInput
    _sum?: DimDowntimeReasonSumOrderByAggregateInput
  }

  export type DimDowntimeReasonScalarWhereWithAggregatesInput = {
    AND?: DimDowntimeReasonScalarWhereWithAggregatesInput | DimDowntimeReasonScalarWhereWithAggregatesInput[]
    OR?: DimDowntimeReasonScalarWhereWithAggregatesInput[]
    NOT?: DimDowntimeReasonScalarWhereWithAggregatesInput | DimDowntimeReasonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimDowntimeReason"> | number
    code?: StringWithAggregatesFilter<"DimDowntimeReason"> | string
    description?: StringWithAggregatesFilter<"DimDowntimeReason"> | string
    category?: StringWithAggregatesFilter<"DimDowntimeReason"> | string
    isPlanned?: BoolNullableWithAggregatesFilter<"DimDowntimeReason"> | boolean | null
    affectsOee?: BoolNullableWithAggregatesFilter<"DimDowntimeReason"> | boolean | null
    isFailure?: BoolNullableWithAggregatesFilter<"DimDowntimeReason"> | boolean | null
  }

  export type DimUnitWhereInput = {
    AND?: DimUnitWhereInput | DimUnitWhereInput[]
    OR?: DimUnitWhereInput[]
    NOT?: DimUnitWhereInput | DimUnitWhereInput[]
    id?: IntFilter<"DimUnit"> | number
    code?: StringFilter<"DimUnit"> | string
    name?: StringFilter<"DimUnit"> | string
    type?: StringFilter<"DimUnit"> | string
    sensorEvents?: FactSensorEventListRelationFilter
  }

  export type DimUnitOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sensorEvents?: FactSensorEventOrderByRelationAggregateInput
  }

  export type DimUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DimUnitWhereInput | DimUnitWhereInput[]
    OR?: DimUnitWhereInput[]
    NOT?: DimUnitWhereInput | DimUnitWhereInput[]
    name?: StringFilter<"DimUnit"> | string
    type?: StringFilter<"DimUnit"> | string
    sensorEvents?: FactSensorEventListRelationFilter
  }, "id" | "code">

  export type DimUnitOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    _count?: DimUnitCountOrderByAggregateInput
    _avg?: DimUnitAvgOrderByAggregateInput
    _max?: DimUnitMaxOrderByAggregateInput
    _min?: DimUnitMinOrderByAggregateInput
    _sum?: DimUnitSumOrderByAggregateInput
  }

  export type DimUnitScalarWhereWithAggregatesInput = {
    AND?: DimUnitScalarWhereWithAggregatesInput | DimUnitScalarWhereWithAggregatesInput[]
    OR?: DimUnitScalarWhereWithAggregatesInput[]
    NOT?: DimUnitScalarWhereWithAggregatesInput | DimUnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimUnit"> | number
    code?: StringWithAggregatesFilter<"DimUnit"> | string
    name?: StringWithAggregatesFilter<"DimUnit"> | string
    type?: StringWithAggregatesFilter<"DimUnit"> | string
  }

  export type FactProductionWhereInput = {
    AND?: FactProductionWhereInput | FactProductionWhereInput[]
    OR?: FactProductionWhereInput[]
    NOT?: FactProductionWhereInput | FactProductionWhereInput[]
    id?: IntFilter<"FactProduction"> | number
    dateId?: IntFilter<"FactProduction"> | number
    shiftId?: IntFilter<"FactProduction"> | number
    equipmentId?: IntFilter<"FactProduction"> | number
    productId?: IntFilter<"FactProduction"> | number
    orderNumber?: StringNullableFilter<"FactProduction"> | string | null
    startTime?: DateTimeFilter<"FactProduction"> | Date | string
    endTime?: DateTimeFilter<"FactProduction"> | Date | string
    plannedProductionTime?: BigIntFilter<"FactProduction"> | bigint | number
    operatingTime?: BigIntFilter<"FactProduction"> | bigint | number
    plannedParts?: IntFilter<"FactProduction"> | number
    totalPartsProduced?: IntFilter<"FactProduction"> | number
    goodParts?: IntFilter<"FactProduction"> | number
    scrapParts?: IntNullableFilter<"FactProduction"> | number | null
    reworkParts?: IntNullableFilter<"FactProduction"> | number | null
    operatorId?: StringNullableFilter<"FactProduction"> | string | null
    createdAt?: DateTimeNullableFilter<"FactProduction"> | Date | string | null
    equipment?: XOR<DimEquipmentRelationFilter, DimEquipmentWhereInput>
    product?: XOR<DimProductRelationFilter, DimProductWhereInput>
    shift?: XOR<DimShiftRelationFilter, DimShiftWhereInput>
    downtime?: FactDowntimeListRelationFilter
    scrap?: FactScrapListRelationFilter
  }

  export type FactProductionOrderByWithRelationInput = {
    id?: SortOrder
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    plannedProductionTime?: SortOrder
    operatingTime?: SortOrder
    plannedParts?: SortOrder
    totalPartsProduced?: SortOrder
    goodParts?: SortOrder
    scrapParts?: SortOrderInput | SortOrder
    reworkParts?: SortOrderInput | SortOrder
    operatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    equipment?: DimEquipmentOrderByWithRelationInput
    product?: DimProductOrderByWithRelationInput
    shift?: DimShiftOrderByWithRelationInput
    downtime?: FactDowntimeOrderByRelationAggregateInput
    scrap?: FactScrapOrderByRelationAggregateInput
  }

  export type FactProductionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FactProductionWhereInput | FactProductionWhereInput[]
    OR?: FactProductionWhereInput[]
    NOT?: FactProductionWhereInput | FactProductionWhereInput[]
    dateId?: IntFilter<"FactProduction"> | number
    shiftId?: IntFilter<"FactProduction"> | number
    equipmentId?: IntFilter<"FactProduction"> | number
    productId?: IntFilter<"FactProduction"> | number
    orderNumber?: StringNullableFilter<"FactProduction"> | string | null
    startTime?: DateTimeFilter<"FactProduction"> | Date | string
    endTime?: DateTimeFilter<"FactProduction"> | Date | string
    plannedProductionTime?: BigIntFilter<"FactProduction"> | bigint | number
    operatingTime?: BigIntFilter<"FactProduction"> | bigint | number
    plannedParts?: IntFilter<"FactProduction"> | number
    totalPartsProduced?: IntFilter<"FactProduction"> | number
    goodParts?: IntFilter<"FactProduction"> | number
    scrapParts?: IntNullableFilter<"FactProduction"> | number | null
    reworkParts?: IntNullableFilter<"FactProduction"> | number | null
    operatorId?: StringNullableFilter<"FactProduction"> | string | null
    createdAt?: DateTimeNullableFilter<"FactProduction"> | Date | string | null
    equipment?: XOR<DimEquipmentRelationFilter, DimEquipmentWhereInput>
    product?: XOR<DimProductRelationFilter, DimProductWhereInput>
    shift?: XOR<DimShiftRelationFilter, DimShiftWhereInput>
    downtime?: FactDowntimeListRelationFilter
    scrap?: FactScrapListRelationFilter
  }, "id">

  export type FactProductionOrderByWithAggregationInput = {
    id?: SortOrder
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    plannedProductionTime?: SortOrder
    operatingTime?: SortOrder
    plannedParts?: SortOrder
    totalPartsProduced?: SortOrder
    goodParts?: SortOrder
    scrapParts?: SortOrderInput | SortOrder
    reworkParts?: SortOrderInput | SortOrder
    operatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: FactProductionCountOrderByAggregateInput
    _avg?: FactProductionAvgOrderByAggregateInput
    _max?: FactProductionMaxOrderByAggregateInput
    _min?: FactProductionMinOrderByAggregateInput
    _sum?: FactProductionSumOrderByAggregateInput
  }

  export type FactProductionScalarWhereWithAggregatesInput = {
    AND?: FactProductionScalarWhereWithAggregatesInput | FactProductionScalarWhereWithAggregatesInput[]
    OR?: FactProductionScalarWhereWithAggregatesInput[]
    NOT?: FactProductionScalarWhereWithAggregatesInput | FactProductionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FactProduction"> | number
    dateId?: IntWithAggregatesFilter<"FactProduction"> | number
    shiftId?: IntWithAggregatesFilter<"FactProduction"> | number
    equipmentId?: IntWithAggregatesFilter<"FactProduction"> | number
    productId?: IntWithAggregatesFilter<"FactProduction"> | number
    orderNumber?: StringNullableWithAggregatesFilter<"FactProduction"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"FactProduction"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"FactProduction"> | Date | string
    plannedProductionTime?: BigIntWithAggregatesFilter<"FactProduction"> | bigint | number
    operatingTime?: BigIntWithAggregatesFilter<"FactProduction"> | bigint | number
    plannedParts?: IntWithAggregatesFilter<"FactProduction"> | number
    totalPartsProduced?: IntWithAggregatesFilter<"FactProduction"> | number
    goodParts?: IntWithAggregatesFilter<"FactProduction"> | number
    scrapParts?: IntNullableWithAggregatesFilter<"FactProduction"> | number | null
    reworkParts?: IntNullableWithAggregatesFilter<"FactProduction"> | number | null
    operatorId?: StringNullableWithAggregatesFilter<"FactProduction"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"FactProduction"> | Date | string | null
  }

  export type FactDowntimeWhereInput = {
    AND?: FactDowntimeWhereInput | FactDowntimeWhereInput[]
    OR?: FactDowntimeWhereInput[]
    NOT?: FactDowntimeWhereInput | FactDowntimeWhereInput[]
    id?: IntFilter<"FactDowntime"> | number
    productionId?: IntNullableFilter<"FactDowntime"> | number | null
    equipmentId?: IntFilter<"FactDowntime"> | number
    reasonId?: IntFilter<"FactDowntime"> | number
    startTime?: DateTimeFilter<"FactDowntime"> | Date | string
    endTime?: DateTimeFilter<"FactDowntime"> | Date | string
    downtimeDuration?: BigIntFilter<"FactDowntime"> | bigint | number
    comments?: StringNullableFilter<"FactDowntime"> | string | null
    createdAt?: DateTimeNullableFilter<"FactDowntime"> | Date | string | null
    equipment?: XOR<DimEquipmentRelationFilter, DimEquipmentWhereInput>
    reason?: XOR<DimDowntimeReasonRelationFilter, DimDowntimeReasonWhereInput>
    production?: XOR<FactProductionNullableRelationFilter, FactProductionWhereInput> | null
  }

  export type FactDowntimeOrderByWithRelationInput = {
    id?: SortOrder
    productionId?: SortOrderInput | SortOrder
    equipmentId?: SortOrder
    reasonId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    downtimeDuration?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    equipment?: DimEquipmentOrderByWithRelationInput
    reason?: DimDowntimeReasonOrderByWithRelationInput
    production?: FactProductionOrderByWithRelationInput
  }

  export type FactDowntimeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FactDowntimeWhereInput | FactDowntimeWhereInput[]
    OR?: FactDowntimeWhereInput[]
    NOT?: FactDowntimeWhereInput | FactDowntimeWhereInput[]
    productionId?: IntNullableFilter<"FactDowntime"> | number | null
    equipmentId?: IntFilter<"FactDowntime"> | number
    reasonId?: IntFilter<"FactDowntime"> | number
    startTime?: DateTimeFilter<"FactDowntime"> | Date | string
    endTime?: DateTimeFilter<"FactDowntime"> | Date | string
    downtimeDuration?: BigIntFilter<"FactDowntime"> | bigint | number
    comments?: StringNullableFilter<"FactDowntime"> | string | null
    createdAt?: DateTimeNullableFilter<"FactDowntime"> | Date | string | null
    equipment?: XOR<DimEquipmentRelationFilter, DimEquipmentWhereInput>
    reason?: XOR<DimDowntimeReasonRelationFilter, DimDowntimeReasonWhereInput>
    production?: XOR<FactProductionNullableRelationFilter, FactProductionWhereInput> | null
  }, "id">

  export type FactDowntimeOrderByWithAggregationInput = {
    id?: SortOrder
    productionId?: SortOrderInput | SortOrder
    equipmentId?: SortOrder
    reasonId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    downtimeDuration?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: FactDowntimeCountOrderByAggregateInput
    _avg?: FactDowntimeAvgOrderByAggregateInput
    _max?: FactDowntimeMaxOrderByAggregateInput
    _min?: FactDowntimeMinOrderByAggregateInput
    _sum?: FactDowntimeSumOrderByAggregateInput
  }

  export type FactDowntimeScalarWhereWithAggregatesInput = {
    AND?: FactDowntimeScalarWhereWithAggregatesInput | FactDowntimeScalarWhereWithAggregatesInput[]
    OR?: FactDowntimeScalarWhereWithAggregatesInput[]
    NOT?: FactDowntimeScalarWhereWithAggregatesInput | FactDowntimeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FactDowntime"> | number
    productionId?: IntNullableWithAggregatesFilter<"FactDowntime"> | number | null
    equipmentId?: IntWithAggregatesFilter<"FactDowntime"> | number
    reasonId?: IntWithAggregatesFilter<"FactDowntime"> | number
    startTime?: DateTimeWithAggregatesFilter<"FactDowntime"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"FactDowntime"> | Date | string
    downtimeDuration?: BigIntWithAggregatesFilter<"FactDowntime"> | bigint | number
    comments?: StringNullableWithAggregatesFilter<"FactDowntime"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"FactDowntime"> | Date | string | null
  }

  export type FactScrapWhereInput = {
    AND?: FactScrapWhereInput | FactScrapWhereInput[]
    OR?: FactScrapWhereInput[]
    NOT?: FactScrapWhereInput | FactScrapWhereInput[]
    id?: IntFilter<"FactScrap"> | number
    productionId?: IntFilter<"FactScrap"> | number
    productId?: IntFilter<"FactScrap"> | number
    scrapCode?: StringFilter<"FactScrap"> | string
    scrapQty?: IntFilter<"FactScrap"> | number
    scrapCost?: DecimalNullableFilter<"FactScrap"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"FactScrap"> | Date | string | null
    product?: XOR<DimProductRelationFilter, DimProductWhereInput>
    production?: XOR<FactProductionRelationFilter, FactProductionWhereInput>
  }

  export type FactScrapOrderByWithRelationInput = {
    id?: SortOrder
    productionId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapQty?: SortOrder
    scrapCost?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    product?: DimProductOrderByWithRelationInput
    production?: FactProductionOrderByWithRelationInput
  }

  export type FactScrapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FactScrapWhereInput | FactScrapWhereInput[]
    OR?: FactScrapWhereInput[]
    NOT?: FactScrapWhereInput | FactScrapWhereInput[]
    productionId?: IntFilter<"FactScrap"> | number
    productId?: IntFilter<"FactScrap"> | number
    scrapCode?: StringFilter<"FactScrap"> | string
    scrapQty?: IntFilter<"FactScrap"> | number
    scrapCost?: DecimalNullableFilter<"FactScrap"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"FactScrap"> | Date | string | null
    product?: XOR<DimProductRelationFilter, DimProductWhereInput>
    production?: XOR<FactProductionRelationFilter, FactProductionWhereInput>
  }, "id">

  export type FactScrapOrderByWithAggregationInput = {
    id?: SortOrder
    productionId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapQty?: SortOrder
    scrapCost?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: FactScrapCountOrderByAggregateInput
    _avg?: FactScrapAvgOrderByAggregateInput
    _max?: FactScrapMaxOrderByAggregateInput
    _min?: FactScrapMinOrderByAggregateInput
    _sum?: FactScrapSumOrderByAggregateInput
  }

  export type FactScrapScalarWhereWithAggregatesInput = {
    AND?: FactScrapScalarWhereWithAggregatesInput | FactScrapScalarWhereWithAggregatesInput[]
    OR?: FactScrapScalarWhereWithAggregatesInput[]
    NOT?: FactScrapScalarWhereWithAggregatesInput | FactScrapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FactScrap"> | number
    productionId?: IntWithAggregatesFilter<"FactScrap"> | number
    productId?: IntWithAggregatesFilter<"FactScrap"> | number
    scrapCode?: StringWithAggregatesFilter<"FactScrap"> | string
    scrapQty?: IntWithAggregatesFilter<"FactScrap"> | number
    scrapCost?: DecimalNullableWithAggregatesFilter<"FactScrap"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"FactScrap"> | Date | string | null
  }

  export type FactMaintenanceWhereInput = {
    AND?: FactMaintenanceWhereInput | FactMaintenanceWhereInput[]
    OR?: FactMaintenanceWhereInput[]
    NOT?: FactMaintenanceWhereInput | FactMaintenanceWhereInput[]
    id?: IntFilter<"FactMaintenance"> | number
    equipmentId?: IntFilter<"FactMaintenance"> | number
    workOrderNumber?: StringFilter<"FactMaintenance"> | string
    maintenanceType?: StringFilter<"FactMaintenance"> | string
    startTime?: DateTimeFilter<"FactMaintenance"> | Date | string
    endTime?: DateTimeFilter<"FactMaintenance"> | Date | string
    laborHours?: DecimalNullableFilter<"FactMaintenance"> | Decimal | DecimalJsLike | number | string | null
    materialCost?: DecimalNullableFilter<"FactMaintenance"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"FactMaintenance"> | string | null
    createdAt?: DateTimeNullableFilter<"FactMaintenance"> | Date | string | null
    equipment?: XOR<DimEquipmentRelationFilter, DimEquipmentWhereInput>
  }

  export type FactMaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    workOrderNumber?: SortOrder
    maintenanceType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    laborHours?: SortOrderInput | SortOrder
    materialCost?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    equipment?: DimEquipmentOrderByWithRelationInput
  }

  export type FactMaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FactMaintenanceWhereInput | FactMaintenanceWhereInput[]
    OR?: FactMaintenanceWhereInput[]
    NOT?: FactMaintenanceWhereInput | FactMaintenanceWhereInput[]
    equipmentId?: IntFilter<"FactMaintenance"> | number
    workOrderNumber?: StringFilter<"FactMaintenance"> | string
    maintenanceType?: StringFilter<"FactMaintenance"> | string
    startTime?: DateTimeFilter<"FactMaintenance"> | Date | string
    endTime?: DateTimeFilter<"FactMaintenance"> | Date | string
    laborHours?: DecimalNullableFilter<"FactMaintenance"> | Decimal | DecimalJsLike | number | string | null
    materialCost?: DecimalNullableFilter<"FactMaintenance"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"FactMaintenance"> | string | null
    createdAt?: DateTimeNullableFilter<"FactMaintenance"> | Date | string | null
    equipment?: XOR<DimEquipmentRelationFilter, DimEquipmentWhereInput>
  }, "id">

  export type FactMaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    workOrderNumber?: SortOrder
    maintenanceType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    laborHours?: SortOrderInput | SortOrder
    materialCost?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: FactMaintenanceCountOrderByAggregateInput
    _avg?: FactMaintenanceAvgOrderByAggregateInput
    _max?: FactMaintenanceMaxOrderByAggregateInput
    _min?: FactMaintenanceMinOrderByAggregateInput
    _sum?: FactMaintenanceSumOrderByAggregateInput
  }

  export type FactMaintenanceScalarWhereWithAggregatesInput = {
    AND?: FactMaintenanceScalarWhereWithAggregatesInput | FactMaintenanceScalarWhereWithAggregatesInput[]
    OR?: FactMaintenanceScalarWhereWithAggregatesInput[]
    NOT?: FactMaintenanceScalarWhereWithAggregatesInput | FactMaintenanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FactMaintenance"> | number
    equipmentId?: IntWithAggregatesFilter<"FactMaintenance"> | number
    workOrderNumber?: StringWithAggregatesFilter<"FactMaintenance"> | string
    maintenanceType?: StringWithAggregatesFilter<"FactMaintenance"> | string
    startTime?: DateTimeWithAggregatesFilter<"FactMaintenance"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"FactMaintenance"> | Date | string
    laborHours?: DecimalNullableWithAggregatesFilter<"FactMaintenance"> | Decimal | DecimalJsLike | number | string | null
    materialCost?: DecimalNullableWithAggregatesFilter<"FactMaintenance"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableWithAggregatesFilter<"FactMaintenance"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"FactMaintenance"> | Date | string | null
  }

  export type FactSensorEventWhereInput = {
    AND?: FactSensorEventWhereInput | FactSensorEventWhereInput[]
    OR?: FactSensorEventWhereInput[]
    NOT?: FactSensorEventWhereInput | FactSensorEventWhereInput[]
    eventId?: BigIntFilter<"FactSensorEvent"> | bigint | number
    equipmentId?: IntFilter<"FactSensorEvent"> | number
    eventTs?: DateTimeFilter<"FactSensorEvent"> | Date | string
    parameter?: StringFilter<"FactSensorEvent"> | string
    value?: DecimalFilter<"FactSensorEvent"> | Decimal | DecimalJsLike | number | string
    unitId?: IntNullableFilter<"FactSensorEvent"> | number | null
    equipment?: XOR<DimEquipmentRelationFilter, DimEquipmentWhereInput>
    unit?: XOR<DimUnitNullableRelationFilter, DimUnitWhereInput> | null
  }

  export type FactSensorEventOrderByWithRelationInput = {
    eventId?: SortOrder
    equipmentId?: SortOrder
    eventTs?: SortOrder
    parameter?: SortOrder
    value?: SortOrder
    unitId?: SortOrderInput | SortOrder
    equipment?: DimEquipmentOrderByWithRelationInput
    unit?: DimUnitOrderByWithRelationInput
  }

  export type FactSensorEventWhereUniqueInput = Prisma.AtLeast<{
    eventId_eventTs?: FactSensorEventEventIdEventTsCompoundUniqueInput
    AND?: FactSensorEventWhereInput | FactSensorEventWhereInput[]
    OR?: FactSensorEventWhereInput[]
    NOT?: FactSensorEventWhereInput | FactSensorEventWhereInput[]
    eventId?: BigIntFilter<"FactSensorEvent"> | bigint | number
    equipmentId?: IntFilter<"FactSensorEvent"> | number
    eventTs?: DateTimeFilter<"FactSensorEvent"> | Date | string
    parameter?: StringFilter<"FactSensorEvent"> | string
    value?: DecimalFilter<"FactSensorEvent"> | Decimal | DecimalJsLike | number | string
    unitId?: IntNullableFilter<"FactSensorEvent"> | number | null
    equipment?: XOR<DimEquipmentRelationFilter, DimEquipmentWhereInput>
    unit?: XOR<DimUnitNullableRelationFilter, DimUnitWhereInput> | null
  }, "eventId_eventTs">

  export type FactSensorEventOrderByWithAggregationInput = {
    eventId?: SortOrder
    equipmentId?: SortOrder
    eventTs?: SortOrder
    parameter?: SortOrder
    value?: SortOrder
    unitId?: SortOrderInput | SortOrder
    _count?: FactSensorEventCountOrderByAggregateInput
    _avg?: FactSensorEventAvgOrderByAggregateInput
    _max?: FactSensorEventMaxOrderByAggregateInput
    _min?: FactSensorEventMinOrderByAggregateInput
    _sum?: FactSensorEventSumOrderByAggregateInput
  }

  export type FactSensorEventScalarWhereWithAggregatesInput = {
    AND?: FactSensorEventScalarWhereWithAggregatesInput | FactSensorEventScalarWhereWithAggregatesInput[]
    OR?: FactSensorEventScalarWhereWithAggregatesInput[]
    NOT?: FactSensorEventScalarWhereWithAggregatesInput | FactSensorEventScalarWhereWithAggregatesInput[]
    eventId?: BigIntWithAggregatesFilter<"FactSensorEvent"> | bigint | number
    equipmentId?: IntWithAggregatesFilter<"FactSensorEvent"> | number
    eventTs?: DateTimeWithAggregatesFilter<"FactSensorEvent"> | Date | string
    parameter?: StringWithAggregatesFilter<"FactSensorEvent"> | string
    value?: DecimalWithAggregatesFilter<"FactSensorEvent"> | Decimal | DecimalJsLike | number | string
    unitId?: IntNullableWithAggregatesFilter<"FactSensorEvent"> | number | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: BigIntFilter<"AuditLog"> | bigint | number
    username?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    logTs?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
    beforeData?: JsonNullableFilter<"AuditLog">
    afterData?: JsonNullableFilter<"AuditLog">
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    logTs?: SortOrderInput | SortOrder
    beforeData?: SortOrderInput | SortOrder
    afterData?: SortOrderInput | SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    username?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    logTs?: DateTimeNullableFilter<"AuditLog"> | Date | string | null
    beforeData?: JsonNullableFilter<"AuditLog">
    afterData?: JsonNullableFilter<"AuditLog">
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    logTs?: SortOrderInput | SortOrder
    beforeData?: SortOrderInput | SortOrder
    afterData?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"AuditLog"> | bigint | number
    username?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: StringWithAggregatesFilter<"AuditLog"> | string
    logTs?: DateTimeNullableWithAggregatesFilter<"AuditLog"> | Date | string | null
    beforeData?: JsonNullableWithAggregatesFilter<"AuditLog">
    afterData?: JsonNullableWithAggregatesFilter<"AuditLog">
  }

  export type AuditEventWhereInput = {
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    id?: BigIntFilter<"AuditEvent"> | bigint | number
    eventType?: StringFilter<"AuditEvent"> | string
    aggregateId?: StringFilter<"AuditEvent"> | string
    aggregateType?: StringFilter<"AuditEvent"> | string
    eventData?: JsonFilter<"AuditEvent">
    eventMetadata?: JsonNullableFilter<"AuditEvent">
    userId?: StringNullableFilter<"AuditEvent"> | string | null
    correlationId?: StringNullableFilter<"AuditEvent"> | string | null
    causationId?: StringNullableFilter<"AuditEvent"> | string | null
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
  }

  export type AuditEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    aggregateId?: SortOrder
    aggregateType?: SortOrder
    eventData?: SortOrder
    eventMetadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    correlationId?: SortOrderInput | SortOrder
    causationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    eventType?: StringFilter<"AuditEvent"> | string
    aggregateId?: StringFilter<"AuditEvent"> | string
    aggregateType?: StringFilter<"AuditEvent"> | string
    eventData?: JsonFilter<"AuditEvent">
    eventMetadata?: JsonNullableFilter<"AuditEvent">
    userId?: StringNullableFilter<"AuditEvent"> | string | null
    correlationId?: StringNullableFilter<"AuditEvent"> | string | null
    causationId?: StringNullableFilter<"AuditEvent"> | string | null
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
  }, "id">

  export type AuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    aggregateId?: SortOrder
    aggregateType?: SortOrder
    eventData?: SortOrder
    eventMetadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    correlationId?: SortOrderInput | SortOrder
    causationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditEventCountOrderByAggregateInput
    _avg?: AuditEventAvgOrderByAggregateInput
    _max?: AuditEventMaxOrderByAggregateInput
    _min?: AuditEventMinOrderByAggregateInput
    _sum?: AuditEventSumOrderByAggregateInput
  }

  export type AuditEventScalarWhereWithAggregatesInput = {
    AND?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    OR?: AuditEventScalarWhereWithAggregatesInput[]
    NOT?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"AuditEvent"> | bigint | number
    eventType?: StringWithAggregatesFilter<"AuditEvent"> | string
    aggregateId?: StringWithAggregatesFilter<"AuditEvent"> | string
    aggregateType?: StringWithAggregatesFilter<"AuditEvent"> | string
    eventData?: JsonWithAggregatesFilter<"AuditEvent">
    eventMetadata?: JsonNullableWithAggregatesFilter<"AuditEvent">
    userId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    correlationId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    causationId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditEvent"> | Date | string
  }

  export type DataDictionaryWhereInput = {
    AND?: DataDictionaryWhereInput | DataDictionaryWhereInput[]
    OR?: DataDictionaryWhereInput[]
    NOT?: DataDictionaryWhereInput | DataDictionaryWhereInput[]
    id?: IntFilter<"DataDictionary"> | number
    schemaName?: StringFilter<"DataDictionary"> | string
    tableName?: StringFilter<"DataDictionary"> | string
    columnName?: StringFilter<"DataDictionary"> | string
    dataType?: StringFilter<"DataDictionary"> | string
    isNullable?: BoolFilter<"DataDictionary"> | boolean
    description?: StringNullableFilter<"DataDictionary"> | string | null
    businessName?: StringNullableFilter<"DataDictionary"> | string | null
    dataSteward?: StringNullableFilter<"DataDictionary"> | string | null
    classification?: StringNullableFilter<"DataDictionary"> | string | null
    piiFlag?: BoolNullableFilter<"DataDictionary"> | boolean | null
    retentionDays?: IntNullableFilter<"DataDictionary"> | number | null
    createdAt?: DateTimeNullableFilter<"DataDictionary"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataDictionary"> | Date | string | null
  }

  export type DataDictionaryOrderByWithRelationInput = {
    id?: SortOrder
    schemaName?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    dataType?: SortOrder
    isNullable?: SortOrder
    description?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    dataSteward?: SortOrderInput | SortOrder
    classification?: SortOrderInput | SortOrder
    piiFlag?: SortOrderInput | SortOrder
    retentionDays?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type DataDictionaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    schemaName_tableName_columnName?: DataDictionarySchemaNameTableNameColumnNameCompoundUniqueInput
    AND?: DataDictionaryWhereInput | DataDictionaryWhereInput[]
    OR?: DataDictionaryWhereInput[]
    NOT?: DataDictionaryWhereInput | DataDictionaryWhereInput[]
    schemaName?: StringFilter<"DataDictionary"> | string
    tableName?: StringFilter<"DataDictionary"> | string
    columnName?: StringFilter<"DataDictionary"> | string
    dataType?: StringFilter<"DataDictionary"> | string
    isNullable?: BoolFilter<"DataDictionary"> | boolean
    description?: StringNullableFilter<"DataDictionary"> | string | null
    businessName?: StringNullableFilter<"DataDictionary"> | string | null
    dataSteward?: StringNullableFilter<"DataDictionary"> | string | null
    classification?: StringNullableFilter<"DataDictionary"> | string | null
    piiFlag?: BoolNullableFilter<"DataDictionary"> | boolean | null
    retentionDays?: IntNullableFilter<"DataDictionary"> | number | null
    createdAt?: DateTimeNullableFilter<"DataDictionary"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DataDictionary"> | Date | string | null
  }, "id" | "schemaName_tableName_columnName">

  export type DataDictionaryOrderByWithAggregationInput = {
    id?: SortOrder
    schemaName?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    dataType?: SortOrder
    isNullable?: SortOrder
    description?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    dataSteward?: SortOrderInput | SortOrder
    classification?: SortOrderInput | SortOrder
    piiFlag?: SortOrderInput | SortOrder
    retentionDays?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: DataDictionaryCountOrderByAggregateInput
    _avg?: DataDictionaryAvgOrderByAggregateInput
    _max?: DataDictionaryMaxOrderByAggregateInput
    _min?: DataDictionaryMinOrderByAggregateInput
    _sum?: DataDictionarySumOrderByAggregateInput
  }

  export type DataDictionaryScalarWhereWithAggregatesInput = {
    AND?: DataDictionaryScalarWhereWithAggregatesInput | DataDictionaryScalarWhereWithAggregatesInput[]
    OR?: DataDictionaryScalarWhereWithAggregatesInput[]
    NOT?: DataDictionaryScalarWhereWithAggregatesInput | DataDictionaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataDictionary"> | number
    schemaName?: StringWithAggregatesFilter<"DataDictionary"> | string
    tableName?: StringWithAggregatesFilter<"DataDictionary"> | string
    columnName?: StringWithAggregatesFilter<"DataDictionary"> | string
    dataType?: StringWithAggregatesFilter<"DataDictionary"> | string
    isNullable?: BoolWithAggregatesFilter<"DataDictionary"> | boolean
    description?: StringNullableWithAggregatesFilter<"DataDictionary"> | string | null
    businessName?: StringNullableWithAggregatesFilter<"DataDictionary"> | string | null
    dataSteward?: StringNullableWithAggregatesFilter<"DataDictionary"> | string | null
    classification?: StringNullableWithAggregatesFilter<"DataDictionary"> | string | null
    piiFlag?: BoolNullableWithAggregatesFilter<"DataDictionary"> | boolean | null
    retentionDays?: IntNullableWithAggregatesFilter<"DataDictionary"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"DataDictionary"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DataDictionary"> | Date | string | null
  }

  export type DataRetentionPolicyWhereInput = {
    AND?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    OR?: DataRetentionPolicyWhereInput[]
    NOT?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    id?: IntFilter<"DataRetentionPolicy"> | number
    tableName?: StringFilter<"DataRetentionPolicy"> | string
    retentionDays?: IntFilter<"DataRetentionPolicy"> | number
    archiveEnabled?: BoolNullableFilter<"DataRetentionPolicy"> | boolean | null
    archiveTableName?: StringNullableFilter<"DataRetentionPolicy"> | string | null
    lastArchived?: DateTimeNullableFilter<"DataRetentionPolicy"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"DataRetentionPolicy"> | Date | string | null
  }

  export type DataRetentionPolicyOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    retentionDays?: SortOrder
    archiveEnabled?: SortOrderInput | SortOrder
    archiveTableName?: SortOrderInput | SortOrder
    lastArchived?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type DataRetentionPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tableName?: string
    AND?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    OR?: DataRetentionPolicyWhereInput[]
    NOT?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    retentionDays?: IntFilter<"DataRetentionPolicy"> | number
    archiveEnabled?: BoolNullableFilter<"DataRetentionPolicy"> | boolean | null
    archiveTableName?: StringNullableFilter<"DataRetentionPolicy"> | string | null
    lastArchived?: DateTimeNullableFilter<"DataRetentionPolicy"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"DataRetentionPolicy"> | Date | string | null
  }, "id" | "tableName">

  export type DataRetentionPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    retentionDays?: SortOrder
    archiveEnabled?: SortOrderInput | SortOrder
    archiveTableName?: SortOrderInput | SortOrder
    lastArchived?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: DataRetentionPolicyCountOrderByAggregateInput
    _avg?: DataRetentionPolicyAvgOrderByAggregateInput
    _max?: DataRetentionPolicyMaxOrderByAggregateInput
    _min?: DataRetentionPolicyMinOrderByAggregateInput
    _sum?: DataRetentionPolicySumOrderByAggregateInput
  }

  export type DataRetentionPolicyScalarWhereWithAggregatesInput = {
    AND?: DataRetentionPolicyScalarWhereWithAggregatesInput | DataRetentionPolicyScalarWhereWithAggregatesInput[]
    OR?: DataRetentionPolicyScalarWhereWithAggregatesInput[]
    NOT?: DataRetentionPolicyScalarWhereWithAggregatesInput | DataRetentionPolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataRetentionPolicy"> | number
    tableName?: StringWithAggregatesFilter<"DataRetentionPolicy"> | string
    retentionDays?: IntWithAggregatesFilter<"DataRetentionPolicy"> | number
    archiveEnabled?: BoolNullableWithAggregatesFilter<"DataRetentionPolicy"> | boolean | null
    archiveTableName?: StringNullableWithAggregatesFilter<"DataRetentionPolicy"> | string | null
    lastArchived?: DateTimeNullableWithAggregatesFilter<"DataRetentionPolicy"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"DataRetentionPolicy"> | Date | string | null
  }

  export type QueryPerformanceWhereInput = {
    AND?: QueryPerformanceWhereInput | QueryPerformanceWhereInput[]
    OR?: QueryPerformanceWhereInput[]
    NOT?: QueryPerformanceWhereInput | QueryPerformanceWhereInput[]
    id?: IntFilter<"QueryPerformance"> | number
    queryHash?: StringFilter<"QueryPerformance"> | string
    queryText?: StringNullableFilter<"QueryPerformance"> | string | null
    totalTime?: DecimalFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    meanTime?: DecimalFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    maxTime?: DecimalFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    minTime?: DecimalFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    calls?: BigIntFilter<"QueryPerformance"> | bigint | number
    rows?: BigIntFilter<"QueryPerformance"> | bigint | number
    capturedAt?: DateTimeFilter<"QueryPerformance"> | Date | string
  }

  export type QueryPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    queryHash?: SortOrder
    queryText?: SortOrderInput | SortOrder
    totalTime?: SortOrder
    meanTime?: SortOrder
    maxTime?: SortOrder
    minTime?: SortOrder
    calls?: SortOrder
    rows?: SortOrder
    capturedAt?: SortOrder
  }

  export type QueryPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QueryPerformanceWhereInput | QueryPerformanceWhereInput[]
    OR?: QueryPerformanceWhereInput[]
    NOT?: QueryPerformanceWhereInput | QueryPerformanceWhereInput[]
    queryHash?: StringFilter<"QueryPerformance"> | string
    queryText?: StringNullableFilter<"QueryPerformance"> | string | null
    totalTime?: DecimalFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    meanTime?: DecimalFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    maxTime?: DecimalFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    minTime?: DecimalFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    calls?: BigIntFilter<"QueryPerformance"> | bigint | number
    rows?: BigIntFilter<"QueryPerformance"> | bigint | number
    capturedAt?: DateTimeFilter<"QueryPerformance"> | Date | string
  }, "id">

  export type QueryPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    queryHash?: SortOrder
    queryText?: SortOrderInput | SortOrder
    totalTime?: SortOrder
    meanTime?: SortOrder
    maxTime?: SortOrder
    minTime?: SortOrder
    calls?: SortOrder
    rows?: SortOrder
    capturedAt?: SortOrder
    _count?: QueryPerformanceCountOrderByAggregateInput
    _avg?: QueryPerformanceAvgOrderByAggregateInput
    _max?: QueryPerformanceMaxOrderByAggregateInput
    _min?: QueryPerformanceMinOrderByAggregateInput
    _sum?: QueryPerformanceSumOrderByAggregateInput
  }

  export type QueryPerformanceScalarWhereWithAggregatesInput = {
    AND?: QueryPerformanceScalarWhereWithAggregatesInput | QueryPerformanceScalarWhereWithAggregatesInput[]
    OR?: QueryPerformanceScalarWhereWithAggregatesInput[]
    NOT?: QueryPerformanceScalarWhereWithAggregatesInput | QueryPerformanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QueryPerformance"> | number
    queryHash?: StringWithAggregatesFilter<"QueryPerformance"> | string
    queryText?: StringNullableWithAggregatesFilter<"QueryPerformance"> | string | null
    totalTime?: DecimalWithAggregatesFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    meanTime?: DecimalWithAggregatesFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    maxTime?: DecimalWithAggregatesFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    minTime?: DecimalWithAggregatesFilter<"QueryPerformance"> | Decimal | DecimalJsLike | number | string
    calls?: BigIntWithAggregatesFilter<"QueryPerformance"> | bigint | number
    rows?: BigIntWithAggregatesFilter<"QueryPerformance"> | bigint | number
    capturedAt?: DateTimeWithAggregatesFilter<"QueryPerformance"> | Date | string
  }

  export type DataQualityScoresWhereInput = {
    AND?: DataQualityScoresWhereInput | DataQualityScoresWhereInput[]
    OR?: DataQualityScoresWhereInput[]
    NOT?: DataQualityScoresWhereInput | DataQualityScoresWhereInput[]
    id?: IntFilter<"DataQualityScores"> | number
    tableName?: StringFilter<"DataQualityScores"> | string
    checkName?: StringFilter<"DataQualityScores"> | string
    checkType?: StringFilter<"DataQualityScores"> | string
    passed?: BoolFilter<"DataQualityScores"> | boolean
    score?: DecimalFilter<"DataQualityScores"> | Decimal | DecimalJsLike | number | string
    totalRows?: BigIntNullableFilter<"DataQualityScores"> | bigint | number | null
    failedRows?: BigIntNullableFilter<"DataQualityScores"> | bigint | number | null
    details?: JsonNullableFilter<"DataQualityScores">
    checkedAt?: DateTimeFilter<"DataQualityScores"> | Date | string
  }

  export type DataQualityScoresOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    checkName?: SortOrder
    checkType?: SortOrder
    passed?: SortOrder
    score?: SortOrder
    totalRows?: SortOrderInput | SortOrder
    failedRows?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    checkedAt?: SortOrder
  }

  export type DataQualityScoresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DataQualityScoresWhereInput | DataQualityScoresWhereInput[]
    OR?: DataQualityScoresWhereInput[]
    NOT?: DataQualityScoresWhereInput | DataQualityScoresWhereInput[]
    tableName?: StringFilter<"DataQualityScores"> | string
    checkName?: StringFilter<"DataQualityScores"> | string
    checkType?: StringFilter<"DataQualityScores"> | string
    passed?: BoolFilter<"DataQualityScores"> | boolean
    score?: DecimalFilter<"DataQualityScores"> | Decimal | DecimalJsLike | number | string
    totalRows?: BigIntNullableFilter<"DataQualityScores"> | bigint | number | null
    failedRows?: BigIntNullableFilter<"DataQualityScores"> | bigint | number | null
    details?: JsonNullableFilter<"DataQualityScores">
    checkedAt?: DateTimeFilter<"DataQualityScores"> | Date | string
  }, "id">

  export type DataQualityScoresOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    checkName?: SortOrder
    checkType?: SortOrder
    passed?: SortOrder
    score?: SortOrder
    totalRows?: SortOrderInput | SortOrder
    failedRows?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    checkedAt?: SortOrder
    _count?: DataQualityScoresCountOrderByAggregateInput
    _avg?: DataQualityScoresAvgOrderByAggregateInput
    _max?: DataQualityScoresMaxOrderByAggregateInput
    _min?: DataQualityScoresMinOrderByAggregateInput
    _sum?: DataQualityScoresSumOrderByAggregateInput
  }

  export type DataQualityScoresScalarWhereWithAggregatesInput = {
    AND?: DataQualityScoresScalarWhereWithAggregatesInput | DataQualityScoresScalarWhereWithAggregatesInput[]
    OR?: DataQualityScoresScalarWhereWithAggregatesInput[]
    NOT?: DataQualityScoresScalarWhereWithAggregatesInput | DataQualityScoresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataQualityScores"> | number
    tableName?: StringWithAggregatesFilter<"DataQualityScores"> | string
    checkName?: StringWithAggregatesFilter<"DataQualityScores"> | string
    checkType?: StringWithAggregatesFilter<"DataQualityScores"> | string
    passed?: BoolWithAggregatesFilter<"DataQualityScores"> | boolean
    score?: DecimalWithAggregatesFilter<"DataQualityScores"> | Decimal | DecimalJsLike | number | string
    totalRows?: BigIntNullableWithAggregatesFilter<"DataQualityScores"> | bigint | number | null
    failedRows?: BigIntNullableWithAggregatesFilter<"DataQualityScores"> | bigint | number | null
    details?: JsonNullableWithAggregatesFilter<"DataQualityScores">
    checkedAt?: DateTimeWithAggregatesFilter<"DataQualityScores"> | Date | string
  }

  export type SystemMetricsWhereInput = {
    AND?: SystemMetricsWhereInput | SystemMetricsWhereInput[]
    OR?: SystemMetricsWhereInput[]
    NOT?: SystemMetricsWhereInput | SystemMetricsWhereInput[]
    id?: IntFilter<"SystemMetrics"> | number
    metricType?: StringFilter<"SystemMetrics"> | string
    metricName?: StringFilter<"SystemMetrics"> | string
    metricValue?: DecimalFilter<"SystemMetrics"> | Decimal | DecimalJsLike | number | string
    metricUnit?: StringNullableFilter<"SystemMetrics"> | string | null
    hostName?: StringNullableFilter<"SystemMetrics"> | string | null
    serviceName?: StringNullableFilter<"SystemMetrics"> | string | null
    tags?: JsonNullableFilter<"SystemMetrics">
    collectedAt?: DateTimeFilter<"SystemMetrics"> | Date | string
  }

  export type SystemMetricsOrderByWithRelationInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrderInput | SortOrder
    hostName?: SortOrderInput | SortOrder
    serviceName?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
  }

  export type SystemMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemMetricsWhereInput | SystemMetricsWhereInput[]
    OR?: SystemMetricsWhereInput[]
    NOT?: SystemMetricsWhereInput | SystemMetricsWhereInput[]
    metricType?: StringFilter<"SystemMetrics"> | string
    metricName?: StringFilter<"SystemMetrics"> | string
    metricValue?: DecimalFilter<"SystemMetrics"> | Decimal | DecimalJsLike | number | string
    metricUnit?: StringNullableFilter<"SystemMetrics"> | string | null
    hostName?: StringNullableFilter<"SystemMetrics"> | string | null
    serviceName?: StringNullableFilter<"SystemMetrics"> | string | null
    tags?: JsonNullableFilter<"SystemMetrics">
    collectedAt?: DateTimeFilter<"SystemMetrics"> | Date | string
  }, "id">

  export type SystemMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrderInput | SortOrder
    hostName?: SortOrderInput | SortOrder
    serviceName?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    collectedAt?: SortOrder
    _count?: SystemMetricsCountOrderByAggregateInput
    _avg?: SystemMetricsAvgOrderByAggregateInput
    _max?: SystemMetricsMaxOrderByAggregateInput
    _min?: SystemMetricsMinOrderByAggregateInput
    _sum?: SystemMetricsSumOrderByAggregateInput
  }

  export type SystemMetricsScalarWhereWithAggregatesInput = {
    AND?: SystemMetricsScalarWhereWithAggregatesInput | SystemMetricsScalarWhereWithAggregatesInput[]
    OR?: SystemMetricsScalarWhereWithAggregatesInput[]
    NOT?: SystemMetricsScalarWhereWithAggregatesInput | SystemMetricsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemMetrics"> | number
    metricType?: StringWithAggregatesFilter<"SystemMetrics"> | string
    metricName?: StringWithAggregatesFilter<"SystemMetrics"> | string
    metricValue?: DecimalWithAggregatesFilter<"SystemMetrics"> | Decimal | DecimalJsLike | number | string
    metricUnit?: StringNullableWithAggregatesFilter<"SystemMetrics"> | string | null
    hostName?: StringNullableWithAggregatesFilter<"SystemMetrics"> | string | null
    serviceName?: StringNullableWithAggregatesFilter<"SystemMetrics"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"SystemMetrics">
    collectedAt?: DateTimeWithAggregatesFilter<"SystemMetrics"> | Date | string
  }

  export type DimDateRangeWhereInput = {
    AND?: DimDateRangeWhereInput | DimDateRangeWhereInput[]
    OR?: DimDateRangeWhereInput[]
    NOT?: DimDateRangeWhereInput | DimDateRangeWhereInput[]
    id?: IntFilter<"DimDateRange"> | number
    name?: StringFilter<"DimDateRange"> | string
    startDate?: DateTimeFilter<"DimDateRange"> | Date | string
    endDate?: DateTimeFilter<"DimDateRange"> | Date | string
  }

  export type DimDateRangeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type DimDateRangeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: DimDateRangeWhereInput | DimDateRangeWhereInput[]
    OR?: DimDateRangeWhereInput[]
    NOT?: DimDateRangeWhereInput | DimDateRangeWhereInput[]
    startDate?: DateTimeFilter<"DimDateRange"> | Date | string
    endDate?: DateTimeFilter<"DimDateRange"> | Date | string
  }, "id" | "name">

  export type DimDateRangeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: DimDateRangeCountOrderByAggregateInput
    _avg?: DimDateRangeAvgOrderByAggregateInput
    _max?: DimDateRangeMaxOrderByAggregateInput
    _min?: DimDateRangeMinOrderByAggregateInput
    _sum?: DimDateRangeSumOrderByAggregateInput
  }

  export type DimDateRangeScalarWhereWithAggregatesInput = {
    AND?: DimDateRangeScalarWhereWithAggregatesInput | DimDateRangeScalarWhereWithAggregatesInput[]
    OR?: DimDateRangeScalarWhereWithAggregatesInput[]
    NOT?: DimDateRangeScalarWhereWithAggregatesInput | DimDateRangeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DimDateRange"> | number
    name?: StringWithAggregatesFilter<"DimDateRange"> | string
    startDate?: DateTimeWithAggregatesFilter<"DimDateRange"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"DimDateRange"> | Date | string
  }

  export type OntologyTermWhereInput = {
    AND?: OntologyTermWhereInput | OntologyTermWhereInput[]
    OR?: OntologyTermWhereInput[]
    NOT?: OntologyTermWhereInput | OntologyTermWhereInput[]
    term?: StringFilter<"OntologyTerm"> | string
    modelName?: StringFilter<"OntologyTerm"> | string
    fieldName?: StringFilter<"OntologyTerm"> | string
    priority?: IntFilter<"OntologyTerm"> | number
  }

  export type OntologyTermOrderByWithRelationInput = {
    term?: SortOrder
    modelName?: SortOrder
    fieldName?: SortOrder
    priority?: SortOrder
  }

  export type OntologyTermWhereUniqueInput = Prisma.AtLeast<{
    term?: string
    AND?: OntologyTermWhereInput | OntologyTermWhereInput[]
    OR?: OntologyTermWhereInput[]
    NOT?: OntologyTermWhereInput | OntologyTermWhereInput[]
    modelName?: StringFilter<"OntologyTerm"> | string
    fieldName?: StringFilter<"OntologyTerm"> | string
    priority?: IntFilter<"OntologyTerm"> | number
  }, "term">

  export type OntologyTermOrderByWithAggregationInput = {
    term?: SortOrder
    modelName?: SortOrder
    fieldName?: SortOrder
    priority?: SortOrder
    _count?: OntologyTermCountOrderByAggregateInput
    _avg?: OntologyTermAvgOrderByAggregateInput
    _max?: OntologyTermMaxOrderByAggregateInput
    _min?: OntologyTermMinOrderByAggregateInput
    _sum?: OntologyTermSumOrderByAggregateInput
  }

  export type OntologyTermScalarWhereWithAggregatesInput = {
    AND?: OntologyTermScalarWhereWithAggregatesInput | OntologyTermScalarWhereWithAggregatesInput[]
    OR?: OntologyTermScalarWhereWithAggregatesInput[]
    NOT?: OntologyTermScalarWhereWithAggregatesInput | OntologyTermScalarWhereWithAggregatesInput[]
    term?: StringWithAggregatesFilter<"OntologyTerm"> | string
    modelName?: StringWithAggregatesFilter<"OntologyTerm"> | string
    fieldName?: StringWithAggregatesFilter<"OntologyTerm"> | string
    priority?: IntWithAggregatesFilter<"OntologyTerm"> | number
  }

  export type ViewOeeDailyWhereInput = {
    AND?: ViewOeeDailyWhereInput | ViewOeeDailyWhereInput[]
    OR?: ViewOeeDailyWhereInput[]
    NOT?: ViewOeeDailyWhereInput | ViewOeeDailyWhereInput[]
    dateId?: DateTimeFilter<"ViewOeeDaily"> | Date | string
    shiftId?: IntFilter<"ViewOeeDaily"> | number
    equipmentId?: IntFilter<"ViewOeeDaily"> | number
    availability?: FloatFilter<"ViewOeeDaily"> | number
    performance?: FloatFilter<"ViewOeeDaily"> | number
    quality?: FloatFilter<"ViewOeeDaily"> | number
    oee?: FloatFilter<"ViewOeeDaily"> | number
  }

  export type ViewOeeDailyOrderByWithRelationInput = {
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    availability?: SortOrder
    performance?: SortOrder
    quality?: SortOrder
    oee?: SortOrder
  }

  export type ViewOeeDailyWhereUniqueInput = Prisma.AtLeast<{
    dateId_shiftId_equipmentId?: ViewOeeDailyDateIdShiftIdEquipmentIdCompoundUniqueInput
    AND?: ViewOeeDailyWhereInput | ViewOeeDailyWhereInput[]
    OR?: ViewOeeDailyWhereInput[]
    NOT?: ViewOeeDailyWhereInput | ViewOeeDailyWhereInput[]
    dateId?: DateTimeFilter<"ViewOeeDaily"> | Date | string
    shiftId?: IntFilter<"ViewOeeDaily"> | number
    equipmentId?: IntFilter<"ViewOeeDaily"> | number
    availability?: FloatFilter<"ViewOeeDaily"> | number
    performance?: FloatFilter<"ViewOeeDaily"> | number
    quality?: FloatFilter<"ViewOeeDaily"> | number
    oee?: FloatFilter<"ViewOeeDaily"> | number
  }, "dateId_shiftId_equipmentId">

  export type ViewOeeDailyOrderByWithAggregationInput = {
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    availability?: SortOrder
    performance?: SortOrder
    quality?: SortOrder
    oee?: SortOrder
    _count?: ViewOeeDailyCountOrderByAggregateInput
    _avg?: ViewOeeDailyAvgOrderByAggregateInput
    _max?: ViewOeeDailyMaxOrderByAggregateInput
    _min?: ViewOeeDailyMinOrderByAggregateInput
    _sum?: ViewOeeDailySumOrderByAggregateInput
  }

  export type ViewOeeDailyScalarWhereWithAggregatesInput = {
    AND?: ViewOeeDailyScalarWhereWithAggregatesInput | ViewOeeDailyScalarWhereWithAggregatesInput[]
    OR?: ViewOeeDailyScalarWhereWithAggregatesInput[]
    NOT?: ViewOeeDailyScalarWhereWithAggregatesInput | ViewOeeDailyScalarWhereWithAggregatesInput[]
    dateId?: DateTimeWithAggregatesFilter<"ViewOeeDaily"> | Date | string
    shiftId?: IntWithAggregatesFilter<"ViewOeeDaily"> | number
    equipmentId?: IntWithAggregatesFilter<"ViewOeeDaily"> | number
    availability?: FloatWithAggregatesFilter<"ViewOeeDaily"> | number
    performance?: FloatWithAggregatesFilter<"ViewOeeDaily"> | number
    quality?: FloatWithAggregatesFilter<"ViewOeeDaily"> | number
    oee?: FloatWithAggregatesFilter<"ViewOeeDaily"> | number
  }

  export type ViewReliabilitySummaryWhereInput = {
    AND?: ViewReliabilitySummaryWhereInput | ViewReliabilitySummaryWhereInput[]
    OR?: ViewReliabilitySummaryWhereInput[]
    NOT?: ViewReliabilitySummaryWhereInput | ViewReliabilitySummaryWhereInput[]
    equipmentId?: IntFilter<"ViewReliabilitySummary"> | number
    equipmentCode?: StringFilter<"ViewReliabilitySummary"> | string
    equipmentName?: StringFilter<"ViewReliabilitySummary"> | string
    mtbfHours?: FloatFilter<"ViewReliabilitySummary"> | number
    mttrHours?: FloatFilter<"ViewReliabilitySummary"> | number
    failureCount?: IntFilter<"ViewReliabilitySummary"> | number
  }

  export type ViewReliabilitySummaryOrderByWithRelationInput = {
    equipmentId?: SortOrder
    equipmentCode?: SortOrder
    equipmentName?: SortOrder
    mtbfHours?: SortOrder
    mttrHours?: SortOrder
    failureCount?: SortOrder
  }

  export type ViewReliabilitySummaryWhereUniqueInput = Prisma.AtLeast<{
    equipmentId?: number
    AND?: ViewReliabilitySummaryWhereInput | ViewReliabilitySummaryWhereInput[]
    OR?: ViewReliabilitySummaryWhereInput[]
    NOT?: ViewReliabilitySummaryWhereInput | ViewReliabilitySummaryWhereInput[]
    equipmentCode?: StringFilter<"ViewReliabilitySummary"> | string
    equipmentName?: StringFilter<"ViewReliabilitySummary"> | string
    mtbfHours?: FloatFilter<"ViewReliabilitySummary"> | number
    mttrHours?: FloatFilter<"ViewReliabilitySummary"> | number
    failureCount?: IntFilter<"ViewReliabilitySummary"> | number
  }, "equipmentId">

  export type ViewReliabilitySummaryOrderByWithAggregationInput = {
    equipmentId?: SortOrder
    equipmentCode?: SortOrder
    equipmentName?: SortOrder
    mtbfHours?: SortOrder
    mttrHours?: SortOrder
    failureCount?: SortOrder
    _count?: ViewReliabilitySummaryCountOrderByAggregateInput
    _avg?: ViewReliabilitySummaryAvgOrderByAggregateInput
    _max?: ViewReliabilitySummaryMaxOrderByAggregateInput
    _min?: ViewReliabilitySummaryMinOrderByAggregateInput
    _sum?: ViewReliabilitySummarySumOrderByAggregateInput
  }

  export type ViewReliabilitySummaryScalarWhereWithAggregatesInput = {
    AND?: ViewReliabilitySummaryScalarWhereWithAggregatesInput | ViewReliabilitySummaryScalarWhereWithAggregatesInput[]
    OR?: ViewReliabilitySummaryScalarWhereWithAggregatesInput[]
    NOT?: ViewReliabilitySummaryScalarWhereWithAggregatesInput | ViewReliabilitySummaryScalarWhereWithAggregatesInput[]
    equipmentId?: IntWithAggregatesFilter<"ViewReliabilitySummary"> | number
    equipmentCode?: StringWithAggregatesFilter<"ViewReliabilitySummary"> | string
    equipmentName?: StringWithAggregatesFilter<"ViewReliabilitySummary"> | string
    mtbfHours?: FloatWithAggregatesFilter<"ViewReliabilitySummary"> | number
    mttrHours?: FloatWithAggregatesFilter<"ViewReliabilitySummary"> | number
    failureCount?: IntWithAggregatesFilter<"ViewReliabilitySummary"> | number
  }

  export type ViewScrapSummaryWhereInput = {
    AND?: ViewScrapSummaryWhereInput | ViewScrapSummaryWhereInput[]
    OR?: ViewScrapSummaryWhereInput[]
    NOT?: ViewScrapSummaryWhereInput | ViewScrapSummaryWhereInput[]
    dateId?: DateTimeFilter<"ViewScrapSummary"> | Date | string
    equipmentId?: IntFilter<"ViewScrapSummary"> | number
    productId?: IntFilter<"ViewScrapSummary"> | number
    scrapCode?: StringFilter<"ViewScrapSummary"> | string
    scrapReason?: StringNullableFilter<"ViewScrapSummary"> | string | null
    totalScrapQty?: IntFilter<"ViewScrapSummary"> | number
    scrapIncidents?: IntFilter<"ViewScrapSummary"> | number
    scrapCost?: DecimalNullableFilter<"ViewScrapSummary"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ViewScrapSummaryOrderByWithRelationInput = {
    dateId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapReason?: SortOrderInput | SortOrder
    totalScrapQty?: SortOrder
    scrapIncidents?: SortOrder
    scrapCost?: SortOrderInput | SortOrder
  }

  export type ViewScrapSummaryWhereUniqueInput = Prisma.AtLeast<{
    dateId_equipmentId_productId_scrapCode?: ViewScrapSummaryDateIdEquipmentIdProductIdScrapCodeCompoundUniqueInput
    AND?: ViewScrapSummaryWhereInput | ViewScrapSummaryWhereInput[]
    OR?: ViewScrapSummaryWhereInput[]
    NOT?: ViewScrapSummaryWhereInput | ViewScrapSummaryWhereInput[]
    dateId?: DateTimeFilter<"ViewScrapSummary"> | Date | string
    equipmentId?: IntFilter<"ViewScrapSummary"> | number
    productId?: IntFilter<"ViewScrapSummary"> | number
    scrapCode?: StringFilter<"ViewScrapSummary"> | string
    scrapReason?: StringNullableFilter<"ViewScrapSummary"> | string | null
    totalScrapQty?: IntFilter<"ViewScrapSummary"> | number
    scrapIncidents?: IntFilter<"ViewScrapSummary"> | number
    scrapCost?: DecimalNullableFilter<"ViewScrapSummary"> | Decimal | DecimalJsLike | number | string | null
  }, "dateId_equipmentId_productId_scrapCode">

  export type ViewScrapSummaryOrderByWithAggregationInput = {
    dateId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapReason?: SortOrderInput | SortOrder
    totalScrapQty?: SortOrder
    scrapIncidents?: SortOrder
    scrapCost?: SortOrderInput | SortOrder
    _count?: ViewScrapSummaryCountOrderByAggregateInput
    _avg?: ViewScrapSummaryAvgOrderByAggregateInput
    _max?: ViewScrapSummaryMaxOrderByAggregateInput
    _min?: ViewScrapSummaryMinOrderByAggregateInput
    _sum?: ViewScrapSummarySumOrderByAggregateInput
  }

  export type ViewScrapSummaryScalarWhereWithAggregatesInput = {
    AND?: ViewScrapSummaryScalarWhereWithAggregatesInput | ViewScrapSummaryScalarWhereWithAggregatesInput[]
    OR?: ViewScrapSummaryScalarWhereWithAggregatesInput[]
    NOT?: ViewScrapSummaryScalarWhereWithAggregatesInput | ViewScrapSummaryScalarWhereWithAggregatesInput[]
    dateId?: DateTimeWithAggregatesFilter<"ViewScrapSummary"> | Date | string
    equipmentId?: IntWithAggregatesFilter<"ViewScrapSummary"> | number
    productId?: IntWithAggregatesFilter<"ViewScrapSummary"> | number
    scrapCode?: StringWithAggregatesFilter<"ViewScrapSummary"> | string
    scrapReason?: StringNullableWithAggregatesFilter<"ViewScrapSummary"> | string | null
    totalScrapQty?: IntWithAggregatesFilter<"ViewScrapSummary"> | number
    scrapIncidents?: IntWithAggregatesFilter<"ViewScrapSummary"> | number
    scrapCost?: DecimalNullableWithAggregatesFilter<"ViewScrapSummary"> | Decimal | DecimalJsLike | number | string | null
  }

  export type DimSiteCreateInput = {
    code: string
    name: string
    timezone?: string | null
    areas?: DimAreaCreateNestedManyWithoutSiteInput
    shifts?: DimShiftCreateNestedManyWithoutSiteInput
  }

  export type DimSiteUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    timezone?: string | null
    areas?: DimAreaUncheckedCreateNestedManyWithoutSiteInput
    shifts?: DimShiftUncheckedCreateNestedManyWithoutSiteInput
  }

  export type DimSiteUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    areas?: DimAreaUpdateManyWithoutSiteNestedInput
    shifts?: DimShiftUpdateManyWithoutSiteNestedInput
  }

  export type DimSiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    areas?: DimAreaUncheckedUpdateManyWithoutSiteNestedInput
    shifts?: DimShiftUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type DimSiteCreateManyInput = {
    id?: number
    code: string
    name: string
    timezone?: string | null
  }

  export type DimSiteUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DimSiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DimAreaCreateInput = {
    code: string
    name: string
    site: DimSiteCreateNestedOneWithoutAreasInput
    workCenters?: DimWorkCenterCreateNestedManyWithoutAreaInput
  }

  export type DimAreaUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    siteId: number
    workCenters?: DimWorkCenterUncheckedCreateNestedManyWithoutAreaInput
  }

  export type DimAreaUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    site?: DimSiteUpdateOneRequiredWithoutAreasNestedInput
    workCenters?: DimWorkCenterUpdateManyWithoutAreaNestedInput
  }

  export type DimAreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
    workCenters?: DimWorkCenterUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type DimAreaCreateManyInput = {
    id?: number
    code: string
    name: string
    siteId: number
  }

  export type DimAreaUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DimAreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type DimWorkCenterCreateInput = {
    code: string
    name: string
    capacity?: Decimal | DecimalJsLike | number | string | null
    capacityUnit?: string | null
    area: DimAreaCreateNestedOneWithoutWorkCentersInput
    equipment?: DimEquipmentCreateNestedManyWithoutWorkCenterInput
  }

  export type DimWorkCenterUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    areaId: number
    capacity?: Decimal | DecimalJsLike | number | string | null
    capacityUnit?: string | null
    equipment?: DimEquipmentUncheckedCreateNestedManyWithoutWorkCenterInput
  }

  export type DimWorkCenterUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    area?: DimAreaUpdateOneRequiredWithoutWorkCentersNestedInput
    equipment?: DimEquipmentUpdateManyWithoutWorkCenterNestedInput
  }

  export type DimWorkCenterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: DimEquipmentUncheckedUpdateManyWithoutWorkCenterNestedInput
  }

  export type DimWorkCenterCreateManyInput = {
    id?: number
    code: string
    name: string
    areaId: number
    capacity?: Decimal | DecimalJsLike | number | string | null
    capacityUnit?: string | null
  }

  export type DimWorkCenterUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DimWorkCenterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DimEquipmentCreateInput = {
    code: string
    name: string
    type?: string | null
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    workCenter: DimWorkCenterCreateNestedOneWithoutEquipmentInput
    production?: FactProductionCreateNestedManyWithoutEquipmentInput
    downtime?: FactDowntimeCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    type?: string | null
    workCenterId: number
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    production?: FactProductionUncheckedCreateNestedManyWithoutEquipmentInput
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workCenter?: DimWorkCenterUpdateOneRequiredWithoutEquipmentNestedInput
    production?: FactProductionUpdateManyWithoutEquipmentNestedInput
    downtime?: FactDowntimeUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workCenterId?: IntFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    production?: FactProductionUncheckedUpdateManyWithoutEquipmentNestedInput
    downtime?: FactDowntimeUncheckedUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentCreateManyInput = {
    id?: number
    code: string
    name: string
    type?: string | null
    workCenterId: number
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimEquipmentUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimEquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workCenterId?: IntFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DimProductCreateInput = {
    code: string
    name: string
    family?: string | null
    unitOfMeasure?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: bigint | number | null
    production?: FactProductionCreateNestedManyWithoutProductInput
    scrap?: FactScrapCreateNestedManyWithoutProductInput
  }

  export type DimProductUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    family?: string | null
    unitOfMeasure?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: bigint | number | null
    production?: FactProductionUncheckedCreateNestedManyWithoutProductInput
    scrap?: FactScrapUncheckedCreateNestedManyWithoutProductInput
  }

  export type DimProductUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    family?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    production?: FactProductionUpdateManyWithoutProductNestedInput
    scrap?: FactScrapUpdateManyWithoutProductNestedInput
  }

  export type DimProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    family?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    production?: FactProductionUncheckedUpdateManyWithoutProductNestedInput
    scrap?: FactScrapUncheckedUpdateManyWithoutProductNestedInput
  }

  export type DimProductCreateManyInput = {
    id?: number
    code: string
    name: string
    family?: string | null
    unitOfMeasure?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: bigint | number | null
  }

  export type DimProductUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    family?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type DimProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    family?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type DimShiftCreateInput = {
    name: string
    startTime: string
    endTime: string
    breakMinutes?: number | null
    isActive?: boolean | null
    site: DimSiteCreateNestedOneWithoutShiftsInput
    production?: FactProductionCreateNestedManyWithoutShiftInput
  }

  export type DimShiftUncheckedCreateInput = {
    id?: number
    siteId: number
    name: string
    startTime: string
    endTime: string
    breakMinutes?: number | null
    isActive?: boolean | null
    production?: FactProductionUncheckedCreateNestedManyWithoutShiftInput
  }

  export type DimShiftUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    site?: DimSiteUpdateOneRequiredWithoutShiftsNestedInput
    production?: FactProductionUpdateManyWithoutShiftNestedInput
  }

  export type DimShiftUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    production?: FactProductionUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type DimShiftCreateManyInput = {
    id?: number
    siteId: number
    name: string
    startTime: string
    endTime: string
    breakMinutes?: number | null
    isActive?: boolean | null
  }

  export type DimShiftUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DimShiftUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DimDowntimeReasonCreateInput = {
    code: string
    description: string
    category: string
    isPlanned?: boolean | null
    affectsOee?: boolean | null
    isFailure?: boolean | null
    downtime?: FactDowntimeCreateNestedManyWithoutReasonInput
  }

  export type DimDowntimeReasonUncheckedCreateInput = {
    id?: number
    code: string
    description: string
    category: string
    isPlanned?: boolean | null
    affectsOee?: boolean | null
    isFailure?: boolean | null
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutReasonInput
  }

  export type DimDowntimeReasonUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isPlanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectsOee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFailure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    downtime?: FactDowntimeUpdateManyWithoutReasonNestedInput
  }

  export type DimDowntimeReasonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isPlanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectsOee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFailure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    downtime?: FactDowntimeUncheckedUpdateManyWithoutReasonNestedInput
  }

  export type DimDowntimeReasonCreateManyInput = {
    id?: number
    code: string
    description: string
    category: string
    isPlanned?: boolean | null
    affectsOee?: boolean | null
    isFailure?: boolean | null
  }

  export type DimDowntimeReasonUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isPlanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectsOee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFailure?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DimDowntimeReasonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isPlanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectsOee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFailure?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DimUnitCreateInput = {
    code: string
    name: string
    type: string
    sensorEvents?: FactSensorEventCreateNestedManyWithoutUnitInput
  }

  export type DimUnitUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    type: string
    sensorEvents?: FactSensorEventUncheckedCreateNestedManyWithoutUnitInput
  }

  export type DimUnitUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sensorEvents?: FactSensorEventUpdateManyWithoutUnitNestedInput
  }

  export type DimUnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sensorEvents?: FactSensorEventUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type DimUnitCreateManyInput = {
    id?: number
    code: string
    name: string
    type: string
  }

  export type DimUnitUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DimUnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type FactProductionCreateInput = {
    dateId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutProductionInput
    product: DimProductCreateNestedOneWithoutProductionInput
    shift: DimShiftCreateNestedOneWithoutProductionInput
    downtime?: FactDowntimeCreateNestedManyWithoutProductionInput
    scrap?: FactScrapCreateNestedManyWithoutProductionInput
  }

  export type FactProductionUncheckedCreateInput = {
    id?: number
    dateId: number
    shiftId: number
    equipmentId: number
    productId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutProductionInput
    scrap?: FactScrapUncheckedCreateNestedManyWithoutProductionInput
  }

  export type FactProductionUpdateInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutProductionNestedInput
    product?: DimProductUpdateOneRequiredWithoutProductionNestedInput
    shift?: DimShiftUpdateOneRequiredWithoutProductionNestedInput
    downtime?: FactDowntimeUpdateManyWithoutProductionNestedInput
    scrap?: FactScrapUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downtime?: FactDowntimeUncheckedUpdateManyWithoutProductionNestedInput
    scrap?: FactScrapUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionCreateManyInput = {
    id?: number
    dateId: number
    shiftId: number
    equipmentId: number
    productId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
  }

  export type FactProductionUpdateManyMutationInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactProductionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactDowntimeCreateInput = {
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutDowntimeInput
    reason: DimDowntimeReasonCreateNestedOneWithoutDowntimeInput
    production?: FactProductionCreateNestedOneWithoutDowntimeInput
  }

  export type FactDowntimeUncheckedCreateInput = {
    id?: number
    productionId?: number | null
    equipmentId: number
    reasonId: number
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
  }

  export type FactDowntimeUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutDowntimeNestedInput
    reason?: DimDowntimeReasonUpdateOneRequiredWithoutDowntimeNestedInput
    production?: FactProductionUpdateOneWithoutDowntimeNestedInput
  }

  export type FactDowntimeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentId?: IntFieldUpdateOperationsInput | number
    reasonId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactDowntimeCreateManyInput = {
    id?: number
    productionId?: number | null
    equipmentId: number
    reasonId: number
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
  }

  export type FactDowntimeUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactDowntimeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentId?: IntFieldUpdateOperationsInput | number
    reasonId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactScrapCreateInput = {
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    product: DimProductCreateNestedOneWithoutScrapInput
    production: FactProductionCreateNestedOneWithoutScrapInput
  }

  export type FactScrapUncheckedCreateInput = {
    id?: number
    productionId: number
    productId: number
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
  }

  export type FactScrapUpdateInput = {
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: DimProductUpdateOneRequiredWithoutScrapNestedInput
    production?: FactProductionUpdateOneRequiredWithoutScrapNestedInput
  }

  export type FactScrapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactScrapCreateManyInput = {
    id?: number
    productionId: number
    productId: number
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
  }

  export type FactScrapUpdateManyMutationInput = {
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactScrapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactMaintenanceCreateInput = {
    workOrderNumber: string
    maintenanceType: string
    startTime: Date | string
    endTime: Date | string
    laborHours?: Decimal | DecimalJsLike | number | string | null
    materialCost?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutMaintenanceInput
  }

  export type FactMaintenanceUncheckedCreateInput = {
    id?: number
    equipmentId: number
    workOrderNumber: string
    maintenanceType: string
    startTime: Date | string
    endTime: Date | string
    laborHours?: Decimal | DecimalJsLike | number | string | null
    materialCost?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    createdAt?: Date | string | null
  }

  export type FactMaintenanceUpdateInput = {
    workOrderNumber?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    laborHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    materialCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutMaintenanceNestedInput
  }

  export type FactMaintenanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    workOrderNumber?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    laborHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    materialCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactMaintenanceCreateManyInput = {
    id?: number
    equipmentId: number
    workOrderNumber: string
    maintenanceType: string
    startTime: Date | string
    endTime: Date | string
    laborHours?: Decimal | DecimalJsLike | number | string | null
    materialCost?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    createdAt?: Date | string | null
  }

  export type FactMaintenanceUpdateManyMutationInput = {
    workOrderNumber?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    laborHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    materialCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactMaintenanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    workOrderNumber?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    laborHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    materialCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactSensorEventCreateInput = {
    eventId?: bigint | number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
    equipment: DimEquipmentCreateNestedOneWithoutSensorEventsInput
    unit?: DimUnitCreateNestedOneWithoutSensorEventsInput
  }

  export type FactSensorEventUncheckedCreateInput = {
    eventId?: bigint | number
    equipmentId: number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
    unitId?: number | null
  }

  export type FactSensorEventUpdateInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipment?: DimEquipmentUpdateOneRequiredWithoutSensorEventsNestedInput
    unit?: DimUnitUpdateOneWithoutSensorEventsNestedInput
  }

  export type FactSensorEventUncheckedUpdateInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FactSensorEventCreateManyInput = {
    eventId?: bigint | number
    equipmentId: number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
    unitId?: number | null
  }

  export type FactSensorEventUpdateManyMutationInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FactSensorEventUncheckedUpdateManyInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogCreateInput = {
    id?: bigint | number
    username?: string | null
    action: string
    tableName: string
    recordId: string
    logTs?: Date | string | null
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogUncheckedCreateInput = {
    id?: bigint | number
    username?: string | null
    action: string
    tableName: string
    recordId: string
    logTs?: Date | string | null
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    logTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    logTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogCreateManyInput = {
    id?: bigint | number
    username?: string | null
    action: string
    tableName: string
    recordId: string
    logTs?: Date | string | null
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    logTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    logTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventCreateInput = {
    id?: bigint | number
    eventType: string
    aggregateId: string
    aggregateType: string
    eventData: JsonNullValueInput | InputJsonValue
    eventMetadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    correlationId?: string | null
    causationId?: string | null
    createdAt?: Date | string
  }

  export type AuditEventUncheckedCreateInput = {
    id?: bigint | number
    eventType: string
    aggregateId: string
    aggregateType: string
    eventData: JsonNullValueInput | InputJsonValue
    eventMetadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    correlationId?: string | null
    causationId?: string | null
    createdAt?: Date | string
  }

  export type AuditEventUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    aggregateId?: StringFieldUpdateOperationsInput | string
    aggregateType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    eventMetadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    causationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    aggregateId?: StringFieldUpdateOperationsInput | string
    aggregateType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    eventMetadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    causationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateManyInput = {
    id?: bigint | number
    eventType: string
    aggregateId: string
    aggregateType: string
    eventData: JsonNullValueInput | InputJsonValue
    eventMetadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    correlationId?: string | null
    causationId?: string | null
    createdAt?: Date | string
  }

  export type AuditEventUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    aggregateId?: StringFieldUpdateOperationsInput | string
    aggregateType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    eventMetadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    causationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    aggregateId?: StringFieldUpdateOperationsInput | string
    aggregateType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    eventMetadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    causationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataDictionaryCreateInput = {
    schemaName: string
    tableName: string
    columnName: string
    dataType: string
    isNullable: boolean
    description?: string | null
    businessName?: string | null
    dataSteward?: string | null
    classification?: string | null
    piiFlag?: boolean | null
    retentionDays?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataDictionaryUncheckedCreateInput = {
    id?: number
    schemaName: string
    tableName: string
    columnName: string
    dataType: string
    isNullable: boolean
    description?: string | null
    businessName?: string | null
    dataSteward?: string | null
    classification?: string | null
    piiFlag?: boolean | null
    retentionDays?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataDictionaryUpdateInput = {
    schemaName?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    dataSteward?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    piiFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataDictionaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemaName?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    dataSteward?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    piiFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataDictionaryCreateManyInput = {
    id?: number
    schemaName: string
    tableName: string
    columnName: string
    dataType: string
    isNullable: boolean
    description?: string | null
    businessName?: string | null
    dataSteward?: string | null
    classification?: string | null
    piiFlag?: boolean | null
    retentionDays?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DataDictionaryUpdateManyMutationInput = {
    schemaName?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    dataSteward?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    piiFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataDictionaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemaName?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    dataSteward?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    piiFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRetentionPolicyCreateInput = {
    tableName: string
    retentionDays: number
    archiveEnabled?: boolean | null
    archiveTableName?: string | null
    lastArchived?: Date | string | null
    createdAt?: Date | string | null
  }

  export type DataRetentionPolicyUncheckedCreateInput = {
    id?: number
    tableName: string
    retentionDays: number
    archiveEnabled?: boolean | null
    archiveTableName?: string | null
    lastArchived?: Date | string | null
    createdAt?: Date | string | null
  }

  export type DataRetentionPolicyUpdateInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    retentionDays?: IntFieldUpdateOperationsInput | number
    archiveEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    archiveTableName?: NullableStringFieldUpdateOperationsInput | string | null
    lastArchived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRetentionPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    retentionDays?: IntFieldUpdateOperationsInput | number
    archiveEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    archiveTableName?: NullableStringFieldUpdateOperationsInput | string | null
    lastArchived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRetentionPolicyCreateManyInput = {
    id?: number
    tableName: string
    retentionDays: number
    archiveEnabled?: boolean | null
    archiveTableName?: string | null
    lastArchived?: Date | string | null
    createdAt?: Date | string | null
  }

  export type DataRetentionPolicyUpdateManyMutationInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    retentionDays?: IntFieldUpdateOperationsInput | number
    archiveEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    archiveTableName?: NullableStringFieldUpdateOperationsInput | string | null
    lastArchived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataRetentionPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    retentionDays?: IntFieldUpdateOperationsInput | number
    archiveEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    archiveTableName?: NullableStringFieldUpdateOperationsInput | string | null
    lastArchived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QueryPerformanceCreateInput = {
    queryHash: string
    queryText?: string | null
    totalTime: Decimal | DecimalJsLike | number | string
    meanTime: Decimal | DecimalJsLike | number | string
    maxTime: Decimal | DecimalJsLike | number | string
    minTime: Decimal | DecimalJsLike | number | string
    calls: bigint | number
    rows: bigint | number
    capturedAt?: Date | string
  }

  export type QueryPerformanceUncheckedCreateInput = {
    id?: number
    queryHash: string
    queryText?: string | null
    totalTime: Decimal | DecimalJsLike | number | string
    meanTime: Decimal | DecimalJsLike | number | string
    maxTime: Decimal | DecimalJsLike | number | string
    minTime: Decimal | DecimalJsLike | number | string
    calls: bigint | number
    rows: bigint | number
    capturedAt?: Date | string
  }

  export type QueryPerformanceUpdateInput = {
    queryHash?: StringFieldUpdateOperationsInput | string
    queryText?: NullableStringFieldUpdateOperationsInput | string | null
    totalTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meanTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calls?: BigIntFieldUpdateOperationsInput | bigint | number
    rows?: BigIntFieldUpdateOperationsInput | bigint | number
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryPerformanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    queryHash?: StringFieldUpdateOperationsInput | string
    queryText?: NullableStringFieldUpdateOperationsInput | string | null
    totalTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meanTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calls?: BigIntFieldUpdateOperationsInput | bigint | number
    rows?: BigIntFieldUpdateOperationsInput | bigint | number
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryPerformanceCreateManyInput = {
    id?: number
    queryHash: string
    queryText?: string | null
    totalTime: Decimal | DecimalJsLike | number | string
    meanTime: Decimal | DecimalJsLike | number | string
    maxTime: Decimal | DecimalJsLike | number | string
    minTime: Decimal | DecimalJsLike | number | string
    calls: bigint | number
    rows: bigint | number
    capturedAt?: Date | string
  }

  export type QueryPerformanceUpdateManyMutationInput = {
    queryHash?: StringFieldUpdateOperationsInput | string
    queryText?: NullableStringFieldUpdateOperationsInput | string | null
    totalTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meanTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calls?: BigIntFieldUpdateOperationsInput | bigint | number
    rows?: BigIntFieldUpdateOperationsInput | bigint | number
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryPerformanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    queryHash?: StringFieldUpdateOperationsInput | string
    queryText?: NullableStringFieldUpdateOperationsInput | string | null
    totalTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meanTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minTime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calls?: BigIntFieldUpdateOperationsInput | bigint | number
    rows?: BigIntFieldUpdateOperationsInput | bigint | number
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityScoresCreateInput = {
    tableName: string
    checkName: string
    checkType: string
    passed: boolean
    score: Decimal | DecimalJsLike | number | string
    totalRows?: bigint | number | null
    failedRows?: bigint | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: Date | string
  }

  export type DataQualityScoresUncheckedCreateInput = {
    id?: number
    tableName: string
    checkName: string
    checkType: string
    passed: boolean
    score: Decimal | DecimalJsLike | number | string
    totalRows?: bigint | number | null
    failedRows?: bigint | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: Date | string
  }

  export type DataQualityScoresUpdateInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    checkName?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRows?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failedRows?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityScoresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    checkName?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRows?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failedRows?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityScoresCreateManyInput = {
    id?: number
    tableName: string
    checkName: string
    checkType: string
    passed: boolean
    score: Decimal | DecimalJsLike | number | string
    totalRows?: bigint | number | null
    failedRows?: bigint | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: Date | string
  }

  export type DataQualityScoresUpdateManyMutationInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    checkName?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRows?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failedRows?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataQualityScoresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    checkName?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRows?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failedRows?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricsCreateInput = {
    metricType: string
    metricName: string
    metricValue: Decimal | DecimalJsLike | number | string
    metricUnit?: string | null
    hostName?: string | null
    serviceName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    collectedAt?: Date | string
  }

  export type SystemMetricsUncheckedCreateInput = {
    id?: number
    metricType: string
    metricName: string
    metricValue: Decimal | DecimalJsLike | number | string
    metricUnit?: string | null
    hostName?: string | null
    serviceName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    collectedAt?: Date | string
  }

  export type SystemMetricsUpdateInput = {
    metricType?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    metricType?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricsCreateManyInput = {
    id?: number
    metricType: string
    metricName: string
    metricValue: Decimal | DecimalJsLike | number | string
    metricUnit?: string | null
    hostName?: string | null
    serviceName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    collectedAt?: Date | string
  }

  export type SystemMetricsUpdateManyMutationInput = {
    metricType?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    metricType?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    collectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DimDateRangeCreateInput = {
    name: string
    startDate: Date | string
    endDate: Date | string
  }

  export type DimDateRangeUncheckedCreateInput = {
    id?: number
    name: string
    startDate: Date | string
    endDate: Date | string
  }

  export type DimDateRangeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DimDateRangeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DimDateRangeCreateManyInput = {
    id?: number
    name: string
    startDate: Date | string
    endDate: Date | string
  }

  export type DimDateRangeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DimDateRangeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OntologyTermCreateInput = {
    term: string
    modelName: string
    fieldName: string
    priority?: number
  }

  export type OntologyTermUncheckedCreateInput = {
    term: string
    modelName: string
    fieldName: string
    priority?: number
  }

  export type OntologyTermUpdateInput = {
    term?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type OntologyTermUncheckedUpdateInput = {
    term?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type OntologyTermCreateManyInput = {
    term: string
    modelName: string
    fieldName: string
    priority?: number
  }

  export type OntologyTermUpdateManyMutationInput = {
    term?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type OntologyTermUncheckedUpdateManyInput = {
    term?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type ViewOeeDailyCreateInput = {
    dateId: Date | string
    shiftId: number
    equipmentId: number
    availability: number
    performance: number
    quality: number
    oee: number
  }

  export type ViewOeeDailyUncheckedCreateInput = {
    dateId: Date | string
    shiftId: number
    equipmentId: number
    availability: number
    performance: number
    quality: number
    oee: number
  }

  export type ViewOeeDailyUpdateInput = {
    dateId?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    availability?: FloatFieldUpdateOperationsInput | number
    performance?: FloatFieldUpdateOperationsInput | number
    quality?: FloatFieldUpdateOperationsInput | number
    oee?: FloatFieldUpdateOperationsInput | number
  }

  export type ViewOeeDailyUncheckedUpdateInput = {
    dateId?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    availability?: FloatFieldUpdateOperationsInput | number
    performance?: FloatFieldUpdateOperationsInput | number
    quality?: FloatFieldUpdateOperationsInput | number
    oee?: FloatFieldUpdateOperationsInput | number
  }

  export type ViewOeeDailyCreateManyInput = {
    dateId: Date | string
    shiftId: number
    equipmentId: number
    availability: number
    performance: number
    quality: number
    oee: number
  }

  export type ViewOeeDailyUpdateManyMutationInput = {
    dateId?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    availability?: FloatFieldUpdateOperationsInput | number
    performance?: FloatFieldUpdateOperationsInput | number
    quality?: FloatFieldUpdateOperationsInput | number
    oee?: FloatFieldUpdateOperationsInput | number
  }

  export type ViewOeeDailyUncheckedUpdateManyInput = {
    dateId?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    availability?: FloatFieldUpdateOperationsInput | number
    performance?: FloatFieldUpdateOperationsInput | number
    quality?: FloatFieldUpdateOperationsInput | number
    oee?: FloatFieldUpdateOperationsInput | number
  }

  export type ViewReliabilitySummaryCreateInput = {
    equipmentId: number
    equipmentCode: string
    equipmentName: string
    mtbfHours: number
    mttrHours: number
    failureCount: number
  }

  export type ViewReliabilitySummaryUncheckedCreateInput = {
    equipmentId: number
    equipmentCode: string
    equipmentName: string
    mtbfHours: number
    mttrHours: number
    failureCount: number
  }

  export type ViewReliabilitySummaryUpdateInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    equipmentCode?: StringFieldUpdateOperationsInput | string
    equipmentName?: StringFieldUpdateOperationsInput | string
    mtbfHours?: FloatFieldUpdateOperationsInput | number
    mttrHours?: FloatFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
  }

  export type ViewReliabilitySummaryUncheckedUpdateInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    equipmentCode?: StringFieldUpdateOperationsInput | string
    equipmentName?: StringFieldUpdateOperationsInput | string
    mtbfHours?: FloatFieldUpdateOperationsInput | number
    mttrHours?: FloatFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
  }

  export type ViewReliabilitySummaryCreateManyInput = {
    equipmentId: number
    equipmentCode: string
    equipmentName: string
    mtbfHours: number
    mttrHours: number
    failureCount: number
  }

  export type ViewReliabilitySummaryUpdateManyMutationInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    equipmentCode?: StringFieldUpdateOperationsInput | string
    equipmentName?: StringFieldUpdateOperationsInput | string
    mtbfHours?: FloatFieldUpdateOperationsInput | number
    mttrHours?: FloatFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
  }

  export type ViewReliabilitySummaryUncheckedUpdateManyInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    equipmentCode?: StringFieldUpdateOperationsInput | string
    equipmentName?: StringFieldUpdateOperationsInput | string
    mtbfHours?: FloatFieldUpdateOperationsInput | number
    mttrHours?: FloatFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
  }

  export type ViewScrapSummaryCreateInput = {
    dateId: Date | string
    equipmentId: number
    productId: number
    scrapCode: string
    scrapReason?: string | null
    totalScrapQty: number
    scrapIncidents: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type ViewScrapSummaryUncheckedCreateInput = {
    dateId: Date | string
    equipmentId: number
    productId: number
    scrapCode: string
    scrapReason?: string | null
    totalScrapQty: number
    scrapIncidents: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type ViewScrapSummaryUpdateInput = {
    dateId?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalScrapQty?: IntFieldUpdateOperationsInput | number
    scrapIncidents?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ViewScrapSummaryUncheckedUpdateInput = {
    dateId?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalScrapQty?: IntFieldUpdateOperationsInput | number
    scrapIncidents?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ViewScrapSummaryCreateManyInput = {
    dateId: Date | string
    equipmentId: number
    productId: number
    scrapCode: string
    scrapReason?: string | null
    totalScrapQty: number
    scrapIncidents: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type ViewScrapSummaryUpdateManyMutationInput = {
    dateId?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalScrapQty?: IntFieldUpdateOperationsInput | number
    scrapIncidents?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ViewScrapSummaryUncheckedUpdateManyInput = {
    dateId?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalScrapQty?: IntFieldUpdateOperationsInput | number
    scrapIncidents?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DimAreaListRelationFilter = {
    every?: DimAreaWhereInput
    some?: DimAreaWhereInput
    none?: DimAreaWhereInput
  }

  export type DimShiftListRelationFilter = {
    every?: DimShiftWhereInput
    some?: DimShiftWhereInput
    none?: DimShiftWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DimAreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimSiteCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    timezone?: SortOrder
  }

  export type DimSiteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DimSiteMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    timezone?: SortOrder
  }

  export type DimSiteMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    timezone?: SortOrder
  }

  export type DimSiteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DimSiteRelationFilter = {
    is?: DimSiteWhereInput
    isNot?: DimSiteWhereInput
  }

  export type DimWorkCenterListRelationFilter = {
    every?: DimWorkCenterWhereInput
    some?: DimWorkCenterWhereInput
    none?: DimWorkCenterWhereInput
  }

  export type DimWorkCenterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimAreaCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    siteId?: SortOrder
  }

  export type DimAreaAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
  }

  export type DimAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    siteId?: SortOrder
  }

  export type DimAreaMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    siteId?: SortOrder
  }

  export type DimAreaSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DimAreaRelationFilter = {
    is?: DimAreaWhereInput
    isNot?: DimAreaWhereInput
  }

  export type DimEquipmentListRelationFilter = {
    every?: DimEquipmentWhereInput
    some?: DimEquipmentWhereInput
    none?: DimEquipmentWhereInput
  }

  export type DimEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimWorkCenterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    areaId?: SortOrder
    capacity?: SortOrder
    capacityUnit?: SortOrder
  }

  export type DimWorkCenterAvgOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
    capacity?: SortOrder
  }

  export type DimWorkCenterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    areaId?: SortOrder
    capacity?: SortOrder
    capacityUnit?: SortOrder
  }

  export type DimWorkCenterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    areaId?: SortOrder
    capacity?: SortOrder
    capacityUnit?: SortOrder
  }

  export type DimWorkCenterSumOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
    capacity?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DimWorkCenterRelationFilter = {
    is?: DimWorkCenterWhereInput
    isNot?: DimWorkCenterWhereInput
  }

  export type FactProductionListRelationFilter = {
    every?: FactProductionWhereInput
    some?: FactProductionWhereInput
    none?: FactProductionWhereInput
  }

  export type FactDowntimeListRelationFilter = {
    every?: FactDowntimeWhereInput
    some?: FactDowntimeWhereInput
    none?: FactDowntimeWhereInput
  }

  export type FactMaintenanceListRelationFilter = {
    every?: FactMaintenanceWhereInput
    some?: FactMaintenanceWhereInput
    none?: FactMaintenanceWhereInput
  }

  export type FactSensorEventListRelationFilter = {
    every?: FactSensorEventWhereInput
    some?: FactSensorEventWhereInput
    none?: FactSensorEventWhereInput
  }

  export type FactProductionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FactDowntimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FactMaintenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FactSensorEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    workCenterId?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    installationDate?: SortOrder
    criticalityLevel?: SortOrder
    theoreticalRate?: SortOrder
    attributes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimEquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    workCenterId?: SortOrder
    theoreticalRate?: SortOrder
  }

  export type DimEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    workCenterId?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    installationDate?: SortOrder
    criticalityLevel?: SortOrder
    theoreticalRate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    workCenterId?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    installationDate?: SortOrder
    criticalityLevel?: SortOrder
    theoreticalRate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DimEquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    workCenterId?: SortOrder
    theoreticalRate?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type FactScrapListRelationFilter = {
    every?: FactScrapWhereInput
    some?: FactScrapWhereInput
    none?: FactScrapWhereInput
  }

  export type FactScrapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DimProductCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    family?: SortOrder
    unitOfMeasure?: SortOrder
    standardCost?: SortOrder
    targetCycleTime?: SortOrder
  }

  export type DimProductAvgOrderByAggregateInput = {
    id?: SortOrder
    standardCost?: SortOrder
    targetCycleTime?: SortOrder
  }

  export type DimProductMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    family?: SortOrder
    unitOfMeasure?: SortOrder
    standardCost?: SortOrder
    targetCycleTime?: SortOrder
  }

  export type DimProductMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    family?: SortOrder
    unitOfMeasure?: SortOrder
    standardCost?: SortOrder
    targetCycleTime?: SortOrder
  }

  export type DimProductSumOrderByAggregateInput = {
    id?: SortOrder
    standardCost?: SortOrder
    targetCycleTime?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DimShiftSiteIdNameCompoundUniqueInput = {
    siteId: number
    name: string
  }

  export type DimShiftCountOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakMinutes?: SortOrder
    isActive?: SortOrder
  }

  export type DimShiftAvgOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    breakMinutes?: SortOrder
  }

  export type DimShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakMinutes?: SortOrder
    isActive?: SortOrder
  }

  export type DimShiftMinOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakMinutes?: SortOrder
    isActive?: SortOrder
  }

  export type DimShiftSumOrderByAggregateInput = {
    id?: SortOrder
    siteId?: SortOrder
    breakMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DimDowntimeReasonCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPlanned?: SortOrder
    affectsOee?: SortOrder
    isFailure?: SortOrder
  }

  export type DimDowntimeReasonAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DimDowntimeReasonMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPlanned?: SortOrder
    affectsOee?: SortOrder
    isFailure?: SortOrder
  }

  export type DimDowntimeReasonMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPlanned?: SortOrder
    affectsOee?: SortOrder
    isFailure?: SortOrder
  }

  export type DimDowntimeReasonSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DimUnitCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type DimUnitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DimUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type DimUnitMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type DimUnitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type DimEquipmentRelationFilter = {
    is?: DimEquipmentWhereInput
    isNot?: DimEquipmentWhereInput
  }

  export type DimProductRelationFilter = {
    is?: DimProductWhereInput
    isNot?: DimProductWhereInput
  }

  export type DimShiftRelationFilter = {
    is?: DimShiftWhereInput
    isNot?: DimShiftWhereInput
  }

  export type FactProductionCountOrderByAggregateInput = {
    id?: SortOrder
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    plannedProductionTime?: SortOrder
    operatingTime?: SortOrder
    plannedParts?: SortOrder
    totalPartsProduced?: SortOrder
    goodParts?: SortOrder
    scrapParts?: SortOrder
    reworkParts?: SortOrder
    operatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type FactProductionAvgOrderByAggregateInput = {
    id?: SortOrder
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    plannedProductionTime?: SortOrder
    operatingTime?: SortOrder
    plannedParts?: SortOrder
    totalPartsProduced?: SortOrder
    goodParts?: SortOrder
    scrapParts?: SortOrder
    reworkParts?: SortOrder
  }

  export type FactProductionMaxOrderByAggregateInput = {
    id?: SortOrder
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    plannedProductionTime?: SortOrder
    operatingTime?: SortOrder
    plannedParts?: SortOrder
    totalPartsProduced?: SortOrder
    goodParts?: SortOrder
    scrapParts?: SortOrder
    reworkParts?: SortOrder
    operatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type FactProductionMinOrderByAggregateInput = {
    id?: SortOrder
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    plannedProductionTime?: SortOrder
    operatingTime?: SortOrder
    plannedParts?: SortOrder
    totalPartsProduced?: SortOrder
    goodParts?: SortOrder
    scrapParts?: SortOrder
    reworkParts?: SortOrder
    operatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type FactProductionSumOrderByAggregateInput = {
    id?: SortOrder
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    plannedProductionTime?: SortOrder
    operatingTime?: SortOrder
    plannedParts?: SortOrder
    totalPartsProduced?: SortOrder
    goodParts?: SortOrder
    scrapParts?: SortOrder
    reworkParts?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type DimDowntimeReasonRelationFilter = {
    is?: DimDowntimeReasonWhereInput
    isNot?: DimDowntimeReasonWhereInput
  }

  export type FactProductionNullableRelationFilter = {
    is?: FactProductionWhereInput | null
    isNot?: FactProductionWhereInput | null
  }

  export type FactDowntimeCountOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    equipmentId?: SortOrder
    reasonId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    downtimeDuration?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type FactDowntimeAvgOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    equipmentId?: SortOrder
    reasonId?: SortOrder
    downtimeDuration?: SortOrder
  }

  export type FactDowntimeMaxOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    equipmentId?: SortOrder
    reasonId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    downtimeDuration?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type FactDowntimeMinOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    equipmentId?: SortOrder
    reasonId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    downtimeDuration?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type FactDowntimeSumOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    equipmentId?: SortOrder
    reasonId?: SortOrder
    downtimeDuration?: SortOrder
  }

  export type FactProductionRelationFilter = {
    is?: FactProductionWhereInput
    isNot?: FactProductionWhereInput
  }

  export type FactScrapCountOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapQty?: SortOrder
    scrapCost?: SortOrder
    createdAt?: SortOrder
  }

  export type FactScrapAvgOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    productId?: SortOrder
    scrapQty?: SortOrder
    scrapCost?: SortOrder
  }

  export type FactScrapMaxOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapQty?: SortOrder
    scrapCost?: SortOrder
    createdAt?: SortOrder
  }

  export type FactScrapMinOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapQty?: SortOrder
    scrapCost?: SortOrder
    createdAt?: SortOrder
  }

  export type FactScrapSumOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    productId?: SortOrder
    scrapQty?: SortOrder
    scrapCost?: SortOrder
  }

  export type FactMaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    workOrderNumber?: SortOrder
    maintenanceType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    laborHours?: SortOrder
    materialCost?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type FactMaintenanceAvgOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    laborHours?: SortOrder
    materialCost?: SortOrder
  }

  export type FactMaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    workOrderNumber?: SortOrder
    maintenanceType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    laborHours?: SortOrder
    materialCost?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type FactMaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    workOrderNumber?: SortOrder
    maintenanceType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    laborHours?: SortOrder
    materialCost?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type FactMaintenanceSumOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    laborHours?: SortOrder
    materialCost?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DimUnitNullableRelationFilter = {
    is?: DimUnitWhereInput | null
    isNot?: DimUnitWhereInput | null
  }

  export type FactSensorEventEventIdEventTsCompoundUniqueInput = {
    eventId: bigint | number
    eventTs: Date | string
  }

  export type FactSensorEventCountOrderByAggregateInput = {
    eventId?: SortOrder
    equipmentId?: SortOrder
    eventTs?: SortOrder
    parameter?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
  }

  export type FactSensorEventAvgOrderByAggregateInput = {
    eventId?: SortOrder
    equipmentId?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
  }

  export type FactSensorEventMaxOrderByAggregateInput = {
    eventId?: SortOrder
    equipmentId?: SortOrder
    eventTs?: SortOrder
    parameter?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
  }

  export type FactSensorEventMinOrderByAggregateInput = {
    eventId?: SortOrder
    equipmentId?: SortOrder
    eventTs?: SortOrder
    parameter?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
  }

  export type FactSensorEventSumOrderByAggregateInput = {
    eventId?: SortOrder
    equipmentId?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    logTs?: SortOrder
    beforeData?: SortOrder
    afterData?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    logTs?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    logTs?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    aggregateId?: SortOrder
    aggregateType?: SortOrder
    eventData?: SortOrder
    eventMetadata?: SortOrder
    userId?: SortOrder
    correlationId?: SortOrder
    causationId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    aggregateId?: SortOrder
    aggregateType?: SortOrder
    userId?: SortOrder
    correlationId?: SortOrder
    causationId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    aggregateId?: SortOrder
    aggregateType?: SortOrder
    userId?: SortOrder
    correlationId?: SortOrder
    causationId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DataDictionarySchemaNameTableNameColumnNameCompoundUniqueInput = {
    schemaName: string
    tableName: string
    columnName: string
  }

  export type DataDictionaryCountOrderByAggregateInput = {
    id?: SortOrder
    schemaName?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    dataType?: SortOrder
    isNullable?: SortOrder
    description?: SortOrder
    businessName?: SortOrder
    dataSteward?: SortOrder
    classification?: SortOrder
    piiFlag?: SortOrder
    retentionDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataDictionaryAvgOrderByAggregateInput = {
    id?: SortOrder
    retentionDays?: SortOrder
  }

  export type DataDictionaryMaxOrderByAggregateInput = {
    id?: SortOrder
    schemaName?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    dataType?: SortOrder
    isNullable?: SortOrder
    description?: SortOrder
    businessName?: SortOrder
    dataSteward?: SortOrder
    classification?: SortOrder
    piiFlag?: SortOrder
    retentionDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataDictionaryMinOrderByAggregateInput = {
    id?: SortOrder
    schemaName?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    dataType?: SortOrder
    isNullable?: SortOrder
    description?: SortOrder
    businessName?: SortOrder
    dataSteward?: SortOrder
    classification?: SortOrder
    piiFlag?: SortOrder
    retentionDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataDictionarySumOrderByAggregateInput = {
    id?: SortOrder
    retentionDays?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DataRetentionPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    retentionDays?: SortOrder
    archiveEnabled?: SortOrder
    archiveTableName?: SortOrder
    lastArchived?: SortOrder
    createdAt?: SortOrder
  }

  export type DataRetentionPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    retentionDays?: SortOrder
  }

  export type DataRetentionPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    retentionDays?: SortOrder
    archiveEnabled?: SortOrder
    archiveTableName?: SortOrder
    lastArchived?: SortOrder
    createdAt?: SortOrder
  }

  export type DataRetentionPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    retentionDays?: SortOrder
    archiveEnabled?: SortOrder
    archiveTableName?: SortOrder
    lastArchived?: SortOrder
    createdAt?: SortOrder
  }

  export type DataRetentionPolicySumOrderByAggregateInput = {
    id?: SortOrder
    retentionDays?: SortOrder
  }

  export type QueryPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    queryHash?: SortOrder
    queryText?: SortOrder
    totalTime?: SortOrder
    meanTime?: SortOrder
    maxTime?: SortOrder
    minTime?: SortOrder
    calls?: SortOrder
    rows?: SortOrder
    capturedAt?: SortOrder
  }

  export type QueryPerformanceAvgOrderByAggregateInput = {
    id?: SortOrder
    totalTime?: SortOrder
    meanTime?: SortOrder
    maxTime?: SortOrder
    minTime?: SortOrder
    calls?: SortOrder
    rows?: SortOrder
  }

  export type QueryPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    queryHash?: SortOrder
    queryText?: SortOrder
    totalTime?: SortOrder
    meanTime?: SortOrder
    maxTime?: SortOrder
    minTime?: SortOrder
    calls?: SortOrder
    rows?: SortOrder
    capturedAt?: SortOrder
  }

  export type QueryPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    queryHash?: SortOrder
    queryText?: SortOrder
    totalTime?: SortOrder
    meanTime?: SortOrder
    maxTime?: SortOrder
    minTime?: SortOrder
    calls?: SortOrder
    rows?: SortOrder
    capturedAt?: SortOrder
  }

  export type QueryPerformanceSumOrderByAggregateInput = {
    id?: SortOrder
    totalTime?: SortOrder
    meanTime?: SortOrder
    maxTime?: SortOrder
    minTime?: SortOrder
    calls?: SortOrder
    rows?: SortOrder
  }

  export type DataQualityScoresCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    checkName?: SortOrder
    checkType?: SortOrder
    passed?: SortOrder
    score?: SortOrder
    totalRows?: SortOrder
    failedRows?: SortOrder
    details?: SortOrder
    checkedAt?: SortOrder
  }

  export type DataQualityScoresAvgOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    totalRows?: SortOrder
    failedRows?: SortOrder
  }

  export type DataQualityScoresMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    checkName?: SortOrder
    checkType?: SortOrder
    passed?: SortOrder
    score?: SortOrder
    totalRows?: SortOrder
    failedRows?: SortOrder
    checkedAt?: SortOrder
  }

  export type DataQualityScoresMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    checkName?: SortOrder
    checkType?: SortOrder
    passed?: SortOrder
    score?: SortOrder
    totalRows?: SortOrder
    failedRows?: SortOrder
    checkedAt?: SortOrder
  }

  export type DataQualityScoresSumOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    totalRows?: SortOrder
    failedRows?: SortOrder
  }

  export type SystemMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    hostName?: SortOrder
    serviceName?: SortOrder
    tags?: SortOrder
    collectedAt?: SortOrder
  }

  export type SystemMetricsAvgOrderByAggregateInput = {
    id?: SortOrder
    metricValue?: SortOrder
  }

  export type SystemMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    hostName?: SortOrder
    serviceName?: SortOrder
    collectedAt?: SortOrder
  }

  export type SystemMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    hostName?: SortOrder
    serviceName?: SortOrder
    collectedAt?: SortOrder
  }

  export type SystemMetricsSumOrderByAggregateInput = {
    id?: SortOrder
    metricValue?: SortOrder
  }

  export type DimDateRangeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type DimDateRangeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DimDateRangeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type DimDateRangeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type DimDateRangeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OntologyTermCountOrderByAggregateInput = {
    term?: SortOrder
    modelName?: SortOrder
    fieldName?: SortOrder
    priority?: SortOrder
  }

  export type OntologyTermAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type OntologyTermMaxOrderByAggregateInput = {
    term?: SortOrder
    modelName?: SortOrder
    fieldName?: SortOrder
    priority?: SortOrder
  }

  export type OntologyTermMinOrderByAggregateInput = {
    term?: SortOrder
    modelName?: SortOrder
    fieldName?: SortOrder
    priority?: SortOrder
  }

  export type OntologyTermSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ViewOeeDailyDateIdShiftIdEquipmentIdCompoundUniqueInput = {
    dateId: Date | string
    shiftId: number
    equipmentId: number
  }

  export type ViewOeeDailyCountOrderByAggregateInput = {
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    availability?: SortOrder
    performance?: SortOrder
    quality?: SortOrder
    oee?: SortOrder
  }

  export type ViewOeeDailyAvgOrderByAggregateInput = {
    shiftId?: SortOrder
    equipmentId?: SortOrder
    availability?: SortOrder
    performance?: SortOrder
    quality?: SortOrder
    oee?: SortOrder
  }

  export type ViewOeeDailyMaxOrderByAggregateInput = {
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    availability?: SortOrder
    performance?: SortOrder
    quality?: SortOrder
    oee?: SortOrder
  }

  export type ViewOeeDailyMinOrderByAggregateInput = {
    dateId?: SortOrder
    shiftId?: SortOrder
    equipmentId?: SortOrder
    availability?: SortOrder
    performance?: SortOrder
    quality?: SortOrder
    oee?: SortOrder
  }

  export type ViewOeeDailySumOrderByAggregateInput = {
    shiftId?: SortOrder
    equipmentId?: SortOrder
    availability?: SortOrder
    performance?: SortOrder
    quality?: SortOrder
    oee?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ViewReliabilitySummaryCountOrderByAggregateInput = {
    equipmentId?: SortOrder
    equipmentCode?: SortOrder
    equipmentName?: SortOrder
    mtbfHours?: SortOrder
    mttrHours?: SortOrder
    failureCount?: SortOrder
  }

  export type ViewReliabilitySummaryAvgOrderByAggregateInput = {
    equipmentId?: SortOrder
    mtbfHours?: SortOrder
    mttrHours?: SortOrder
    failureCount?: SortOrder
  }

  export type ViewReliabilitySummaryMaxOrderByAggregateInput = {
    equipmentId?: SortOrder
    equipmentCode?: SortOrder
    equipmentName?: SortOrder
    mtbfHours?: SortOrder
    mttrHours?: SortOrder
    failureCount?: SortOrder
  }

  export type ViewReliabilitySummaryMinOrderByAggregateInput = {
    equipmentId?: SortOrder
    equipmentCode?: SortOrder
    equipmentName?: SortOrder
    mtbfHours?: SortOrder
    mttrHours?: SortOrder
    failureCount?: SortOrder
  }

  export type ViewReliabilitySummarySumOrderByAggregateInput = {
    equipmentId?: SortOrder
    mtbfHours?: SortOrder
    mttrHours?: SortOrder
    failureCount?: SortOrder
  }

  export type ViewScrapSummaryDateIdEquipmentIdProductIdScrapCodeCompoundUniqueInput = {
    dateId: Date | string
    equipmentId: number
    productId: number
    scrapCode: string
  }

  export type ViewScrapSummaryCountOrderByAggregateInput = {
    dateId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapReason?: SortOrder
    totalScrapQty?: SortOrder
    scrapIncidents?: SortOrder
    scrapCost?: SortOrder
  }

  export type ViewScrapSummaryAvgOrderByAggregateInput = {
    equipmentId?: SortOrder
    productId?: SortOrder
    totalScrapQty?: SortOrder
    scrapIncidents?: SortOrder
    scrapCost?: SortOrder
  }

  export type ViewScrapSummaryMaxOrderByAggregateInput = {
    dateId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapReason?: SortOrder
    totalScrapQty?: SortOrder
    scrapIncidents?: SortOrder
    scrapCost?: SortOrder
  }

  export type ViewScrapSummaryMinOrderByAggregateInput = {
    dateId?: SortOrder
    equipmentId?: SortOrder
    productId?: SortOrder
    scrapCode?: SortOrder
    scrapReason?: SortOrder
    totalScrapQty?: SortOrder
    scrapIncidents?: SortOrder
    scrapCost?: SortOrder
  }

  export type ViewScrapSummarySumOrderByAggregateInput = {
    equipmentId?: SortOrder
    productId?: SortOrder
    totalScrapQty?: SortOrder
    scrapIncidents?: SortOrder
    scrapCost?: SortOrder
  }

  export type DimAreaCreateNestedManyWithoutSiteInput = {
    create?: XOR<DimAreaCreateWithoutSiteInput, DimAreaUncheckedCreateWithoutSiteInput> | DimAreaCreateWithoutSiteInput[] | DimAreaUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DimAreaCreateOrConnectWithoutSiteInput | DimAreaCreateOrConnectWithoutSiteInput[]
    createMany?: DimAreaCreateManySiteInputEnvelope
    connect?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
  }

  export type DimShiftCreateNestedManyWithoutSiteInput = {
    create?: XOR<DimShiftCreateWithoutSiteInput, DimShiftUncheckedCreateWithoutSiteInput> | DimShiftCreateWithoutSiteInput[] | DimShiftUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DimShiftCreateOrConnectWithoutSiteInput | DimShiftCreateOrConnectWithoutSiteInput[]
    createMany?: DimShiftCreateManySiteInputEnvelope
    connect?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
  }

  export type DimAreaUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<DimAreaCreateWithoutSiteInput, DimAreaUncheckedCreateWithoutSiteInput> | DimAreaCreateWithoutSiteInput[] | DimAreaUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DimAreaCreateOrConnectWithoutSiteInput | DimAreaCreateOrConnectWithoutSiteInput[]
    createMany?: DimAreaCreateManySiteInputEnvelope
    connect?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
  }

  export type DimShiftUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<DimShiftCreateWithoutSiteInput, DimShiftUncheckedCreateWithoutSiteInput> | DimShiftCreateWithoutSiteInput[] | DimShiftUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DimShiftCreateOrConnectWithoutSiteInput | DimShiftCreateOrConnectWithoutSiteInput[]
    createMany?: DimShiftCreateManySiteInputEnvelope
    connect?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DimAreaUpdateManyWithoutSiteNestedInput = {
    create?: XOR<DimAreaCreateWithoutSiteInput, DimAreaUncheckedCreateWithoutSiteInput> | DimAreaCreateWithoutSiteInput[] | DimAreaUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DimAreaCreateOrConnectWithoutSiteInput | DimAreaCreateOrConnectWithoutSiteInput[]
    upsert?: DimAreaUpsertWithWhereUniqueWithoutSiteInput | DimAreaUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: DimAreaCreateManySiteInputEnvelope
    set?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
    disconnect?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
    delete?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
    connect?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
    update?: DimAreaUpdateWithWhereUniqueWithoutSiteInput | DimAreaUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: DimAreaUpdateManyWithWhereWithoutSiteInput | DimAreaUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: DimAreaScalarWhereInput | DimAreaScalarWhereInput[]
  }

  export type DimShiftUpdateManyWithoutSiteNestedInput = {
    create?: XOR<DimShiftCreateWithoutSiteInput, DimShiftUncheckedCreateWithoutSiteInput> | DimShiftCreateWithoutSiteInput[] | DimShiftUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DimShiftCreateOrConnectWithoutSiteInput | DimShiftCreateOrConnectWithoutSiteInput[]
    upsert?: DimShiftUpsertWithWhereUniqueWithoutSiteInput | DimShiftUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: DimShiftCreateManySiteInputEnvelope
    set?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
    disconnect?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
    delete?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
    connect?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
    update?: DimShiftUpdateWithWhereUniqueWithoutSiteInput | DimShiftUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: DimShiftUpdateManyWithWhereWithoutSiteInput | DimShiftUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: DimShiftScalarWhereInput | DimShiftScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DimAreaUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<DimAreaCreateWithoutSiteInput, DimAreaUncheckedCreateWithoutSiteInput> | DimAreaCreateWithoutSiteInput[] | DimAreaUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DimAreaCreateOrConnectWithoutSiteInput | DimAreaCreateOrConnectWithoutSiteInput[]
    upsert?: DimAreaUpsertWithWhereUniqueWithoutSiteInput | DimAreaUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: DimAreaCreateManySiteInputEnvelope
    set?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
    disconnect?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
    delete?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
    connect?: DimAreaWhereUniqueInput | DimAreaWhereUniqueInput[]
    update?: DimAreaUpdateWithWhereUniqueWithoutSiteInput | DimAreaUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: DimAreaUpdateManyWithWhereWithoutSiteInput | DimAreaUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: DimAreaScalarWhereInput | DimAreaScalarWhereInput[]
  }

  export type DimShiftUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<DimShiftCreateWithoutSiteInput, DimShiftUncheckedCreateWithoutSiteInput> | DimShiftCreateWithoutSiteInput[] | DimShiftUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DimShiftCreateOrConnectWithoutSiteInput | DimShiftCreateOrConnectWithoutSiteInput[]
    upsert?: DimShiftUpsertWithWhereUniqueWithoutSiteInput | DimShiftUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: DimShiftCreateManySiteInputEnvelope
    set?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
    disconnect?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
    delete?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
    connect?: DimShiftWhereUniqueInput | DimShiftWhereUniqueInput[]
    update?: DimShiftUpdateWithWhereUniqueWithoutSiteInput | DimShiftUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: DimShiftUpdateManyWithWhereWithoutSiteInput | DimShiftUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: DimShiftScalarWhereInput | DimShiftScalarWhereInput[]
  }

  export type DimSiteCreateNestedOneWithoutAreasInput = {
    create?: XOR<DimSiteCreateWithoutAreasInput, DimSiteUncheckedCreateWithoutAreasInput>
    connectOrCreate?: DimSiteCreateOrConnectWithoutAreasInput
    connect?: DimSiteWhereUniqueInput
  }

  export type DimWorkCenterCreateNestedManyWithoutAreaInput = {
    create?: XOR<DimWorkCenterCreateWithoutAreaInput, DimWorkCenterUncheckedCreateWithoutAreaInput> | DimWorkCenterCreateWithoutAreaInput[] | DimWorkCenterUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: DimWorkCenterCreateOrConnectWithoutAreaInput | DimWorkCenterCreateOrConnectWithoutAreaInput[]
    createMany?: DimWorkCenterCreateManyAreaInputEnvelope
    connect?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
  }

  export type DimWorkCenterUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<DimWorkCenterCreateWithoutAreaInput, DimWorkCenterUncheckedCreateWithoutAreaInput> | DimWorkCenterCreateWithoutAreaInput[] | DimWorkCenterUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: DimWorkCenterCreateOrConnectWithoutAreaInput | DimWorkCenterCreateOrConnectWithoutAreaInput[]
    createMany?: DimWorkCenterCreateManyAreaInputEnvelope
    connect?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
  }

  export type DimSiteUpdateOneRequiredWithoutAreasNestedInput = {
    create?: XOR<DimSiteCreateWithoutAreasInput, DimSiteUncheckedCreateWithoutAreasInput>
    connectOrCreate?: DimSiteCreateOrConnectWithoutAreasInput
    upsert?: DimSiteUpsertWithoutAreasInput
    connect?: DimSiteWhereUniqueInput
    update?: XOR<XOR<DimSiteUpdateToOneWithWhereWithoutAreasInput, DimSiteUpdateWithoutAreasInput>, DimSiteUncheckedUpdateWithoutAreasInput>
  }

  export type DimWorkCenterUpdateManyWithoutAreaNestedInput = {
    create?: XOR<DimWorkCenterCreateWithoutAreaInput, DimWorkCenterUncheckedCreateWithoutAreaInput> | DimWorkCenterCreateWithoutAreaInput[] | DimWorkCenterUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: DimWorkCenterCreateOrConnectWithoutAreaInput | DimWorkCenterCreateOrConnectWithoutAreaInput[]
    upsert?: DimWorkCenterUpsertWithWhereUniqueWithoutAreaInput | DimWorkCenterUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: DimWorkCenterCreateManyAreaInputEnvelope
    set?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
    disconnect?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
    delete?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
    connect?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
    update?: DimWorkCenterUpdateWithWhereUniqueWithoutAreaInput | DimWorkCenterUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: DimWorkCenterUpdateManyWithWhereWithoutAreaInput | DimWorkCenterUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: DimWorkCenterScalarWhereInput | DimWorkCenterScalarWhereInput[]
  }

  export type DimWorkCenterUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<DimWorkCenterCreateWithoutAreaInput, DimWorkCenterUncheckedCreateWithoutAreaInput> | DimWorkCenterCreateWithoutAreaInput[] | DimWorkCenterUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: DimWorkCenterCreateOrConnectWithoutAreaInput | DimWorkCenterCreateOrConnectWithoutAreaInput[]
    upsert?: DimWorkCenterUpsertWithWhereUniqueWithoutAreaInput | DimWorkCenterUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: DimWorkCenterCreateManyAreaInputEnvelope
    set?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
    disconnect?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
    delete?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
    connect?: DimWorkCenterWhereUniqueInput | DimWorkCenterWhereUniqueInput[]
    update?: DimWorkCenterUpdateWithWhereUniqueWithoutAreaInput | DimWorkCenterUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: DimWorkCenterUpdateManyWithWhereWithoutAreaInput | DimWorkCenterUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: DimWorkCenterScalarWhereInput | DimWorkCenterScalarWhereInput[]
  }

  export type DimAreaCreateNestedOneWithoutWorkCentersInput = {
    create?: XOR<DimAreaCreateWithoutWorkCentersInput, DimAreaUncheckedCreateWithoutWorkCentersInput>
    connectOrCreate?: DimAreaCreateOrConnectWithoutWorkCentersInput
    connect?: DimAreaWhereUniqueInput
  }

  export type DimEquipmentCreateNestedManyWithoutWorkCenterInput = {
    create?: XOR<DimEquipmentCreateWithoutWorkCenterInput, DimEquipmentUncheckedCreateWithoutWorkCenterInput> | DimEquipmentCreateWithoutWorkCenterInput[] | DimEquipmentUncheckedCreateWithoutWorkCenterInput[]
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutWorkCenterInput | DimEquipmentCreateOrConnectWithoutWorkCenterInput[]
    createMany?: DimEquipmentCreateManyWorkCenterInputEnvelope
    connect?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
  }

  export type DimEquipmentUncheckedCreateNestedManyWithoutWorkCenterInput = {
    create?: XOR<DimEquipmentCreateWithoutWorkCenterInput, DimEquipmentUncheckedCreateWithoutWorkCenterInput> | DimEquipmentCreateWithoutWorkCenterInput[] | DimEquipmentUncheckedCreateWithoutWorkCenterInput[]
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutWorkCenterInput | DimEquipmentCreateOrConnectWithoutWorkCenterInput[]
    createMany?: DimEquipmentCreateManyWorkCenterInputEnvelope
    connect?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DimAreaUpdateOneRequiredWithoutWorkCentersNestedInput = {
    create?: XOR<DimAreaCreateWithoutWorkCentersInput, DimAreaUncheckedCreateWithoutWorkCentersInput>
    connectOrCreate?: DimAreaCreateOrConnectWithoutWorkCentersInput
    upsert?: DimAreaUpsertWithoutWorkCentersInput
    connect?: DimAreaWhereUniqueInput
    update?: XOR<XOR<DimAreaUpdateToOneWithWhereWithoutWorkCentersInput, DimAreaUpdateWithoutWorkCentersInput>, DimAreaUncheckedUpdateWithoutWorkCentersInput>
  }

  export type DimEquipmentUpdateManyWithoutWorkCenterNestedInput = {
    create?: XOR<DimEquipmentCreateWithoutWorkCenterInput, DimEquipmentUncheckedCreateWithoutWorkCenterInput> | DimEquipmentCreateWithoutWorkCenterInput[] | DimEquipmentUncheckedCreateWithoutWorkCenterInput[]
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutWorkCenterInput | DimEquipmentCreateOrConnectWithoutWorkCenterInput[]
    upsert?: DimEquipmentUpsertWithWhereUniqueWithoutWorkCenterInput | DimEquipmentUpsertWithWhereUniqueWithoutWorkCenterInput[]
    createMany?: DimEquipmentCreateManyWorkCenterInputEnvelope
    set?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
    disconnect?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
    delete?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
    connect?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
    update?: DimEquipmentUpdateWithWhereUniqueWithoutWorkCenterInput | DimEquipmentUpdateWithWhereUniqueWithoutWorkCenterInput[]
    updateMany?: DimEquipmentUpdateManyWithWhereWithoutWorkCenterInput | DimEquipmentUpdateManyWithWhereWithoutWorkCenterInput[]
    deleteMany?: DimEquipmentScalarWhereInput | DimEquipmentScalarWhereInput[]
  }

  export type DimEquipmentUncheckedUpdateManyWithoutWorkCenterNestedInput = {
    create?: XOR<DimEquipmentCreateWithoutWorkCenterInput, DimEquipmentUncheckedCreateWithoutWorkCenterInput> | DimEquipmentCreateWithoutWorkCenterInput[] | DimEquipmentUncheckedCreateWithoutWorkCenterInput[]
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutWorkCenterInput | DimEquipmentCreateOrConnectWithoutWorkCenterInput[]
    upsert?: DimEquipmentUpsertWithWhereUniqueWithoutWorkCenterInput | DimEquipmentUpsertWithWhereUniqueWithoutWorkCenterInput[]
    createMany?: DimEquipmentCreateManyWorkCenterInputEnvelope
    set?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
    disconnect?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
    delete?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
    connect?: DimEquipmentWhereUniqueInput | DimEquipmentWhereUniqueInput[]
    update?: DimEquipmentUpdateWithWhereUniqueWithoutWorkCenterInput | DimEquipmentUpdateWithWhereUniqueWithoutWorkCenterInput[]
    updateMany?: DimEquipmentUpdateManyWithWhereWithoutWorkCenterInput | DimEquipmentUpdateManyWithWhereWithoutWorkCenterInput[]
    deleteMany?: DimEquipmentScalarWhereInput | DimEquipmentScalarWhereInput[]
  }

  export type DimWorkCenterCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<DimWorkCenterCreateWithoutEquipmentInput, DimWorkCenterUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: DimWorkCenterCreateOrConnectWithoutEquipmentInput
    connect?: DimWorkCenterWhereUniqueInput
  }

  export type FactProductionCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<FactProductionCreateWithoutEquipmentInput, FactProductionUncheckedCreateWithoutEquipmentInput> | FactProductionCreateWithoutEquipmentInput[] | FactProductionUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutEquipmentInput | FactProductionCreateOrConnectWithoutEquipmentInput[]
    createMany?: FactProductionCreateManyEquipmentInputEnvelope
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
  }

  export type FactDowntimeCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<FactDowntimeCreateWithoutEquipmentInput, FactDowntimeUncheckedCreateWithoutEquipmentInput> | FactDowntimeCreateWithoutEquipmentInput[] | FactDowntimeUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutEquipmentInput | FactDowntimeCreateOrConnectWithoutEquipmentInput[]
    createMany?: FactDowntimeCreateManyEquipmentInputEnvelope
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
  }

  export type FactMaintenanceCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<FactMaintenanceCreateWithoutEquipmentInput, FactMaintenanceUncheckedCreateWithoutEquipmentInput> | FactMaintenanceCreateWithoutEquipmentInput[] | FactMaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactMaintenanceCreateOrConnectWithoutEquipmentInput | FactMaintenanceCreateOrConnectWithoutEquipmentInput[]
    createMany?: FactMaintenanceCreateManyEquipmentInputEnvelope
    connect?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
  }

  export type FactSensorEventCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<FactSensorEventCreateWithoutEquipmentInput, FactSensorEventUncheckedCreateWithoutEquipmentInput> | FactSensorEventCreateWithoutEquipmentInput[] | FactSensorEventUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactSensorEventCreateOrConnectWithoutEquipmentInput | FactSensorEventCreateOrConnectWithoutEquipmentInput[]
    createMany?: FactSensorEventCreateManyEquipmentInputEnvelope
    connect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
  }

  export type FactProductionUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<FactProductionCreateWithoutEquipmentInput, FactProductionUncheckedCreateWithoutEquipmentInput> | FactProductionCreateWithoutEquipmentInput[] | FactProductionUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutEquipmentInput | FactProductionCreateOrConnectWithoutEquipmentInput[]
    createMany?: FactProductionCreateManyEquipmentInputEnvelope
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
  }

  export type FactDowntimeUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<FactDowntimeCreateWithoutEquipmentInput, FactDowntimeUncheckedCreateWithoutEquipmentInput> | FactDowntimeCreateWithoutEquipmentInput[] | FactDowntimeUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutEquipmentInput | FactDowntimeCreateOrConnectWithoutEquipmentInput[]
    createMany?: FactDowntimeCreateManyEquipmentInputEnvelope
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
  }

  export type FactMaintenanceUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<FactMaintenanceCreateWithoutEquipmentInput, FactMaintenanceUncheckedCreateWithoutEquipmentInput> | FactMaintenanceCreateWithoutEquipmentInput[] | FactMaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactMaintenanceCreateOrConnectWithoutEquipmentInput | FactMaintenanceCreateOrConnectWithoutEquipmentInput[]
    createMany?: FactMaintenanceCreateManyEquipmentInputEnvelope
    connect?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
  }

  export type FactSensorEventUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<FactSensorEventCreateWithoutEquipmentInput, FactSensorEventUncheckedCreateWithoutEquipmentInput> | FactSensorEventCreateWithoutEquipmentInput[] | FactSensorEventUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactSensorEventCreateOrConnectWithoutEquipmentInput | FactSensorEventCreateOrConnectWithoutEquipmentInput[]
    createMany?: FactSensorEventCreateManyEquipmentInputEnvelope
    connect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DimWorkCenterUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<DimWorkCenterCreateWithoutEquipmentInput, DimWorkCenterUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: DimWorkCenterCreateOrConnectWithoutEquipmentInput
    upsert?: DimWorkCenterUpsertWithoutEquipmentInput
    connect?: DimWorkCenterWhereUniqueInput
    update?: XOR<XOR<DimWorkCenterUpdateToOneWithWhereWithoutEquipmentInput, DimWorkCenterUpdateWithoutEquipmentInput>, DimWorkCenterUncheckedUpdateWithoutEquipmentInput>
  }

  export type FactProductionUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<FactProductionCreateWithoutEquipmentInput, FactProductionUncheckedCreateWithoutEquipmentInput> | FactProductionCreateWithoutEquipmentInput[] | FactProductionUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutEquipmentInput | FactProductionCreateOrConnectWithoutEquipmentInput[]
    upsert?: FactProductionUpsertWithWhereUniqueWithoutEquipmentInput | FactProductionUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: FactProductionCreateManyEquipmentInputEnvelope
    set?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    disconnect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    delete?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    update?: FactProductionUpdateWithWhereUniqueWithoutEquipmentInput | FactProductionUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: FactProductionUpdateManyWithWhereWithoutEquipmentInput | FactProductionUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: FactProductionScalarWhereInput | FactProductionScalarWhereInput[]
  }

  export type FactDowntimeUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<FactDowntimeCreateWithoutEquipmentInput, FactDowntimeUncheckedCreateWithoutEquipmentInput> | FactDowntimeCreateWithoutEquipmentInput[] | FactDowntimeUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutEquipmentInput | FactDowntimeCreateOrConnectWithoutEquipmentInput[]
    upsert?: FactDowntimeUpsertWithWhereUniqueWithoutEquipmentInput | FactDowntimeUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: FactDowntimeCreateManyEquipmentInputEnvelope
    set?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    disconnect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    delete?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    update?: FactDowntimeUpdateWithWhereUniqueWithoutEquipmentInput | FactDowntimeUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: FactDowntimeUpdateManyWithWhereWithoutEquipmentInput | FactDowntimeUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: FactDowntimeScalarWhereInput | FactDowntimeScalarWhereInput[]
  }

  export type FactMaintenanceUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<FactMaintenanceCreateWithoutEquipmentInput, FactMaintenanceUncheckedCreateWithoutEquipmentInput> | FactMaintenanceCreateWithoutEquipmentInput[] | FactMaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactMaintenanceCreateOrConnectWithoutEquipmentInput | FactMaintenanceCreateOrConnectWithoutEquipmentInput[]
    upsert?: FactMaintenanceUpsertWithWhereUniqueWithoutEquipmentInput | FactMaintenanceUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: FactMaintenanceCreateManyEquipmentInputEnvelope
    set?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
    disconnect?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
    delete?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
    connect?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
    update?: FactMaintenanceUpdateWithWhereUniqueWithoutEquipmentInput | FactMaintenanceUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: FactMaintenanceUpdateManyWithWhereWithoutEquipmentInput | FactMaintenanceUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: FactMaintenanceScalarWhereInput | FactMaintenanceScalarWhereInput[]
  }

  export type FactSensorEventUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<FactSensorEventCreateWithoutEquipmentInput, FactSensorEventUncheckedCreateWithoutEquipmentInput> | FactSensorEventCreateWithoutEquipmentInput[] | FactSensorEventUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactSensorEventCreateOrConnectWithoutEquipmentInput | FactSensorEventCreateOrConnectWithoutEquipmentInput[]
    upsert?: FactSensorEventUpsertWithWhereUniqueWithoutEquipmentInput | FactSensorEventUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: FactSensorEventCreateManyEquipmentInputEnvelope
    set?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    disconnect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    delete?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    connect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    update?: FactSensorEventUpdateWithWhereUniqueWithoutEquipmentInput | FactSensorEventUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: FactSensorEventUpdateManyWithWhereWithoutEquipmentInput | FactSensorEventUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: FactSensorEventScalarWhereInput | FactSensorEventScalarWhereInput[]
  }

  export type FactProductionUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<FactProductionCreateWithoutEquipmentInput, FactProductionUncheckedCreateWithoutEquipmentInput> | FactProductionCreateWithoutEquipmentInput[] | FactProductionUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutEquipmentInput | FactProductionCreateOrConnectWithoutEquipmentInput[]
    upsert?: FactProductionUpsertWithWhereUniqueWithoutEquipmentInput | FactProductionUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: FactProductionCreateManyEquipmentInputEnvelope
    set?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    disconnect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    delete?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    update?: FactProductionUpdateWithWhereUniqueWithoutEquipmentInput | FactProductionUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: FactProductionUpdateManyWithWhereWithoutEquipmentInput | FactProductionUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: FactProductionScalarWhereInput | FactProductionScalarWhereInput[]
  }

  export type FactDowntimeUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<FactDowntimeCreateWithoutEquipmentInput, FactDowntimeUncheckedCreateWithoutEquipmentInput> | FactDowntimeCreateWithoutEquipmentInput[] | FactDowntimeUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutEquipmentInput | FactDowntimeCreateOrConnectWithoutEquipmentInput[]
    upsert?: FactDowntimeUpsertWithWhereUniqueWithoutEquipmentInput | FactDowntimeUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: FactDowntimeCreateManyEquipmentInputEnvelope
    set?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    disconnect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    delete?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    update?: FactDowntimeUpdateWithWhereUniqueWithoutEquipmentInput | FactDowntimeUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: FactDowntimeUpdateManyWithWhereWithoutEquipmentInput | FactDowntimeUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: FactDowntimeScalarWhereInput | FactDowntimeScalarWhereInput[]
  }

  export type FactMaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<FactMaintenanceCreateWithoutEquipmentInput, FactMaintenanceUncheckedCreateWithoutEquipmentInput> | FactMaintenanceCreateWithoutEquipmentInput[] | FactMaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactMaintenanceCreateOrConnectWithoutEquipmentInput | FactMaintenanceCreateOrConnectWithoutEquipmentInput[]
    upsert?: FactMaintenanceUpsertWithWhereUniqueWithoutEquipmentInput | FactMaintenanceUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: FactMaintenanceCreateManyEquipmentInputEnvelope
    set?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
    disconnect?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
    delete?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
    connect?: FactMaintenanceWhereUniqueInput | FactMaintenanceWhereUniqueInput[]
    update?: FactMaintenanceUpdateWithWhereUniqueWithoutEquipmentInput | FactMaintenanceUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: FactMaintenanceUpdateManyWithWhereWithoutEquipmentInput | FactMaintenanceUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: FactMaintenanceScalarWhereInput | FactMaintenanceScalarWhereInput[]
  }

  export type FactSensorEventUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<FactSensorEventCreateWithoutEquipmentInput, FactSensorEventUncheckedCreateWithoutEquipmentInput> | FactSensorEventCreateWithoutEquipmentInput[] | FactSensorEventUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: FactSensorEventCreateOrConnectWithoutEquipmentInput | FactSensorEventCreateOrConnectWithoutEquipmentInput[]
    upsert?: FactSensorEventUpsertWithWhereUniqueWithoutEquipmentInput | FactSensorEventUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: FactSensorEventCreateManyEquipmentInputEnvelope
    set?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    disconnect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    delete?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    connect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    update?: FactSensorEventUpdateWithWhereUniqueWithoutEquipmentInput | FactSensorEventUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: FactSensorEventUpdateManyWithWhereWithoutEquipmentInput | FactSensorEventUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: FactSensorEventScalarWhereInput | FactSensorEventScalarWhereInput[]
  }

  export type FactProductionCreateNestedManyWithoutProductInput = {
    create?: XOR<FactProductionCreateWithoutProductInput, FactProductionUncheckedCreateWithoutProductInput> | FactProductionCreateWithoutProductInput[] | FactProductionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutProductInput | FactProductionCreateOrConnectWithoutProductInput[]
    createMany?: FactProductionCreateManyProductInputEnvelope
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
  }

  export type FactScrapCreateNestedManyWithoutProductInput = {
    create?: XOR<FactScrapCreateWithoutProductInput, FactScrapUncheckedCreateWithoutProductInput> | FactScrapCreateWithoutProductInput[] | FactScrapUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FactScrapCreateOrConnectWithoutProductInput | FactScrapCreateOrConnectWithoutProductInput[]
    createMany?: FactScrapCreateManyProductInputEnvelope
    connect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
  }

  export type FactProductionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<FactProductionCreateWithoutProductInput, FactProductionUncheckedCreateWithoutProductInput> | FactProductionCreateWithoutProductInput[] | FactProductionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutProductInput | FactProductionCreateOrConnectWithoutProductInput[]
    createMany?: FactProductionCreateManyProductInputEnvelope
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
  }

  export type FactScrapUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<FactScrapCreateWithoutProductInput, FactScrapUncheckedCreateWithoutProductInput> | FactScrapCreateWithoutProductInput[] | FactScrapUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FactScrapCreateOrConnectWithoutProductInput | FactScrapCreateOrConnectWithoutProductInput[]
    createMany?: FactScrapCreateManyProductInputEnvelope
    connect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type FactProductionUpdateManyWithoutProductNestedInput = {
    create?: XOR<FactProductionCreateWithoutProductInput, FactProductionUncheckedCreateWithoutProductInput> | FactProductionCreateWithoutProductInput[] | FactProductionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutProductInput | FactProductionCreateOrConnectWithoutProductInput[]
    upsert?: FactProductionUpsertWithWhereUniqueWithoutProductInput | FactProductionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FactProductionCreateManyProductInputEnvelope
    set?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    disconnect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    delete?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    update?: FactProductionUpdateWithWhereUniqueWithoutProductInput | FactProductionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FactProductionUpdateManyWithWhereWithoutProductInput | FactProductionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FactProductionScalarWhereInput | FactProductionScalarWhereInput[]
  }

  export type FactScrapUpdateManyWithoutProductNestedInput = {
    create?: XOR<FactScrapCreateWithoutProductInput, FactScrapUncheckedCreateWithoutProductInput> | FactScrapCreateWithoutProductInput[] | FactScrapUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FactScrapCreateOrConnectWithoutProductInput | FactScrapCreateOrConnectWithoutProductInput[]
    upsert?: FactScrapUpsertWithWhereUniqueWithoutProductInput | FactScrapUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FactScrapCreateManyProductInputEnvelope
    set?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    disconnect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    delete?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    connect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    update?: FactScrapUpdateWithWhereUniqueWithoutProductInput | FactScrapUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FactScrapUpdateManyWithWhereWithoutProductInput | FactScrapUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FactScrapScalarWhereInput | FactScrapScalarWhereInput[]
  }

  export type FactProductionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<FactProductionCreateWithoutProductInput, FactProductionUncheckedCreateWithoutProductInput> | FactProductionCreateWithoutProductInput[] | FactProductionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutProductInput | FactProductionCreateOrConnectWithoutProductInput[]
    upsert?: FactProductionUpsertWithWhereUniqueWithoutProductInput | FactProductionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FactProductionCreateManyProductInputEnvelope
    set?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    disconnect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    delete?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    update?: FactProductionUpdateWithWhereUniqueWithoutProductInput | FactProductionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FactProductionUpdateManyWithWhereWithoutProductInput | FactProductionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FactProductionScalarWhereInput | FactProductionScalarWhereInput[]
  }

  export type FactScrapUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<FactScrapCreateWithoutProductInput, FactScrapUncheckedCreateWithoutProductInput> | FactScrapCreateWithoutProductInput[] | FactScrapUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FactScrapCreateOrConnectWithoutProductInput | FactScrapCreateOrConnectWithoutProductInput[]
    upsert?: FactScrapUpsertWithWhereUniqueWithoutProductInput | FactScrapUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FactScrapCreateManyProductInputEnvelope
    set?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    disconnect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    delete?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    connect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    update?: FactScrapUpdateWithWhereUniqueWithoutProductInput | FactScrapUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FactScrapUpdateManyWithWhereWithoutProductInput | FactScrapUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FactScrapScalarWhereInput | FactScrapScalarWhereInput[]
  }

  export type DimSiteCreateNestedOneWithoutShiftsInput = {
    create?: XOR<DimSiteCreateWithoutShiftsInput, DimSiteUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: DimSiteCreateOrConnectWithoutShiftsInput
    connect?: DimSiteWhereUniqueInput
  }

  export type FactProductionCreateNestedManyWithoutShiftInput = {
    create?: XOR<FactProductionCreateWithoutShiftInput, FactProductionUncheckedCreateWithoutShiftInput> | FactProductionCreateWithoutShiftInput[] | FactProductionUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutShiftInput | FactProductionCreateOrConnectWithoutShiftInput[]
    createMany?: FactProductionCreateManyShiftInputEnvelope
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
  }

  export type FactProductionUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<FactProductionCreateWithoutShiftInput, FactProductionUncheckedCreateWithoutShiftInput> | FactProductionCreateWithoutShiftInput[] | FactProductionUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutShiftInput | FactProductionCreateOrConnectWithoutShiftInput[]
    createMany?: FactProductionCreateManyShiftInputEnvelope
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DimSiteUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<DimSiteCreateWithoutShiftsInput, DimSiteUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: DimSiteCreateOrConnectWithoutShiftsInput
    upsert?: DimSiteUpsertWithoutShiftsInput
    connect?: DimSiteWhereUniqueInput
    update?: XOR<XOR<DimSiteUpdateToOneWithWhereWithoutShiftsInput, DimSiteUpdateWithoutShiftsInput>, DimSiteUncheckedUpdateWithoutShiftsInput>
  }

  export type FactProductionUpdateManyWithoutShiftNestedInput = {
    create?: XOR<FactProductionCreateWithoutShiftInput, FactProductionUncheckedCreateWithoutShiftInput> | FactProductionCreateWithoutShiftInput[] | FactProductionUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutShiftInput | FactProductionCreateOrConnectWithoutShiftInput[]
    upsert?: FactProductionUpsertWithWhereUniqueWithoutShiftInput | FactProductionUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: FactProductionCreateManyShiftInputEnvelope
    set?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    disconnect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    delete?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    update?: FactProductionUpdateWithWhereUniqueWithoutShiftInput | FactProductionUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: FactProductionUpdateManyWithWhereWithoutShiftInput | FactProductionUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: FactProductionScalarWhereInput | FactProductionScalarWhereInput[]
  }

  export type FactProductionUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<FactProductionCreateWithoutShiftInput, FactProductionUncheckedCreateWithoutShiftInput> | FactProductionCreateWithoutShiftInput[] | FactProductionUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: FactProductionCreateOrConnectWithoutShiftInput | FactProductionCreateOrConnectWithoutShiftInput[]
    upsert?: FactProductionUpsertWithWhereUniqueWithoutShiftInput | FactProductionUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: FactProductionCreateManyShiftInputEnvelope
    set?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    disconnect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    delete?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    connect?: FactProductionWhereUniqueInput | FactProductionWhereUniqueInput[]
    update?: FactProductionUpdateWithWhereUniqueWithoutShiftInput | FactProductionUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: FactProductionUpdateManyWithWhereWithoutShiftInput | FactProductionUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: FactProductionScalarWhereInput | FactProductionScalarWhereInput[]
  }

  export type FactDowntimeCreateNestedManyWithoutReasonInput = {
    create?: XOR<FactDowntimeCreateWithoutReasonInput, FactDowntimeUncheckedCreateWithoutReasonInput> | FactDowntimeCreateWithoutReasonInput[] | FactDowntimeUncheckedCreateWithoutReasonInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutReasonInput | FactDowntimeCreateOrConnectWithoutReasonInput[]
    createMany?: FactDowntimeCreateManyReasonInputEnvelope
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
  }

  export type FactDowntimeUncheckedCreateNestedManyWithoutReasonInput = {
    create?: XOR<FactDowntimeCreateWithoutReasonInput, FactDowntimeUncheckedCreateWithoutReasonInput> | FactDowntimeCreateWithoutReasonInput[] | FactDowntimeUncheckedCreateWithoutReasonInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutReasonInput | FactDowntimeCreateOrConnectWithoutReasonInput[]
    createMany?: FactDowntimeCreateManyReasonInputEnvelope
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
  }

  export type FactDowntimeUpdateManyWithoutReasonNestedInput = {
    create?: XOR<FactDowntimeCreateWithoutReasonInput, FactDowntimeUncheckedCreateWithoutReasonInput> | FactDowntimeCreateWithoutReasonInput[] | FactDowntimeUncheckedCreateWithoutReasonInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutReasonInput | FactDowntimeCreateOrConnectWithoutReasonInput[]
    upsert?: FactDowntimeUpsertWithWhereUniqueWithoutReasonInput | FactDowntimeUpsertWithWhereUniqueWithoutReasonInput[]
    createMany?: FactDowntimeCreateManyReasonInputEnvelope
    set?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    disconnect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    delete?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    update?: FactDowntimeUpdateWithWhereUniqueWithoutReasonInput | FactDowntimeUpdateWithWhereUniqueWithoutReasonInput[]
    updateMany?: FactDowntimeUpdateManyWithWhereWithoutReasonInput | FactDowntimeUpdateManyWithWhereWithoutReasonInput[]
    deleteMany?: FactDowntimeScalarWhereInput | FactDowntimeScalarWhereInput[]
  }

  export type FactDowntimeUncheckedUpdateManyWithoutReasonNestedInput = {
    create?: XOR<FactDowntimeCreateWithoutReasonInput, FactDowntimeUncheckedCreateWithoutReasonInput> | FactDowntimeCreateWithoutReasonInput[] | FactDowntimeUncheckedCreateWithoutReasonInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutReasonInput | FactDowntimeCreateOrConnectWithoutReasonInput[]
    upsert?: FactDowntimeUpsertWithWhereUniqueWithoutReasonInput | FactDowntimeUpsertWithWhereUniqueWithoutReasonInput[]
    createMany?: FactDowntimeCreateManyReasonInputEnvelope
    set?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    disconnect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    delete?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    update?: FactDowntimeUpdateWithWhereUniqueWithoutReasonInput | FactDowntimeUpdateWithWhereUniqueWithoutReasonInput[]
    updateMany?: FactDowntimeUpdateManyWithWhereWithoutReasonInput | FactDowntimeUpdateManyWithWhereWithoutReasonInput[]
    deleteMany?: FactDowntimeScalarWhereInput | FactDowntimeScalarWhereInput[]
  }

  export type FactSensorEventCreateNestedManyWithoutUnitInput = {
    create?: XOR<FactSensorEventCreateWithoutUnitInput, FactSensorEventUncheckedCreateWithoutUnitInput> | FactSensorEventCreateWithoutUnitInput[] | FactSensorEventUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: FactSensorEventCreateOrConnectWithoutUnitInput | FactSensorEventCreateOrConnectWithoutUnitInput[]
    createMany?: FactSensorEventCreateManyUnitInputEnvelope
    connect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
  }

  export type FactSensorEventUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<FactSensorEventCreateWithoutUnitInput, FactSensorEventUncheckedCreateWithoutUnitInput> | FactSensorEventCreateWithoutUnitInput[] | FactSensorEventUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: FactSensorEventCreateOrConnectWithoutUnitInput | FactSensorEventCreateOrConnectWithoutUnitInput[]
    createMany?: FactSensorEventCreateManyUnitInputEnvelope
    connect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
  }

  export type FactSensorEventUpdateManyWithoutUnitNestedInput = {
    create?: XOR<FactSensorEventCreateWithoutUnitInput, FactSensorEventUncheckedCreateWithoutUnitInput> | FactSensorEventCreateWithoutUnitInput[] | FactSensorEventUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: FactSensorEventCreateOrConnectWithoutUnitInput | FactSensorEventCreateOrConnectWithoutUnitInput[]
    upsert?: FactSensorEventUpsertWithWhereUniqueWithoutUnitInput | FactSensorEventUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: FactSensorEventCreateManyUnitInputEnvelope
    set?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    disconnect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    delete?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    connect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    update?: FactSensorEventUpdateWithWhereUniqueWithoutUnitInput | FactSensorEventUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: FactSensorEventUpdateManyWithWhereWithoutUnitInput | FactSensorEventUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: FactSensorEventScalarWhereInput | FactSensorEventScalarWhereInput[]
  }

  export type FactSensorEventUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<FactSensorEventCreateWithoutUnitInput, FactSensorEventUncheckedCreateWithoutUnitInput> | FactSensorEventCreateWithoutUnitInput[] | FactSensorEventUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: FactSensorEventCreateOrConnectWithoutUnitInput | FactSensorEventCreateOrConnectWithoutUnitInput[]
    upsert?: FactSensorEventUpsertWithWhereUniqueWithoutUnitInput | FactSensorEventUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: FactSensorEventCreateManyUnitInputEnvelope
    set?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    disconnect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    delete?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    connect?: FactSensorEventWhereUniqueInput | FactSensorEventWhereUniqueInput[]
    update?: FactSensorEventUpdateWithWhereUniqueWithoutUnitInput | FactSensorEventUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: FactSensorEventUpdateManyWithWhereWithoutUnitInput | FactSensorEventUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: FactSensorEventScalarWhereInput | FactSensorEventScalarWhereInput[]
  }

  export type DimEquipmentCreateNestedOneWithoutProductionInput = {
    create?: XOR<DimEquipmentCreateWithoutProductionInput, DimEquipmentUncheckedCreateWithoutProductionInput>
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutProductionInput
    connect?: DimEquipmentWhereUniqueInput
  }

  export type DimProductCreateNestedOneWithoutProductionInput = {
    create?: XOR<DimProductCreateWithoutProductionInput, DimProductUncheckedCreateWithoutProductionInput>
    connectOrCreate?: DimProductCreateOrConnectWithoutProductionInput
    connect?: DimProductWhereUniqueInput
  }

  export type DimShiftCreateNestedOneWithoutProductionInput = {
    create?: XOR<DimShiftCreateWithoutProductionInput, DimShiftUncheckedCreateWithoutProductionInput>
    connectOrCreate?: DimShiftCreateOrConnectWithoutProductionInput
    connect?: DimShiftWhereUniqueInput
  }

  export type FactDowntimeCreateNestedManyWithoutProductionInput = {
    create?: XOR<FactDowntimeCreateWithoutProductionInput, FactDowntimeUncheckedCreateWithoutProductionInput> | FactDowntimeCreateWithoutProductionInput[] | FactDowntimeUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutProductionInput | FactDowntimeCreateOrConnectWithoutProductionInput[]
    createMany?: FactDowntimeCreateManyProductionInputEnvelope
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
  }

  export type FactScrapCreateNestedManyWithoutProductionInput = {
    create?: XOR<FactScrapCreateWithoutProductionInput, FactScrapUncheckedCreateWithoutProductionInput> | FactScrapCreateWithoutProductionInput[] | FactScrapUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: FactScrapCreateOrConnectWithoutProductionInput | FactScrapCreateOrConnectWithoutProductionInput[]
    createMany?: FactScrapCreateManyProductionInputEnvelope
    connect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
  }

  export type FactDowntimeUncheckedCreateNestedManyWithoutProductionInput = {
    create?: XOR<FactDowntimeCreateWithoutProductionInput, FactDowntimeUncheckedCreateWithoutProductionInput> | FactDowntimeCreateWithoutProductionInput[] | FactDowntimeUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutProductionInput | FactDowntimeCreateOrConnectWithoutProductionInput[]
    createMany?: FactDowntimeCreateManyProductionInputEnvelope
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
  }

  export type FactScrapUncheckedCreateNestedManyWithoutProductionInput = {
    create?: XOR<FactScrapCreateWithoutProductionInput, FactScrapUncheckedCreateWithoutProductionInput> | FactScrapCreateWithoutProductionInput[] | FactScrapUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: FactScrapCreateOrConnectWithoutProductionInput | FactScrapCreateOrConnectWithoutProductionInput[]
    createMany?: FactScrapCreateManyProductionInputEnvelope
    connect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DimEquipmentUpdateOneRequiredWithoutProductionNestedInput = {
    create?: XOR<DimEquipmentCreateWithoutProductionInput, DimEquipmentUncheckedCreateWithoutProductionInput>
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutProductionInput
    upsert?: DimEquipmentUpsertWithoutProductionInput
    connect?: DimEquipmentWhereUniqueInput
    update?: XOR<XOR<DimEquipmentUpdateToOneWithWhereWithoutProductionInput, DimEquipmentUpdateWithoutProductionInput>, DimEquipmentUncheckedUpdateWithoutProductionInput>
  }

  export type DimProductUpdateOneRequiredWithoutProductionNestedInput = {
    create?: XOR<DimProductCreateWithoutProductionInput, DimProductUncheckedCreateWithoutProductionInput>
    connectOrCreate?: DimProductCreateOrConnectWithoutProductionInput
    upsert?: DimProductUpsertWithoutProductionInput
    connect?: DimProductWhereUniqueInput
    update?: XOR<XOR<DimProductUpdateToOneWithWhereWithoutProductionInput, DimProductUpdateWithoutProductionInput>, DimProductUncheckedUpdateWithoutProductionInput>
  }

  export type DimShiftUpdateOneRequiredWithoutProductionNestedInput = {
    create?: XOR<DimShiftCreateWithoutProductionInput, DimShiftUncheckedCreateWithoutProductionInput>
    connectOrCreate?: DimShiftCreateOrConnectWithoutProductionInput
    upsert?: DimShiftUpsertWithoutProductionInput
    connect?: DimShiftWhereUniqueInput
    update?: XOR<XOR<DimShiftUpdateToOneWithWhereWithoutProductionInput, DimShiftUpdateWithoutProductionInput>, DimShiftUncheckedUpdateWithoutProductionInput>
  }

  export type FactDowntimeUpdateManyWithoutProductionNestedInput = {
    create?: XOR<FactDowntimeCreateWithoutProductionInput, FactDowntimeUncheckedCreateWithoutProductionInput> | FactDowntimeCreateWithoutProductionInput[] | FactDowntimeUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutProductionInput | FactDowntimeCreateOrConnectWithoutProductionInput[]
    upsert?: FactDowntimeUpsertWithWhereUniqueWithoutProductionInput | FactDowntimeUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: FactDowntimeCreateManyProductionInputEnvelope
    set?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    disconnect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    delete?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    update?: FactDowntimeUpdateWithWhereUniqueWithoutProductionInput | FactDowntimeUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: FactDowntimeUpdateManyWithWhereWithoutProductionInput | FactDowntimeUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: FactDowntimeScalarWhereInput | FactDowntimeScalarWhereInput[]
  }

  export type FactScrapUpdateManyWithoutProductionNestedInput = {
    create?: XOR<FactScrapCreateWithoutProductionInput, FactScrapUncheckedCreateWithoutProductionInput> | FactScrapCreateWithoutProductionInput[] | FactScrapUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: FactScrapCreateOrConnectWithoutProductionInput | FactScrapCreateOrConnectWithoutProductionInput[]
    upsert?: FactScrapUpsertWithWhereUniqueWithoutProductionInput | FactScrapUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: FactScrapCreateManyProductionInputEnvelope
    set?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    disconnect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    delete?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    connect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    update?: FactScrapUpdateWithWhereUniqueWithoutProductionInput | FactScrapUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: FactScrapUpdateManyWithWhereWithoutProductionInput | FactScrapUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: FactScrapScalarWhereInput | FactScrapScalarWhereInput[]
  }

  export type FactDowntimeUncheckedUpdateManyWithoutProductionNestedInput = {
    create?: XOR<FactDowntimeCreateWithoutProductionInput, FactDowntimeUncheckedCreateWithoutProductionInput> | FactDowntimeCreateWithoutProductionInput[] | FactDowntimeUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: FactDowntimeCreateOrConnectWithoutProductionInput | FactDowntimeCreateOrConnectWithoutProductionInput[]
    upsert?: FactDowntimeUpsertWithWhereUniqueWithoutProductionInput | FactDowntimeUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: FactDowntimeCreateManyProductionInputEnvelope
    set?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    disconnect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    delete?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    connect?: FactDowntimeWhereUniqueInput | FactDowntimeWhereUniqueInput[]
    update?: FactDowntimeUpdateWithWhereUniqueWithoutProductionInput | FactDowntimeUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: FactDowntimeUpdateManyWithWhereWithoutProductionInput | FactDowntimeUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: FactDowntimeScalarWhereInput | FactDowntimeScalarWhereInput[]
  }

  export type FactScrapUncheckedUpdateManyWithoutProductionNestedInput = {
    create?: XOR<FactScrapCreateWithoutProductionInput, FactScrapUncheckedCreateWithoutProductionInput> | FactScrapCreateWithoutProductionInput[] | FactScrapUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: FactScrapCreateOrConnectWithoutProductionInput | FactScrapCreateOrConnectWithoutProductionInput[]
    upsert?: FactScrapUpsertWithWhereUniqueWithoutProductionInput | FactScrapUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: FactScrapCreateManyProductionInputEnvelope
    set?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    disconnect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    delete?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    connect?: FactScrapWhereUniqueInput | FactScrapWhereUniqueInput[]
    update?: FactScrapUpdateWithWhereUniqueWithoutProductionInput | FactScrapUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: FactScrapUpdateManyWithWhereWithoutProductionInput | FactScrapUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: FactScrapScalarWhereInput | FactScrapScalarWhereInput[]
  }

  export type DimEquipmentCreateNestedOneWithoutDowntimeInput = {
    create?: XOR<DimEquipmentCreateWithoutDowntimeInput, DimEquipmentUncheckedCreateWithoutDowntimeInput>
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutDowntimeInput
    connect?: DimEquipmentWhereUniqueInput
  }

  export type DimDowntimeReasonCreateNestedOneWithoutDowntimeInput = {
    create?: XOR<DimDowntimeReasonCreateWithoutDowntimeInput, DimDowntimeReasonUncheckedCreateWithoutDowntimeInput>
    connectOrCreate?: DimDowntimeReasonCreateOrConnectWithoutDowntimeInput
    connect?: DimDowntimeReasonWhereUniqueInput
  }

  export type FactProductionCreateNestedOneWithoutDowntimeInput = {
    create?: XOR<FactProductionCreateWithoutDowntimeInput, FactProductionUncheckedCreateWithoutDowntimeInput>
    connectOrCreate?: FactProductionCreateOrConnectWithoutDowntimeInput
    connect?: FactProductionWhereUniqueInput
  }

  export type DimEquipmentUpdateOneRequiredWithoutDowntimeNestedInput = {
    create?: XOR<DimEquipmentCreateWithoutDowntimeInput, DimEquipmentUncheckedCreateWithoutDowntimeInput>
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutDowntimeInput
    upsert?: DimEquipmentUpsertWithoutDowntimeInput
    connect?: DimEquipmentWhereUniqueInput
    update?: XOR<XOR<DimEquipmentUpdateToOneWithWhereWithoutDowntimeInput, DimEquipmentUpdateWithoutDowntimeInput>, DimEquipmentUncheckedUpdateWithoutDowntimeInput>
  }

  export type DimDowntimeReasonUpdateOneRequiredWithoutDowntimeNestedInput = {
    create?: XOR<DimDowntimeReasonCreateWithoutDowntimeInput, DimDowntimeReasonUncheckedCreateWithoutDowntimeInput>
    connectOrCreate?: DimDowntimeReasonCreateOrConnectWithoutDowntimeInput
    upsert?: DimDowntimeReasonUpsertWithoutDowntimeInput
    connect?: DimDowntimeReasonWhereUniqueInput
    update?: XOR<XOR<DimDowntimeReasonUpdateToOneWithWhereWithoutDowntimeInput, DimDowntimeReasonUpdateWithoutDowntimeInput>, DimDowntimeReasonUncheckedUpdateWithoutDowntimeInput>
  }

  export type FactProductionUpdateOneWithoutDowntimeNestedInput = {
    create?: XOR<FactProductionCreateWithoutDowntimeInput, FactProductionUncheckedCreateWithoutDowntimeInput>
    connectOrCreate?: FactProductionCreateOrConnectWithoutDowntimeInput
    upsert?: FactProductionUpsertWithoutDowntimeInput
    disconnect?: FactProductionWhereInput | boolean
    delete?: FactProductionWhereInput | boolean
    connect?: FactProductionWhereUniqueInput
    update?: XOR<XOR<FactProductionUpdateToOneWithWhereWithoutDowntimeInput, FactProductionUpdateWithoutDowntimeInput>, FactProductionUncheckedUpdateWithoutDowntimeInput>
  }

  export type DimProductCreateNestedOneWithoutScrapInput = {
    create?: XOR<DimProductCreateWithoutScrapInput, DimProductUncheckedCreateWithoutScrapInput>
    connectOrCreate?: DimProductCreateOrConnectWithoutScrapInput
    connect?: DimProductWhereUniqueInput
  }

  export type FactProductionCreateNestedOneWithoutScrapInput = {
    create?: XOR<FactProductionCreateWithoutScrapInput, FactProductionUncheckedCreateWithoutScrapInput>
    connectOrCreate?: FactProductionCreateOrConnectWithoutScrapInput
    connect?: FactProductionWhereUniqueInput
  }

  export type DimProductUpdateOneRequiredWithoutScrapNestedInput = {
    create?: XOR<DimProductCreateWithoutScrapInput, DimProductUncheckedCreateWithoutScrapInput>
    connectOrCreate?: DimProductCreateOrConnectWithoutScrapInput
    upsert?: DimProductUpsertWithoutScrapInput
    connect?: DimProductWhereUniqueInput
    update?: XOR<XOR<DimProductUpdateToOneWithWhereWithoutScrapInput, DimProductUpdateWithoutScrapInput>, DimProductUncheckedUpdateWithoutScrapInput>
  }

  export type FactProductionUpdateOneRequiredWithoutScrapNestedInput = {
    create?: XOR<FactProductionCreateWithoutScrapInput, FactProductionUncheckedCreateWithoutScrapInput>
    connectOrCreate?: FactProductionCreateOrConnectWithoutScrapInput
    upsert?: FactProductionUpsertWithoutScrapInput
    connect?: FactProductionWhereUniqueInput
    update?: XOR<XOR<FactProductionUpdateToOneWithWhereWithoutScrapInput, FactProductionUpdateWithoutScrapInput>, FactProductionUncheckedUpdateWithoutScrapInput>
  }

  export type DimEquipmentCreateNestedOneWithoutMaintenanceInput = {
    create?: XOR<DimEquipmentCreateWithoutMaintenanceInput, DimEquipmentUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutMaintenanceInput
    connect?: DimEquipmentWhereUniqueInput
  }

  export type DimEquipmentUpdateOneRequiredWithoutMaintenanceNestedInput = {
    create?: XOR<DimEquipmentCreateWithoutMaintenanceInput, DimEquipmentUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutMaintenanceInput
    upsert?: DimEquipmentUpsertWithoutMaintenanceInput
    connect?: DimEquipmentWhereUniqueInput
    update?: XOR<XOR<DimEquipmentUpdateToOneWithWhereWithoutMaintenanceInput, DimEquipmentUpdateWithoutMaintenanceInput>, DimEquipmentUncheckedUpdateWithoutMaintenanceInput>
  }

  export type DimEquipmentCreateNestedOneWithoutSensorEventsInput = {
    create?: XOR<DimEquipmentCreateWithoutSensorEventsInput, DimEquipmentUncheckedCreateWithoutSensorEventsInput>
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutSensorEventsInput
    connect?: DimEquipmentWhereUniqueInput
  }

  export type DimUnitCreateNestedOneWithoutSensorEventsInput = {
    create?: XOR<DimUnitCreateWithoutSensorEventsInput, DimUnitUncheckedCreateWithoutSensorEventsInput>
    connectOrCreate?: DimUnitCreateOrConnectWithoutSensorEventsInput
    connect?: DimUnitWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DimEquipmentUpdateOneRequiredWithoutSensorEventsNestedInput = {
    create?: XOR<DimEquipmentCreateWithoutSensorEventsInput, DimEquipmentUncheckedCreateWithoutSensorEventsInput>
    connectOrCreate?: DimEquipmentCreateOrConnectWithoutSensorEventsInput
    upsert?: DimEquipmentUpsertWithoutSensorEventsInput
    connect?: DimEquipmentWhereUniqueInput
    update?: XOR<XOR<DimEquipmentUpdateToOneWithWhereWithoutSensorEventsInput, DimEquipmentUpdateWithoutSensorEventsInput>, DimEquipmentUncheckedUpdateWithoutSensorEventsInput>
  }

  export type DimUnitUpdateOneWithoutSensorEventsNestedInput = {
    create?: XOR<DimUnitCreateWithoutSensorEventsInput, DimUnitUncheckedCreateWithoutSensorEventsInput>
    connectOrCreate?: DimUnitCreateOrConnectWithoutSensorEventsInput
    upsert?: DimUnitUpsertWithoutSensorEventsInput
    disconnect?: DimUnitWhereInput | boolean
    delete?: DimUnitWhereInput | boolean
    connect?: DimUnitWhereUniqueInput
    update?: XOR<XOR<DimUnitUpdateToOneWithWhereWithoutSensorEventsInput, DimUnitUpdateWithoutSensorEventsInput>, DimUnitUncheckedUpdateWithoutSensorEventsInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DimAreaCreateWithoutSiteInput = {
    code: string
    name: string
    workCenters?: DimWorkCenterCreateNestedManyWithoutAreaInput
  }

  export type DimAreaUncheckedCreateWithoutSiteInput = {
    id?: number
    code: string
    name: string
    workCenters?: DimWorkCenterUncheckedCreateNestedManyWithoutAreaInput
  }

  export type DimAreaCreateOrConnectWithoutSiteInput = {
    where: DimAreaWhereUniqueInput
    create: XOR<DimAreaCreateWithoutSiteInput, DimAreaUncheckedCreateWithoutSiteInput>
  }

  export type DimAreaCreateManySiteInputEnvelope = {
    data: DimAreaCreateManySiteInput | DimAreaCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type DimShiftCreateWithoutSiteInput = {
    name: string
    startTime: string
    endTime: string
    breakMinutes?: number | null
    isActive?: boolean | null
    production?: FactProductionCreateNestedManyWithoutShiftInput
  }

  export type DimShiftUncheckedCreateWithoutSiteInput = {
    id?: number
    name: string
    startTime: string
    endTime: string
    breakMinutes?: number | null
    isActive?: boolean | null
    production?: FactProductionUncheckedCreateNestedManyWithoutShiftInput
  }

  export type DimShiftCreateOrConnectWithoutSiteInput = {
    where: DimShiftWhereUniqueInput
    create: XOR<DimShiftCreateWithoutSiteInput, DimShiftUncheckedCreateWithoutSiteInput>
  }

  export type DimShiftCreateManySiteInputEnvelope = {
    data: DimShiftCreateManySiteInput | DimShiftCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type DimAreaUpsertWithWhereUniqueWithoutSiteInput = {
    where: DimAreaWhereUniqueInput
    update: XOR<DimAreaUpdateWithoutSiteInput, DimAreaUncheckedUpdateWithoutSiteInput>
    create: XOR<DimAreaCreateWithoutSiteInput, DimAreaUncheckedCreateWithoutSiteInput>
  }

  export type DimAreaUpdateWithWhereUniqueWithoutSiteInput = {
    where: DimAreaWhereUniqueInput
    data: XOR<DimAreaUpdateWithoutSiteInput, DimAreaUncheckedUpdateWithoutSiteInput>
  }

  export type DimAreaUpdateManyWithWhereWithoutSiteInput = {
    where: DimAreaScalarWhereInput
    data: XOR<DimAreaUpdateManyMutationInput, DimAreaUncheckedUpdateManyWithoutSiteInput>
  }

  export type DimAreaScalarWhereInput = {
    AND?: DimAreaScalarWhereInput | DimAreaScalarWhereInput[]
    OR?: DimAreaScalarWhereInput[]
    NOT?: DimAreaScalarWhereInput | DimAreaScalarWhereInput[]
    id?: IntFilter<"DimArea"> | number
    code?: StringFilter<"DimArea"> | string
    name?: StringFilter<"DimArea"> | string
    siteId?: IntFilter<"DimArea"> | number
  }

  export type DimShiftUpsertWithWhereUniqueWithoutSiteInput = {
    where: DimShiftWhereUniqueInput
    update: XOR<DimShiftUpdateWithoutSiteInput, DimShiftUncheckedUpdateWithoutSiteInput>
    create: XOR<DimShiftCreateWithoutSiteInput, DimShiftUncheckedCreateWithoutSiteInput>
  }

  export type DimShiftUpdateWithWhereUniqueWithoutSiteInput = {
    where: DimShiftWhereUniqueInput
    data: XOR<DimShiftUpdateWithoutSiteInput, DimShiftUncheckedUpdateWithoutSiteInput>
  }

  export type DimShiftUpdateManyWithWhereWithoutSiteInput = {
    where: DimShiftScalarWhereInput
    data: XOR<DimShiftUpdateManyMutationInput, DimShiftUncheckedUpdateManyWithoutSiteInput>
  }

  export type DimShiftScalarWhereInput = {
    AND?: DimShiftScalarWhereInput | DimShiftScalarWhereInput[]
    OR?: DimShiftScalarWhereInput[]
    NOT?: DimShiftScalarWhereInput | DimShiftScalarWhereInput[]
    id?: IntFilter<"DimShift"> | number
    siteId?: IntFilter<"DimShift"> | number
    name?: StringFilter<"DimShift"> | string
    startTime?: StringFilter<"DimShift"> | string
    endTime?: StringFilter<"DimShift"> | string
    breakMinutes?: IntNullableFilter<"DimShift"> | number | null
    isActive?: BoolNullableFilter<"DimShift"> | boolean | null
  }

  export type DimSiteCreateWithoutAreasInput = {
    code: string
    name: string
    timezone?: string | null
    shifts?: DimShiftCreateNestedManyWithoutSiteInput
  }

  export type DimSiteUncheckedCreateWithoutAreasInput = {
    id?: number
    code: string
    name: string
    timezone?: string | null
    shifts?: DimShiftUncheckedCreateNestedManyWithoutSiteInput
  }

  export type DimSiteCreateOrConnectWithoutAreasInput = {
    where: DimSiteWhereUniqueInput
    create: XOR<DimSiteCreateWithoutAreasInput, DimSiteUncheckedCreateWithoutAreasInput>
  }

  export type DimWorkCenterCreateWithoutAreaInput = {
    code: string
    name: string
    capacity?: Decimal | DecimalJsLike | number | string | null
    capacityUnit?: string | null
    equipment?: DimEquipmentCreateNestedManyWithoutWorkCenterInput
  }

  export type DimWorkCenterUncheckedCreateWithoutAreaInput = {
    id?: number
    code: string
    name: string
    capacity?: Decimal | DecimalJsLike | number | string | null
    capacityUnit?: string | null
    equipment?: DimEquipmentUncheckedCreateNestedManyWithoutWorkCenterInput
  }

  export type DimWorkCenterCreateOrConnectWithoutAreaInput = {
    where: DimWorkCenterWhereUniqueInput
    create: XOR<DimWorkCenterCreateWithoutAreaInput, DimWorkCenterUncheckedCreateWithoutAreaInput>
  }

  export type DimWorkCenterCreateManyAreaInputEnvelope = {
    data: DimWorkCenterCreateManyAreaInput | DimWorkCenterCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type DimSiteUpsertWithoutAreasInput = {
    update: XOR<DimSiteUpdateWithoutAreasInput, DimSiteUncheckedUpdateWithoutAreasInput>
    create: XOR<DimSiteCreateWithoutAreasInput, DimSiteUncheckedCreateWithoutAreasInput>
    where?: DimSiteWhereInput
  }

  export type DimSiteUpdateToOneWithWhereWithoutAreasInput = {
    where?: DimSiteWhereInput
    data: XOR<DimSiteUpdateWithoutAreasInput, DimSiteUncheckedUpdateWithoutAreasInput>
  }

  export type DimSiteUpdateWithoutAreasInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    shifts?: DimShiftUpdateManyWithoutSiteNestedInput
  }

  export type DimSiteUncheckedUpdateWithoutAreasInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    shifts?: DimShiftUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type DimWorkCenterUpsertWithWhereUniqueWithoutAreaInput = {
    where: DimWorkCenterWhereUniqueInput
    update: XOR<DimWorkCenterUpdateWithoutAreaInput, DimWorkCenterUncheckedUpdateWithoutAreaInput>
    create: XOR<DimWorkCenterCreateWithoutAreaInput, DimWorkCenterUncheckedCreateWithoutAreaInput>
  }

  export type DimWorkCenterUpdateWithWhereUniqueWithoutAreaInput = {
    where: DimWorkCenterWhereUniqueInput
    data: XOR<DimWorkCenterUpdateWithoutAreaInput, DimWorkCenterUncheckedUpdateWithoutAreaInput>
  }

  export type DimWorkCenterUpdateManyWithWhereWithoutAreaInput = {
    where: DimWorkCenterScalarWhereInput
    data: XOR<DimWorkCenterUpdateManyMutationInput, DimWorkCenterUncheckedUpdateManyWithoutAreaInput>
  }

  export type DimWorkCenterScalarWhereInput = {
    AND?: DimWorkCenterScalarWhereInput | DimWorkCenterScalarWhereInput[]
    OR?: DimWorkCenterScalarWhereInput[]
    NOT?: DimWorkCenterScalarWhereInput | DimWorkCenterScalarWhereInput[]
    id?: IntFilter<"DimWorkCenter"> | number
    code?: StringFilter<"DimWorkCenter"> | string
    name?: StringFilter<"DimWorkCenter"> | string
    areaId?: IntFilter<"DimWorkCenter"> | number
    capacity?: DecimalNullableFilter<"DimWorkCenter"> | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: StringNullableFilter<"DimWorkCenter"> | string | null
  }

  export type DimAreaCreateWithoutWorkCentersInput = {
    code: string
    name: string
    site: DimSiteCreateNestedOneWithoutAreasInput
  }

  export type DimAreaUncheckedCreateWithoutWorkCentersInput = {
    id?: number
    code: string
    name: string
    siteId: number
  }

  export type DimAreaCreateOrConnectWithoutWorkCentersInput = {
    where: DimAreaWhereUniqueInput
    create: XOR<DimAreaCreateWithoutWorkCentersInput, DimAreaUncheckedCreateWithoutWorkCentersInput>
  }

  export type DimEquipmentCreateWithoutWorkCenterInput = {
    code: string
    name: string
    type?: string | null
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    production?: FactProductionCreateNestedManyWithoutEquipmentInput
    downtime?: FactDowntimeCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentUncheckedCreateWithoutWorkCenterInput = {
    id?: number
    code: string
    name: string
    type?: string | null
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    production?: FactProductionUncheckedCreateNestedManyWithoutEquipmentInput
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentCreateOrConnectWithoutWorkCenterInput = {
    where: DimEquipmentWhereUniqueInput
    create: XOR<DimEquipmentCreateWithoutWorkCenterInput, DimEquipmentUncheckedCreateWithoutWorkCenterInput>
  }

  export type DimEquipmentCreateManyWorkCenterInputEnvelope = {
    data: DimEquipmentCreateManyWorkCenterInput | DimEquipmentCreateManyWorkCenterInput[]
    skipDuplicates?: boolean
  }

  export type DimAreaUpsertWithoutWorkCentersInput = {
    update: XOR<DimAreaUpdateWithoutWorkCentersInput, DimAreaUncheckedUpdateWithoutWorkCentersInput>
    create: XOR<DimAreaCreateWithoutWorkCentersInput, DimAreaUncheckedCreateWithoutWorkCentersInput>
    where?: DimAreaWhereInput
  }

  export type DimAreaUpdateToOneWithWhereWithoutWorkCentersInput = {
    where?: DimAreaWhereInput
    data: XOR<DimAreaUpdateWithoutWorkCentersInput, DimAreaUncheckedUpdateWithoutWorkCentersInput>
  }

  export type DimAreaUpdateWithoutWorkCentersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    site?: DimSiteUpdateOneRequiredWithoutAreasNestedInput
  }

  export type DimAreaUncheckedUpdateWithoutWorkCentersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    siteId?: IntFieldUpdateOperationsInput | number
  }

  export type DimEquipmentUpsertWithWhereUniqueWithoutWorkCenterInput = {
    where: DimEquipmentWhereUniqueInput
    update: XOR<DimEquipmentUpdateWithoutWorkCenterInput, DimEquipmentUncheckedUpdateWithoutWorkCenterInput>
    create: XOR<DimEquipmentCreateWithoutWorkCenterInput, DimEquipmentUncheckedCreateWithoutWorkCenterInput>
  }

  export type DimEquipmentUpdateWithWhereUniqueWithoutWorkCenterInput = {
    where: DimEquipmentWhereUniqueInput
    data: XOR<DimEquipmentUpdateWithoutWorkCenterInput, DimEquipmentUncheckedUpdateWithoutWorkCenterInput>
  }

  export type DimEquipmentUpdateManyWithWhereWithoutWorkCenterInput = {
    where: DimEquipmentScalarWhereInput
    data: XOR<DimEquipmentUpdateManyMutationInput, DimEquipmentUncheckedUpdateManyWithoutWorkCenterInput>
  }

  export type DimEquipmentScalarWhereInput = {
    AND?: DimEquipmentScalarWhereInput | DimEquipmentScalarWhereInput[]
    OR?: DimEquipmentScalarWhereInput[]
    NOT?: DimEquipmentScalarWhereInput | DimEquipmentScalarWhereInput[]
    id?: IntFilter<"DimEquipment"> | number
    code?: StringFilter<"DimEquipment"> | string
    name?: StringFilter<"DimEquipment"> | string
    type?: StringNullableFilter<"DimEquipment"> | string | null
    workCenterId?: IntFilter<"DimEquipment"> | number
    manufacturer?: StringNullableFilter<"DimEquipment"> | string | null
    model?: StringNullableFilter<"DimEquipment"> | string | null
    serialNumber?: StringNullableFilter<"DimEquipment"> | string | null
    installationDate?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
    criticalityLevel?: StringNullableFilter<"DimEquipment"> | string | null
    theoreticalRate?: DecimalNullableFilter<"DimEquipment"> | Decimal | DecimalJsLike | number | string | null
    attributes?: JsonNullableFilter<"DimEquipment">
    isActive?: BoolNullableFilter<"DimEquipment"> | boolean | null
    createdAt?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DimEquipment"> | Date | string | null
  }

  export type DimWorkCenterCreateWithoutEquipmentInput = {
    code: string
    name: string
    capacity?: Decimal | DecimalJsLike | number | string | null
    capacityUnit?: string | null
    area: DimAreaCreateNestedOneWithoutWorkCentersInput
  }

  export type DimWorkCenterUncheckedCreateWithoutEquipmentInput = {
    id?: number
    code: string
    name: string
    areaId: number
    capacity?: Decimal | DecimalJsLike | number | string | null
    capacityUnit?: string | null
  }

  export type DimWorkCenterCreateOrConnectWithoutEquipmentInput = {
    where: DimWorkCenterWhereUniqueInput
    create: XOR<DimWorkCenterCreateWithoutEquipmentInput, DimWorkCenterUncheckedCreateWithoutEquipmentInput>
  }

  export type FactProductionCreateWithoutEquipmentInput = {
    dateId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    product: DimProductCreateNestedOneWithoutProductionInput
    shift: DimShiftCreateNestedOneWithoutProductionInput
    downtime?: FactDowntimeCreateNestedManyWithoutProductionInput
    scrap?: FactScrapCreateNestedManyWithoutProductionInput
  }

  export type FactProductionUncheckedCreateWithoutEquipmentInput = {
    id?: number
    dateId: number
    shiftId: number
    productId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutProductionInput
    scrap?: FactScrapUncheckedCreateNestedManyWithoutProductionInput
  }

  export type FactProductionCreateOrConnectWithoutEquipmentInput = {
    where: FactProductionWhereUniqueInput
    create: XOR<FactProductionCreateWithoutEquipmentInput, FactProductionUncheckedCreateWithoutEquipmentInput>
  }

  export type FactProductionCreateManyEquipmentInputEnvelope = {
    data: FactProductionCreateManyEquipmentInput | FactProductionCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type FactDowntimeCreateWithoutEquipmentInput = {
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
    reason: DimDowntimeReasonCreateNestedOneWithoutDowntimeInput
    production?: FactProductionCreateNestedOneWithoutDowntimeInput
  }

  export type FactDowntimeUncheckedCreateWithoutEquipmentInput = {
    id?: number
    productionId?: number | null
    reasonId: number
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
  }

  export type FactDowntimeCreateOrConnectWithoutEquipmentInput = {
    where: FactDowntimeWhereUniqueInput
    create: XOR<FactDowntimeCreateWithoutEquipmentInput, FactDowntimeUncheckedCreateWithoutEquipmentInput>
  }

  export type FactDowntimeCreateManyEquipmentInputEnvelope = {
    data: FactDowntimeCreateManyEquipmentInput | FactDowntimeCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type FactMaintenanceCreateWithoutEquipmentInput = {
    workOrderNumber: string
    maintenanceType: string
    startTime: Date | string
    endTime: Date | string
    laborHours?: Decimal | DecimalJsLike | number | string | null
    materialCost?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    createdAt?: Date | string | null
  }

  export type FactMaintenanceUncheckedCreateWithoutEquipmentInput = {
    id?: number
    workOrderNumber: string
    maintenanceType: string
    startTime: Date | string
    endTime: Date | string
    laborHours?: Decimal | DecimalJsLike | number | string | null
    materialCost?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    createdAt?: Date | string | null
  }

  export type FactMaintenanceCreateOrConnectWithoutEquipmentInput = {
    where: FactMaintenanceWhereUniqueInput
    create: XOR<FactMaintenanceCreateWithoutEquipmentInput, FactMaintenanceUncheckedCreateWithoutEquipmentInput>
  }

  export type FactMaintenanceCreateManyEquipmentInputEnvelope = {
    data: FactMaintenanceCreateManyEquipmentInput | FactMaintenanceCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type FactSensorEventCreateWithoutEquipmentInput = {
    eventId?: bigint | number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
    unit?: DimUnitCreateNestedOneWithoutSensorEventsInput
  }

  export type FactSensorEventUncheckedCreateWithoutEquipmentInput = {
    eventId?: bigint | number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
    unitId?: number | null
  }

  export type FactSensorEventCreateOrConnectWithoutEquipmentInput = {
    where: FactSensorEventWhereUniqueInput
    create: XOR<FactSensorEventCreateWithoutEquipmentInput, FactSensorEventUncheckedCreateWithoutEquipmentInput>
  }

  export type FactSensorEventCreateManyEquipmentInputEnvelope = {
    data: FactSensorEventCreateManyEquipmentInput | FactSensorEventCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type DimWorkCenterUpsertWithoutEquipmentInput = {
    update: XOR<DimWorkCenterUpdateWithoutEquipmentInput, DimWorkCenterUncheckedUpdateWithoutEquipmentInput>
    create: XOR<DimWorkCenterCreateWithoutEquipmentInput, DimWorkCenterUncheckedCreateWithoutEquipmentInput>
    where?: DimWorkCenterWhereInput
  }

  export type DimWorkCenterUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: DimWorkCenterWhereInput
    data: XOR<DimWorkCenterUpdateWithoutEquipmentInput, DimWorkCenterUncheckedUpdateWithoutEquipmentInput>
  }

  export type DimWorkCenterUpdateWithoutEquipmentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    area?: DimAreaUpdateOneRequiredWithoutWorkCentersNestedInput
  }

  export type DimWorkCenterUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: IntFieldUpdateOperationsInput | number
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FactProductionUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: FactProductionWhereUniqueInput
    update: XOR<FactProductionUpdateWithoutEquipmentInput, FactProductionUncheckedUpdateWithoutEquipmentInput>
    create: XOR<FactProductionCreateWithoutEquipmentInput, FactProductionUncheckedCreateWithoutEquipmentInput>
  }

  export type FactProductionUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: FactProductionWhereUniqueInput
    data: XOR<FactProductionUpdateWithoutEquipmentInput, FactProductionUncheckedUpdateWithoutEquipmentInput>
  }

  export type FactProductionUpdateManyWithWhereWithoutEquipmentInput = {
    where: FactProductionScalarWhereInput
    data: XOR<FactProductionUpdateManyMutationInput, FactProductionUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type FactProductionScalarWhereInput = {
    AND?: FactProductionScalarWhereInput | FactProductionScalarWhereInput[]
    OR?: FactProductionScalarWhereInput[]
    NOT?: FactProductionScalarWhereInput | FactProductionScalarWhereInput[]
    id?: IntFilter<"FactProduction"> | number
    dateId?: IntFilter<"FactProduction"> | number
    shiftId?: IntFilter<"FactProduction"> | number
    equipmentId?: IntFilter<"FactProduction"> | number
    productId?: IntFilter<"FactProduction"> | number
    orderNumber?: StringNullableFilter<"FactProduction"> | string | null
    startTime?: DateTimeFilter<"FactProduction"> | Date | string
    endTime?: DateTimeFilter<"FactProduction"> | Date | string
    plannedProductionTime?: BigIntFilter<"FactProduction"> | bigint | number
    operatingTime?: BigIntFilter<"FactProduction"> | bigint | number
    plannedParts?: IntFilter<"FactProduction"> | number
    totalPartsProduced?: IntFilter<"FactProduction"> | number
    goodParts?: IntFilter<"FactProduction"> | number
    scrapParts?: IntNullableFilter<"FactProduction"> | number | null
    reworkParts?: IntNullableFilter<"FactProduction"> | number | null
    operatorId?: StringNullableFilter<"FactProduction"> | string | null
    createdAt?: DateTimeNullableFilter<"FactProduction"> | Date | string | null
  }

  export type FactDowntimeUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: FactDowntimeWhereUniqueInput
    update: XOR<FactDowntimeUpdateWithoutEquipmentInput, FactDowntimeUncheckedUpdateWithoutEquipmentInput>
    create: XOR<FactDowntimeCreateWithoutEquipmentInput, FactDowntimeUncheckedCreateWithoutEquipmentInput>
  }

  export type FactDowntimeUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: FactDowntimeWhereUniqueInput
    data: XOR<FactDowntimeUpdateWithoutEquipmentInput, FactDowntimeUncheckedUpdateWithoutEquipmentInput>
  }

  export type FactDowntimeUpdateManyWithWhereWithoutEquipmentInput = {
    where: FactDowntimeScalarWhereInput
    data: XOR<FactDowntimeUpdateManyMutationInput, FactDowntimeUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type FactDowntimeScalarWhereInput = {
    AND?: FactDowntimeScalarWhereInput | FactDowntimeScalarWhereInput[]
    OR?: FactDowntimeScalarWhereInput[]
    NOT?: FactDowntimeScalarWhereInput | FactDowntimeScalarWhereInput[]
    id?: IntFilter<"FactDowntime"> | number
    productionId?: IntNullableFilter<"FactDowntime"> | number | null
    equipmentId?: IntFilter<"FactDowntime"> | number
    reasonId?: IntFilter<"FactDowntime"> | number
    startTime?: DateTimeFilter<"FactDowntime"> | Date | string
    endTime?: DateTimeFilter<"FactDowntime"> | Date | string
    downtimeDuration?: BigIntFilter<"FactDowntime"> | bigint | number
    comments?: StringNullableFilter<"FactDowntime"> | string | null
    createdAt?: DateTimeNullableFilter<"FactDowntime"> | Date | string | null
  }

  export type FactMaintenanceUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: FactMaintenanceWhereUniqueInput
    update: XOR<FactMaintenanceUpdateWithoutEquipmentInput, FactMaintenanceUncheckedUpdateWithoutEquipmentInput>
    create: XOR<FactMaintenanceCreateWithoutEquipmentInput, FactMaintenanceUncheckedCreateWithoutEquipmentInput>
  }

  export type FactMaintenanceUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: FactMaintenanceWhereUniqueInput
    data: XOR<FactMaintenanceUpdateWithoutEquipmentInput, FactMaintenanceUncheckedUpdateWithoutEquipmentInput>
  }

  export type FactMaintenanceUpdateManyWithWhereWithoutEquipmentInput = {
    where: FactMaintenanceScalarWhereInput
    data: XOR<FactMaintenanceUpdateManyMutationInput, FactMaintenanceUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type FactMaintenanceScalarWhereInput = {
    AND?: FactMaintenanceScalarWhereInput | FactMaintenanceScalarWhereInput[]
    OR?: FactMaintenanceScalarWhereInput[]
    NOT?: FactMaintenanceScalarWhereInput | FactMaintenanceScalarWhereInput[]
    id?: IntFilter<"FactMaintenance"> | number
    equipmentId?: IntFilter<"FactMaintenance"> | number
    workOrderNumber?: StringFilter<"FactMaintenance"> | string
    maintenanceType?: StringFilter<"FactMaintenance"> | string
    startTime?: DateTimeFilter<"FactMaintenance"> | Date | string
    endTime?: DateTimeFilter<"FactMaintenance"> | Date | string
    laborHours?: DecimalNullableFilter<"FactMaintenance"> | Decimal | DecimalJsLike | number | string | null
    materialCost?: DecimalNullableFilter<"FactMaintenance"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"FactMaintenance"> | string | null
    createdAt?: DateTimeNullableFilter<"FactMaintenance"> | Date | string | null
  }

  export type FactSensorEventUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: FactSensorEventWhereUniqueInput
    update: XOR<FactSensorEventUpdateWithoutEquipmentInput, FactSensorEventUncheckedUpdateWithoutEquipmentInput>
    create: XOR<FactSensorEventCreateWithoutEquipmentInput, FactSensorEventUncheckedCreateWithoutEquipmentInput>
  }

  export type FactSensorEventUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: FactSensorEventWhereUniqueInput
    data: XOR<FactSensorEventUpdateWithoutEquipmentInput, FactSensorEventUncheckedUpdateWithoutEquipmentInput>
  }

  export type FactSensorEventUpdateManyWithWhereWithoutEquipmentInput = {
    where: FactSensorEventScalarWhereInput
    data: XOR<FactSensorEventUpdateManyMutationInput, FactSensorEventUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type FactSensorEventScalarWhereInput = {
    AND?: FactSensorEventScalarWhereInput | FactSensorEventScalarWhereInput[]
    OR?: FactSensorEventScalarWhereInput[]
    NOT?: FactSensorEventScalarWhereInput | FactSensorEventScalarWhereInput[]
    eventId?: BigIntFilter<"FactSensorEvent"> | bigint | number
    equipmentId?: IntFilter<"FactSensorEvent"> | number
    eventTs?: DateTimeFilter<"FactSensorEvent"> | Date | string
    parameter?: StringFilter<"FactSensorEvent"> | string
    value?: DecimalFilter<"FactSensorEvent"> | Decimal | DecimalJsLike | number | string
    unitId?: IntNullableFilter<"FactSensorEvent"> | number | null
  }

  export type FactProductionCreateWithoutProductInput = {
    dateId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutProductionInput
    shift: DimShiftCreateNestedOneWithoutProductionInput
    downtime?: FactDowntimeCreateNestedManyWithoutProductionInput
    scrap?: FactScrapCreateNestedManyWithoutProductionInput
  }

  export type FactProductionUncheckedCreateWithoutProductInput = {
    id?: number
    dateId: number
    shiftId: number
    equipmentId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutProductionInput
    scrap?: FactScrapUncheckedCreateNestedManyWithoutProductionInput
  }

  export type FactProductionCreateOrConnectWithoutProductInput = {
    where: FactProductionWhereUniqueInput
    create: XOR<FactProductionCreateWithoutProductInput, FactProductionUncheckedCreateWithoutProductInput>
  }

  export type FactProductionCreateManyProductInputEnvelope = {
    data: FactProductionCreateManyProductInput | FactProductionCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type FactScrapCreateWithoutProductInput = {
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    production: FactProductionCreateNestedOneWithoutScrapInput
  }

  export type FactScrapUncheckedCreateWithoutProductInput = {
    id?: number
    productionId: number
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
  }

  export type FactScrapCreateOrConnectWithoutProductInput = {
    where: FactScrapWhereUniqueInput
    create: XOR<FactScrapCreateWithoutProductInput, FactScrapUncheckedCreateWithoutProductInput>
  }

  export type FactScrapCreateManyProductInputEnvelope = {
    data: FactScrapCreateManyProductInput | FactScrapCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type FactProductionUpsertWithWhereUniqueWithoutProductInput = {
    where: FactProductionWhereUniqueInput
    update: XOR<FactProductionUpdateWithoutProductInput, FactProductionUncheckedUpdateWithoutProductInput>
    create: XOR<FactProductionCreateWithoutProductInput, FactProductionUncheckedCreateWithoutProductInput>
  }

  export type FactProductionUpdateWithWhereUniqueWithoutProductInput = {
    where: FactProductionWhereUniqueInput
    data: XOR<FactProductionUpdateWithoutProductInput, FactProductionUncheckedUpdateWithoutProductInput>
  }

  export type FactProductionUpdateManyWithWhereWithoutProductInput = {
    where: FactProductionScalarWhereInput
    data: XOR<FactProductionUpdateManyMutationInput, FactProductionUncheckedUpdateManyWithoutProductInput>
  }

  export type FactScrapUpsertWithWhereUniqueWithoutProductInput = {
    where: FactScrapWhereUniqueInput
    update: XOR<FactScrapUpdateWithoutProductInput, FactScrapUncheckedUpdateWithoutProductInput>
    create: XOR<FactScrapCreateWithoutProductInput, FactScrapUncheckedCreateWithoutProductInput>
  }

  export type FactScrapUpdateWithWhereUniqueWithoutProductInput = {
    where: FactScrapWhereUniqueInput
    data: XOR<FactScrapUpdateWithoutProductInput, FactScrapUncheckedUpdateWithoutProductInput>
  }

  export type FactScrapUpdateManyWithWhereWithoutProductInput = {
    where: FactScrapScalarWhereInput
    data: XOR<FactScrapUpdateManyMutationInput, FactScrapUncheckedUpdateManyWithoutProductInput>
  }

  export type FactScrapScalarWhereInput = {
    AND?: FactScrapScalarWhereInput | FactScrapScalarWhereInput[]
    OR?: FactScrapScalarWhereInput[]
    NOT?: FactScrapScalarWhereInput | FactScrapScalarWhereInput[]
    id?: IntFilter<"FactScrap"> | number
    productionId?: IntFilter<"FactScrap"> | number
    productId?: IntFilter<"FactScrap"> | number
    scrapCode?: StringFilter<"FactScrap"> | string
    scrapQty?: IntFilter<"FactScrap"> | number
    scrapCost?: DecimalNullableFilter<"FactScrap"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"FactScrap"> | Date | string | null
  }

  export type DimSiteCreateWithoutShiftsInput = {
    code: string
    name: string
    timezone?: string | null
    areas?: DimAreaCreateNestedManyWithoutSiteInput
  }

  export type DimSiteUncheckedCreateWithoutShiftsInput = {
    id?: number
    code: string
    name: string
    timezone?: string | null
    areas?: DimAreaUncheckedCreateNestedManyWithoutSiteInput
  }

  export type DimSiteCreateOrConnectWithoutShiftsInput = {
    where: DimSiteWhereUniqueInput
    create: XOR<DimSiteCreateWithoutShiftsInput, DimSiteUncheckedCreateWithoutShiftsInput>
  }

  export type FactProductionCreateWithoutShiftInput = {
    dateId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutProductionInput
    product: DimProductCreateNestedOneWithoutProductionInput
    downtime?: FactDowntimeCreateNestedManyWithoutProductionInput
    scrap?: FactScrapCreateNestedManyWithoutProductionInput
  }

  export type FactProductionUncheckedCreateWithoutShiftInput = {
    id?: number
    dateId: number
    equipmentId: number
    productId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutProductionInput
    scrap?: FactScrapUncheckedCreateNestedManyWithoutProductionInput
  }

  export type FactProductionCreateOrConnectWithoutShiftInput = {
    where: FactProductionWhereUniqueInput
    create: XOR<FactProductionCreateWithoutShiftInput, FactProductionUncheckedCreateWithoutShiftInput>
  }

  export type FactProductionCreateManyShiftInputEnvelope = {
    data: FactProductionCreateManyShiftInput | FactProductionCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type DimSiteUpsertWithoutShiftsInput = {
    update: XOR<DimSiteUpdateWithoutShiftsInput, DimSiteUncheckedUpdateWithoutShiftsInput>
    create: XOR<DimSiteCreateWithoutShiftsInput, DimSiteUncheckedCreateWithoutShiftsInput>
    where?: DimSiteWhereInput
  }

  export type DimSiteUpdateToOneWithWhereWithoutShiftsInput = {
    where?: DimSiteWhereInput
    data: XOR<DimSiteUpdateWithoutShiftsInput, DimSiteUncheckedUpdateWithoutShiftsInput>
  }

  export type DimSiteUpdateWithoutShiftsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    areas?: DimAreaUpdateManyWithoutSiteNestedInput
  }

  export type DimSiteUncheckedUpdateWithoutShiftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    areas?: DimAreaUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type FactProductionUpsertWithWhereUniqueWithoutShiftInput = {
    where: FactProductionWhereUniqueInput
    update: XOR<FactProductionUpdateWithoutShiftInput, FactProductionUncheckedUpdateWithoutShiftInput>
    create: XOR<FactProductionCreateWithoutShiftInput, FactProductionUncheckedCreateWithoutShiftInput>
  }

  export type FactProductionUpdateWithWhereUniqueWithoutShiftInput = {
    where: FactProductionWhereUniqueInput
    data: XOR<FactProductionUpdateWithoutShiftInput, FactProductionUncheckedUpdateWithoutShiftInput>
  }

  export type FactProductionUpdateManyWithWhereWithoutShiftInput = {
    where: FactProductionScalarWhereInput
    data: XOR<FactProductionUpdateManyMutationInput, FactProductionUncheckedUpdateManyWithoutShiftInput>
  }

  export type FactDowntimeCreateWithoutReasonInput = {
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutDowntimeInput
    production?: FactProductionCreateNestedOneWithoutDowntimeInput
  }

  export type FactDowntimeUncheckedCreateWithoutReasonInput = {
    id?: number
    productionId?: number | null
    equipmentId: number
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
  }

  export type FactDowntimeCreateOrConnectWithoutReasonInput = {
    where: FactDowntimeWhereUniqueInput
    create: XOR<FactDowntimeCreateWithoutReasonInput, FactDowntimeUncheckedCreateWithoutReasonInput>
  }

  export type FactDowntimeCreateManyReasonInputEnvelope = {
    data: FactDowntimeCreateManyReasonInput | FactDowntimeCreateManyReasonInput[]
    skipDuplicates?: boolean
  }

  export type FactDowntimeUpsertWithWhereUniqueWithoutReasonInput = {
    where: FactDowntimeWhereUniqueInput
    update: XOR<FactDowntimeUpdateWithoutReasonInput, FactDowntimeUncheckedUpdateWithoutReasonInput>
    create: XOR<FactDowntimeCreateWithoutReasonInput, FactDowntimeUncheckedCreateWithoutReasonInput>
  }

  export type FactDowntimeUpdateWithWhereUniqueWithoutReasonInput = {
    where: FactDowntimeWhereUniqueInput
    data: XOR<FactDowntimeUpdateWithoutReasonInput, FactDowntimeUncheckedUpdateWithoutReasonInput>
  }

  export type FactDowntimeUpdateManyWithWhereWithoutReasonInput = {
    where: FactDowntimeScalarWhereInput
    data: XOR<FactDowntimeUpdateManyMutationInput, FactDowntimeUncheckedUpdateManyWithoutReasonInput>
  }

  export type FactSensorEventCreateWithoutUnitInput = {
    eventId?: bigint | number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
    equipment: DimEquipmentCreateNestedOneWithoutSensorEventsInput
  }

  export type FactSensorEventUncheckedCreateWithoutUnitInput = {
    eventId?: bigint | number
    equipmentId: number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
  }

  export type FactSensorEventCreateOrConnectWithoutUnitInput = {
    where: FactSensorEventWhereUniqueInput
    create: XOR<FactSensorEventCreateWithoutUnitInput, FactSensorEventUncheckedCreateWithoutUnitInput>
  }

  export type FactSensorEventCreateManyUnitInputEnvelope = {
    data: FactSensorEventCreateManyUnitInput | FactSensorEventCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type FactSensorEventUpsertWithWhereUniqueWithoutUnitInput = {
    where: FactSensorEventWhereUniqueInput
    update: XOR<FactSensorEventUpdateWithoutUnitInput, FactSensorEventUncheckedUpdateWithoutUnitInput>
    create: XOR<FactSensorEventCreateWithoutUnitInput, FactSensorEventUncheckedCreateWithoutUnitInput>
  }

  export type FactSensorEventUpdateWithWhereUniqueWithoutUnitInput = {
    where: FactSensorEventWhereUniqueInput
    data: XOR<FactSensorEventUpdateWithoutUnitInput, FactSensorEventUncheckedUpdateWithoutUnitInput>
  }

  export type FactSensorEventUpdateManyWithWhereWithoutUnitInput = {
    where: FactSensorEventScalarWhereInput
    data: XOR<FactSensorEventUpdateManyMutationInput, FactSensorEventUncheckedUpdateManyWithoutUnitInput>
  }

  export type DimEquipmentCreateWithoutProductionInput = {
    code: string
    name: string
    type?: string | null
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    workCenter: DimWorkCenterCreateNestedOneWithoutEquipmentInput
    downtime?: FactDowntimeCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentUncheckedCreateWithoutProductionInput = {
    id?: number
    code: string
    name: string
    type?: string | null
    workCenterId: number
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentCreateOrConnectWithoutProductionInput = {
    where: DimEquipmentWhereUniqueInput
    create: XOR<DimEquipmentCreateWithoutProductionInput, DimEquipmentUncheckedCreateWithoutProductionInput>
  }

  export type DimProductCreateWithoutProductionInput = {
    code: string
    name: string
    family?: string | null
    unitOfMeasure?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: bigint | number | null
    scrap?: FactScrapCreateNestedManyWithoutProductInput
  }

  export type DimProductUncheckedCreateWithoutProductionInput = {
    id?: number
    code: string
    name: string
    family?: string | null
    unitOfMeasure?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: bigint | number | null
    scrap?: FactScrapUncheckedCreateNestedManyWithoutProductInput
  }

  export type DimProductCreateOrConnectWithoutProductionInput = {
    where: DimProductWhereUniqueInput
    create: XOR<DimProductCreateWithoutProductionInput, DimProductUncheckedCreateWithoutProductionInput>
  }

  export type DimShiftCreateWithoutProductionInput = {
    name: string
    startTime: string
    endTime: string
    breakMinutes?: number | null
    isActive?: boolean | null
    site: DimSiteCreateNestedOneWithoutShiftsInput
  }

  export type DimShiftUncheckedCreateWithoutProductionInput = {
    id?: number
    siteId: number
    name: string
    startTime: string
    endTime: string
    breakMinutes?: number | null
    isActive?: boolean | null
  }

  export type DimShiftCreateOrConnectWithoutProductionInput = {
    where: DimShiftWhereUniqueInput
    create: XOR<DimShiftCreateWithoutProductionInput, DimShiftUncheckedCreateWithoutProductionInput>
  }

  export type FactDowntimeCreateWithoutProductionInput = {
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutDowntimeInput
    reason: DimDowntimeReasonCreateNestedOneWithoutDowntimeInput
  }

  export type FactDowntimeUncheckedCreateWithoutProductionInput = {
    id?: number
    equipmentId: number
    reasonId: number
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
  }

  export type FactDowntimeCreateOrConnectWithoutProductionInput = {
    where: FactDowntimeWhereUniqueInput
    create: XOR<FactDowntimeCreateWithoutProductionInput, FactDowntimeUncheckedCreateWithoutProductionInput>
  }

  export type FactDowntimeCreateManyProductionInputEnvelope = {
    data: FactDowntimeCreateManyProductionInput | FactDowntimeCreateManyProductionInput[]
    skipDuplicates?: boolean
  }

  export type FactScrapCreateWithoutProductionInput = {
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    product: DimProductCreateNestedOneWithoutScrapInput
  }

  export type FactScrapUncheckedCreateWithoutProductionInput = {
    id?: number
    productId: number
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
  }

  export type FactScrapCreateOrConnectWithoutProductionInput = {
    where: FactScrapWhereUniqueInput
    create: XOR<FactScrapCreateWithoutProductionInput, FactScrapUncheckedCreateWithoutProductionInput>
  }

  export type FactScrapCreateManyProductionInputEnvelope = {
    data: FactScrapCreateManyProductionInput | FactScrapCreateManyProductionInput[]
    skipDuplicates?: boolean
  }

  export type DimEquipmentUpsertWithoutProductionInput = {
    update: XOR<DimEquipmentUpdateWithoutProductionInput, DimEquipmentUncheckedUpdateWithoutProductionInput>
    create: XOR<DimEquipmentCreateWithoutProductionInput, DimEquipmentUncheckedCreateWithoutProductionInput>
    where?: DimEquipmentWhereInput
  }

  export type DimEquipmentUpdateToOneWithWhereWithoutProductionInput = {
    where?: DimEquipmentWhereInput
    data: XOR<DimEquipmentUpdateWithoutProductionInput, DimEquipmentUncheckedUpdateWithoutProductionInput>
  }

  export type DimEquipmentUpdateWithoutProductionInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workCenter?: DimWorkCenterUpdateOneRequiredWithoutEquipmentNestedInput
    downtime?: FactDowntimeUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentUncheckedUpdateWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workCenterId?: IntFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downtime?: FactDowntimeUncheckedUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type DimProductUpsertWithoutProductionInput = {
    update: XOR<DimProductUpdateWithoutProductionInput, DimProductUncheckedUpdateWithoutProductionInput>
    create: XOR<DimProductCreateWithoutProductionInput, DimProductUncheckedCreateWithoutProductionInput>
    where?: DimProductWhereInput
  }

  export type DimProductUpdateToOneWithWhereWithoutProductionInput = {
    where?: DimProductWhereInput
    data: XOR<DimProductUpdateWithoutProductionInput, DimProductUncheckedUpdateWithoutProductionInput>
  }

  export type DimProductUpdateWithoutProductionInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    family?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scrap?: FactScrapUpdateManyWithoutProductNestedInput
  }

  export type DimProductUncheckedUpdateWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    family?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scrap?: FactScrapUncheckedUpdateManyWithoutProductNestedInput
  }

  export type DimShiftUpsertWithoutProductionInput = {
    update: XOR<DimShiftUpdateWithoutProductionInput, DimShiftUncheckedUpdateWithoutProductionInput>
    create: XOR<DimShiftCreateWithoutProductionInput, DimShiftUncheckedCreateWithoutProductionInput>
    where?: DimShiftWhereInput
  }

  export type DimShiftUpdateToOneWithWhereWithoutProductionInput = {
    where?: DimShiftWhereInput
    data: XOR<DimShiftUpdateWithoutProductionInput, DimShiftUncheckedUpdateWithoutProductionInput>
  }

  export type DimShiftUpdateWithoutProductionInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    site?: DimSiteUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type DimShiftUncheckedUpdateWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    siteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FactDowntimeUpsertWithWhereUniqueWithoutProductionInput = {
    where: FactDowntimeWhereUniqueInput
    update: XOR<FactDowntimeUpdateWithoutProductionInput, FactDowntimeUncheckedUpdateWithoutProductionInput>
    create: XOR<FactDowntimeCreateWithoutProductionInput, FactDowntimeUncheckedCreateWithoutProductionInput>
  }

  export type FactDowntimeUpdateWithWhereUniqueWithoutProductionInput = {
    where: FactDowntimeWhereUniqueInput
    data: XOR<FactDowntimeUpdateWithoutProductionInput, FactDowntimeUncheckedUpdateWithoutProductionInput>
  }

  export type FactDowntimeUpdateManyWithWhereWithoutProductionInput = {
    where: FactDowntimeScalarWhereInput
    data: XOR<FactDowntimeUpdateManyMutationInput, FactDowntimeUncheckedUpdateManyWithoutProductionInput>
  }

  export type FactScrapUpsertWithWhereUniqueWithoutProductionInput = {
    where: FactScrapWhereUniqueInput
    update: XOR<FactScrapUpdateWithoutProductionInput, FactScrapUncheckedUpdateWithoutProductionInput>
    create: XOR<FactScrapCreateWithoutProductionInput, FactScrapUncheckedCreateWithoutProductionInput>
  }

  export type FactScrapUpdateWithWhereUniqueWithoutProductionInput = {
    where: FactScrapWhereUniqueInput
    data: XOR<FactScrapUpdateWithoutProductionInput, FactScrapUncheckedUpdateWithoutProductionInput>
  }

  export type FactScrapUpdateManyWithWhereWithoutProductionInput = {
    where: FactScrapScalarWhereInput
    data: XOR<FactScrapUpdateManyMutationInput, FactScrapUncheckedUpdateManyWithoutProductionInput>
  }

  export type DimEquipmentCreateWithoutDowntimeInput = {
    code: string
    name: string
    type?: string | null
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    workCenter: DimWorkCenterCreateNestedOneWithoutEquipmentInput
    production?: FactProductionCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentUncheckedCreateWithoutDowntimeInput = {
    id?: number
    code: string
    name: string
    type?: string | null
    workCenterId: number
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    production?: FactProductionUncheckedCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentCreateOrConnectWithoutDowntimeInput = {
    where: DimEquipmentWhereUniqueInput
    create: XOR<DimEquipmentCreateWithoutDowntimeInput, DimEquipmentUncheckedCreateWithoutDowntimeInput>
  }

  export type DimDowntimeReasonCreateWithoutDowntimeInput = {
    code: string
    description: string
    category: string
    isPlanned?: boolean | null
    affectsOee?: boolean | null
    isFailure?: boolean | null
  }

  export type DimDowntimeReasonUncheckedCreateWithoutDowntimeInput = {
    id?: number
    code: string
    description: string
    category: string
    isPlanned?: boolean | null
    affectsOee?: boolean | null
    isFailure?: boolean | null
  }

  export type DimDowntimeReasonCreateOrConnectWithoutDowntimeInput = {
    where: DimDowntimeReasonWhereUniqueInput
    create: XOR<DimDowntimeReasonCreateWithoutDowntimeInput, DimDowntimeReasonUncheckedCreateWithoutDowntimeInput>
  }

  export type FactProductionCreateWithoutDowntimeInput = {
    dateId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutProductionInput
    product: DimProductCreateNestedOneWithoutProductionInput
    shift: DimShiftCreateNestedOneWithoutProductionInput
    scrap?: FactScrapCreateNestedManyWithoutProductionInput
  }

  export type FactProductionUncheckedCreateWithoutDowntimeInput = {
    id?: number
    dateId: number
    shiftId: number
    equipmentId: number
    productId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    scrap?: FactScrapUncheckedCreateNestedManyWithoutProductionInput
  }

  export type FactProductionCreateOrConnectWithoutDowntimeInput = {
    where: FactProductionWhereUniqueInput
    create: XOR<FactProductionCreateWithoutDowntimeInput, FactProductionUncheckedCreateWithoutDowntimeInput>
  }

  export type DimEquipmentUpsertWithoutDowntimeInput = {
    update: XOR<DimEquipmentUpdateWithoutDowntimeInput, DimEquipmentUncheckedUpdateWithoutDowntimeInput>
    create: XOR<DimEquipmentCreateWithoutDowntimeInput, DimEquipmentUncheckedCreateWithoutDowntimeInput>
    where?: DimEquipmentWhereInput
  }

  export type DimEquipmentUpdateToOneWithWhereWithoutDowntimeInput = {
    where?: DimEquipmentWhereInput
    data: XOR<DimEquipmentUpdateWithoutDowntimeInput, DimEquipmentUncheckedUpdateWithoutDowntimeInput>
  }

  export type DimEquipmentUpdateWithoutDowntimeInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workCenter?: DimWorkCenterUpdateOneRequiredWithoutEquipmentNestedInput
    production?: FactProductionUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentUncheckedUpdateWithoutDowntimeInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workCenterId?: IntFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    production?: FactProductionUncheckedUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type DimDowntimeReasonUpsertWithoutDowntimeInput = {
    update: XOR<DimDowntimeReasonUpdateWithoutDowntimeInput, DimDowntimeReasonUncheckedUpdateWithoutDowntimeInput>
    create: XOR<DimDowntimeReasonCreateWithoutDowntimeInput, DimDowntimeReasonUncheckedCreateWithoutDowntimeInput>
    where?: DimDowntimeReasonWhereInput
  }

  export type DimDowntimeReasonUpdateToOneWithWhereWithoutDowntimeInput = {
    where?: DimDowntimeReasonWhereInput
    data: XOR<DimDowntimeReasonUpdateWithoutDowntimeInput, DimDowntimeReasonUncheckedUpdateWithoutDowntimeInput>
  }

  export type DimDowntimeReasonUpdateWithoutDowntimeInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isPlanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectsOee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFailure?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DimDowntimeReasonUncheckedUpdateWithoutDowntimeInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isPlanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectsOee?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFailure?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FactProductionUpsertWithoutDowntimeInput = {
    update: XOR<FactProductionUpdateWithoutDowntimeInput, FactProductionUncheckedUpdateWithoutDowntimeInput>
    create: XOR<FactProductionCreateWithoutDowntimeInput, FactProductionUncheckedCreateWithoutDowntimeInput>
    where?: FactProductionWhereInput
  }

  export type FactProductionUpdateToOneWithWhereWithoutDowntimeInput = {
    where?: FactProductionWhereInput
    data: XOR<FactProductionUpdateWithoutDowntimeInput, FactProductionUncheckedUpdateWithoutDowntimeInput>
  }

  export type FactProductionUpdateWithoutDowntimeInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutProductionNestedInput
    product?: DimProductUpdateOneRequiredWithoutProductionNestedInput
    shift?: DimShiftUpdateOneRequiredWithoutProductionNestedInput
    scrap?: FactScrapUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateWithoutDowntimeInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scrap?: FactScrapUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type DimProductCreateWithoutScrapInput = {
    code: string
    name: string
    family?: string | null
    unitOfMeasure?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: bigint | number | null
    production?: FactProductionCreateNestedManyWithoutProductInput
  }

  export type DimProductUncheckedCreateWithoutScrapInput = {
    id?: number
    code: string
    name: string
    family?: string | null
    unitOfMeasure?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: bigint | number | null
    production?: FactProductionUncheckedCreateNestedManyWithoutProductInput
  }

  export type DimProductCreateOrConnectWithoutScrapInput = {
    where: DimProductWhereUniqueInput
    create: XOR<DimProductCreateWithoutScrapInput, DimProductUncheckedCreateWithoutScrapInput>
  }

  export type FactProductionCreateWithoutScrapInput = {
    dateId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    equipment: DimEquipmentCreateNestedOneWithoutProductionInput
    product: DimProductCreateNestedOneWithoutProductionInput
    shift: DimShiftCreateNestedOneWithoutProductionInput
    downtime?: FactDowntimeCreateNestedManyWithoutProductionInput
  }

  export type FactProductionUncheckedCreateWithoutScrapInput = {
    id?: number
    dateId: number
    shiftId: number
    equipmentId: number
    productId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutProductionInput
  }

  export type FactProductionCreateOrConnectWithoutScrapInput = {
    where: FactProductionWhereUniqueInput
    create: XOR<FactProductionCreateWithoutScrapInput, FactProductionUncheckedCreateWithoutScrapInput>
  }

  export type DimProductUpsertWithoutScrapInput = {
    update: XOR<DimProductUpdateWithoutScrapInput, DimProductUncheckedUpdateWithoutScrapInput>
    create: XOR<DimProductCreateWithoutScrapInput, DimProductUncheckedCreateWithoutScrapInput>
    where?: DimProductWhereInput
  }

  export type DimProductUpdateToOneWithWhereWithoutScrapInput = {
    where?: DimProductWhereInput
    data: XOR<DimProductUpdateWithoutScrapInput, DimProductUncheckedUpdateWithoutScrapInput>
  }

  export type DimProductUpdateWithoutScrapInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    family?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    production?: FactProductionUpdateManyWithoutProductNestedInput
  }

  export type DimProductUncheckedUpdateWithoutScrapInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    family?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfMeasure?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetCycleTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    production?: FactProductionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type FactProductionUpsertWithoutScrapInput = {
    update: XOR<FactProductionUpdateWithoutScrapInput, FactProductionUncheckedUpdateWithoutScrapInput>
    create: XOR<FactProductionCreateWithoutScrapInput, FactProductionUncheckedCreateWithoutScrapInput>
    where?: FactProductionWhereInput
  }

  export type FactProductionUpdateToOneWithWhereWithoutScrapInput = {
    where?: FactProductionWhereInput
    data: XOR<FactProductionUpdateWithoutScrapInput, FactProductionUncheckedUpdateWithoutScrapInput>
  }

  export type FactProductionUpdateWithoutScrapInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutProductionNestedInput
    product?: DimProductUpdateOneRequiredWithoutProductionNestedInput
    shift?: DimShiftUpdateOneRequiredWithoutProductionNestedInput
    downtime?: FactDowntimeUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateWithoutScrapInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downtime?: FactDowntimeUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type DimEquipmentCreateWithoutMaintenanceInput = {
    code: string
    name: string
    type?: string | null
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    workCenter: DimWorkCenterCreateNestedOneWithoutEquipmentInput
    production?: FactProductionCreateNestedManyWithoutEquipmentInput
    downtime?: FactDowntimeCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentUncheckedCreateWithoutMaintenanceInput = {
    id?: number
    code: string
    name: string
    type?: string | null
    workCenterId: number
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    production?: FactProductionUncheckedCreateNestedManyWithoutEquipmentInput
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutEquipmentInput
    sensorEvents?: FactSensorEventUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentCreateOrConnectWithoutMaintenanceInput = {
    where: DimEquipmentWhereUniqueInput
    create: XOR<DimEquipmentCreateWithoutMaintenanceInput, DimEquipmentUncheckedCreateWithoutMaintenanceInput>
  }

  export type DimEquipmentUpsertWithoutMaintenanceInput = {
    update: XOR<DimEquipmentUpdateWithoutMaintenanceInput, DimEquipmentUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<DimEquipmentCreateWithoutMaintenanceInput, DimEquipmentUncheckedCreateWithoutMaintenanceInput>
    where?: DimEquipmentWhereInput
  }

  export type DimEquipmentUpdateToOneWithWhereWithoutMaintenanceInput = {
    where?: DimEquipmentWhereInput
    data: XOR<DimEquipmentUpdateWithoutMaintenanceInput, DimEquipmentUncheckedUpdateWithoutMaintenanceInput>
  }

  export type DimEquipmentUpdateWithoutMaintenanceInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workCenter?: DimWorkCenterUpdateOneRequiredWithoutEquipmentNestedInput
    production?: FactProductionUpdateManyWithoutEquipmentNestedInput
    downtime?: FactDowntimeUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentUncheckedUpdateWithoutMaintenanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workCenterId?: IntFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    production?: FactProductionUncheckedUpdateManyWithoutEquipmentNestedInput
    downtime?: FactDowntimeUncheckedUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentCreateWithoutSensorEventsInput = {
    code: string
    name: string
    type?: string | null
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    workCenter: DimWorkCenterCreateNestedOneWithoutEquipmentInput
    production?: FactProductionCreateNestedManyWithoutEquipmentInput
    downtime?: FactDowntimeCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentUncheckedCreateWithoutSensorEventsInput = {
    id?: number
    code: string
    name: string
    type?: string | null
    workCenterId: number
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    production?: FactProductionUncheckedCreateNestedManyWithoutEquipmentInput
    downtime?: FactDowntimeUncheckedCreateNestedManyWithoutEquipmentInput
    maintenance?: FactMaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type DimEquipmentCreateOrConnectWithoutSensorEventsInput = {
    where: DimEquipmentWhereUniqueInput
    create: XOR<DimEquipmentCreateWithoutSensorEventsInput, DimEquipmentUncheckedCreateWithoutSensorEventsInput>
  }

  export type DimUnitCreateWithoutSensorEventsInput = {
    code: string
    name: string
    type: string
  }

  export type DimUnitUncheckedCreateWithoutSensorEventsInput = {
    id?: number
    code: string
    name: string
    type: string
  }

  export type DimUnitCreateOrConnectWithoutSensorEventsInput = {
    where: DimUnitWhereUniqueInput
    create: XOR<DimUnitCreateWithoutSensorEventsInput, DimUnitUncheckedCreateWithoutSensorEventsInput>
  }

  export type DimEquipmentUpsertWithoutSensorEventsInput = {
    update: XOR<DimEquipmentUpdateWithoutSensorEventsInput, DimEquipmentUncheckedUpdateWithoutSensorEventsInput>
    create: XOR<DimEquipmentCreateWithoutSensorEventsInput, DimEquipmentUncheckedCreateWithoutSensorEventsInput>
    where?: DimEquipmentWhereInput
  }

  export type DimEquipmentUpdateToOneWithWhereWithoutSensorEventsInput = {
    where?: DimEquipmentWhereInput
    data: XOR<DimEquipmentUpdateWithoutSensorEventsInput, DimEquipmentUncheckedUpdateWithoutSensorEventsInput>
  }

  export type DimEquipmentUpdateWithoutSensorEventsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workCenter?: DimWorkCenterUpdateOneRequiredWithoutEquipmentNestedInput
    production?: FactProductionUpdateManyWithoutEquipmentNestedInput
    downtime?: FactDowntimeUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentUncheckedUpdateWithoutSensorEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workCenterId?: IntFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    production?: FactProductionUncheckedUpdateManyWithoutEquipmentNestedInput
    downtime?: FactDowntimeUncheckedUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type DimUnitUpsertWithoutSensorEventsInput = {
    update: XOR<DimUnitUpdateWithoutSensorEventsInput, DimUnitUncheckedUpdateWithoutSensorEventsInput>
    create: XOR<DimUnitCreateWithoutSensorEventsInput, DimUnitUncheckedCreateWithoutSensorEventsInput>
    where?: DimUnitWhereInput
  }

  export type DimUnitUpdateToOneWithWhereWithoutSensorEventsInput = {
    where?: DimUnitWhereInput
    data: XOR<DimUnitUpdateWithoutSensorEventsInput, DimUnitUncheckedUpdateWithoutSensorEventsInput>
  }

  export type DimUnitUpdateWithoutSensorEventsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DimUnitUncheckedUpdateWithoutSensorEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DimAreaCreateManySiteInput = {
    id?: number
    code: string
    name: string
  }

  export type DimShiftCreateManySiteInput = {
    id?: number
    name: string
    startTime: string
    endTime: string
    breakMinutes?: number | null
    isActive?: boolean | null
  }

  export type DimAreaUpdateWithoutSiteInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workCenters?: DimWorkCenterUpdateManyWithoutAreaNestedInput
  }

  export type DimAreaUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workCenters?: DimWorkCenterUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type DimAreaUncheckedUpdateManyWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DimShiftUpdateWithoutSiteInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    production?: FactProductionUpdateManyWithoutShiftNestedInput
  }

  export type DimShiftUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    production?: FactProductionUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type DimShiftUncheckedUpdateManyWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DimWorkCenterCreateManyAreaInput = {
    id?: number
    code: string
    name: string
    capacity?: Decimal | DecimalJsLike | number | string | null
    capacityUnit?: string | null
  }

  export type DimWorkCenterUpdateWithoutAreaInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: DimEquipmentUpdateManyWithoutWorkCenterNestedInput
  }

  export type DimWorkCenterUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: DimEquipmentUncheckedUpdateManyWithoutWorkCenterNestedInput
  }

  export type DimWorkCenterUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capacityUnit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DimEquipmentCreateManyWorkCenterInput = {
    id?: number
    code: string
    name: string
    type?: string | null
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installationDate?: Date | string | null
    criticalityLevel?: string | null
    theoreticalRate?: Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DimEquipmentUpdateWithoutWorkCenterInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    production?: FactProductionUpdateManyWithoutEquipmentNestedInput
    downtime?: FactDowntimeUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentUncheckedUpdateWithoutWorkCenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    production?: FactProductionUncheckedUpdateManyWithoutEquipmentNestedInput
    downtime?: FactDowntimeUncheckedUpdateManyWithoutEquipmentNestedInput
    maintenance?: FactMaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    sensorEvents?: FactSensorEventUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type DimEquipmentUncheckedUpdateManyWithoutWorkCenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criticalityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    theoreticalRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactProductionCreateManyEquipmentInput = {
    id?: number
    dateId: number
    shiftId: number
    productId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
  }

  export type FactDowntimeCreateManyEquipmentInput = {
    id?: number
    productionId?: number | null
    reasonId: number
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
  }

  export type FactMaintenanceCreateManyEquipmentInput = {
    id?: number
    workOrderNumber: string
    maintenanceType: string
    startTime: Date | string
    endTime: Date | string
    laborHours?: Decimal | DecimalJsLike | number | string | null
    materialCost?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    createdAt?: Date | string | null
  }

  export type FactSensorEventCreateManyEquipmentInput = {
    eventId?: bigint | number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
    unitId?: number | null
  }

  export type FactProductionUpdateWithoutEquipmentInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: DimProductUpdateOneRequiredWithoutProductionNestedInput
    shift?: DimShiftUpdateOneRequiredWithoutProductionNestedInput
    downtime?: FactDowntimeUpdateManyWithoutProductionNestedInput
    scrap?: FactScrapUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downtime?: FactDowntimeUncheckedUpdateManyWithoutProductionNestedInput
    scrap?: FactScrapUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactDowntimeUpdateWithoutEquipmentInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: DimDowntimeReasonUpdateOneRequiredWithoutDowntimeNestedInput
    production?: FactProductionUpdateOneWithoutDowntimeNestedInput
  }

  export type FactDowntimeUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: NullableIntFieldUpdateOperationsInput | number | null
    reasonId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactDowntimeUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: NullableIntFieldUpdateOperationsInput | number | null
    reasonId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactMaintenanceUpdateWithoutEquipmentInput = {
    workOrderNumber?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    laborHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    materialCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactMaintenanceUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    workOrderNumber?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    laborHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    materialCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactMaintenanceUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    workOrderNumber?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    laborHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    materialCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactSensorEventUpdateWithoutEquipmentInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: DimUnitUpdateOneWithoutSensorEventsNestedInput
  }

  export type FactSensorEventUncheckedUpdateWithoutEquipmentInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FactSensorEventUncheckedUpdateManyWithoutEquipmentInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FactProductionCreateManyProductInput = {
    id?: number
    dateId: number
    shiftId: number
    equipmentId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
  }

  export type FactScrapCreateManyProductInput = {
    id?: number
    productionId: number
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
  }

  export type FactProductionUpdateWithoutProductInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutProductionNestedInput
    shift?: DimShiftUpdateOneRequiredWithoutProductionNestedInput
    downtime?: FactDowntimeUpdateManyWithoutProductionNestedInput
    scrap?: FactScrapUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downtime?: FactDowntimeUncheckedUpdateManyWithoutProductionNestedInput
    scrap?: FactScrapUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactScrapUpdateWithoutProductInput = {
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    production?: FactProductionUpdateOneRequiredWithoutScrapNestedInput
  }

  export type FactScrapUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactScrapUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactProductionCreateManyShiftInput = {
    id?: number
    dateId: number
    equipmentId: number
    productId: number
    orderNumber?: string | null
    startTime: Date | string
    endTime: Date | string
    plannedProductionTime: bigint | number
    operatingTime: bigint | number
    plannedParts: number
    totalPartsProduced: number
    goodParts: number
    scrapParts?: number | null
    reworkParts?: number | null
    operatorId?: string | null
    createdAt?: Date | string | null
  }

  export type FactProductionUpdateWithoutShiftInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutProductionNestedInput
    product?: DimProductUpdateOneRequiredWithoutProductionNestedInput
    downtime?: FactDowntimeUpdateManyWithoutProductionNestedInput
    scrap?: FactScrapUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateWithoutShiftInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downtime?: FactDowntimeUncheckedUpdateManyWithoutProductionNestedInput
    scrap?: FactScrapUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type FactProductionUncheckedUpdateManyWithoutShiftInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedProductionTime?: BigIntFieldUpdateOperationsInput | bigint | number
    operatingTime?: BigIntFieldUpdateOperationsInput | bigint | number
    plannedParts?: IntFieldUpdateOperationsInput | number
    totalPartsProduced?: IntFieldUpdateOperationsInput | number
    goodParts?: IntFieldUpdateOperationsInput | number
    scrapParts?: NullableIntFieldUpdateOperationsInput | number | null
    reworkParts?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactDowntimeCreateManyReasonInput = {
    id?: number
    productionId?: number | null
    equipmentId: number
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
  }

  export type FactDowntimeUpdateWithoutReasonInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutDowntimeNestedInput
    production?: FactProductionUpdateOneWithoutDowntimeNestedInput
  }

  export type FactDowntimeUncheckedUpdateWithoutReasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactDowntimeUncheckedUpdateManyWithoutReasonInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactSensorEventCreateManyUnitInput = {
    eventId?: bigint | number
    equipmentId: number
    eventTs: Date | string
    parameter: string
    value: Decimal | DecimalJsLike | number | string
  }

  export type FactSensorEventUpdateWithoutUnitInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    equipment?: DimEquipmentUpdateOneRequiredWithoutSensorEventsNestedInput
  }

  export type FactSensorEventUncheckedUpdateWithoutUnitInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FactSensorEventUncheckedUpdateManyWithoutUnitInput = {
    eventId?: BigIntFieldUpdateOperationsInput | bigint | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    eventTs?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FactDowntimeCreateManyProductionInput = {
    id?: number
    equipmentId: number
    reasonId: number
    startTime: Date | string
    endTime: Date | string
    downtimeDuration: bigint | number
    comments?: string | null
    createdAt?: Date | string | null
  }

  export type FactScrapCreateManyProductionInput = {
    id?: number
    productId: number
    scrapCode: string
    scrapQty: number
    scrapCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
  }

  export type FactDowntimeUpdateWithoutProductionInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: DimEquipmentUpdateOneRequiredWithoutDowntimeNestedInput
    reason?: DimDowntimeReasonUpdateOneRequiredWithoutDowntimeNestedInput
  }

  export type FactDowntimeUncheckedUpdateWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    reasonId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactDowntimeUncheckedUpdateManyWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    reasonId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeDuration?: BigIntFieldUpdateOperationsInput | bigint | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactScrapUpdateWithoutProductionInput = {
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: DimProductUpdateOneRequiredWithoutScrapNestedInput
  }

  export type FactScrapUncheckedUpdateWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FactScrapUncheckedUpdateManyWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    scrapCode?: StringFieldUpdateOperationsInput | string
    scrapQty?: IntFieldUpdateOperationsInput | number
    scrapCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use DimSiteCountOutputTypeDefaultArgs instead
     */
    export type DimSiteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimSiteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimAreaCountOutputTypeDefaultArgs instead
     */
    export type DimAreaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimAreaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimWorkCenterCountOutputTypeDefaultArgs instead
     */
    export type DimWorkCenterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimWorkCenterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimEquipmentCountOutputTypeDefaultArgs instead
     */
    export type DimEquipmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimEquipmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimProductCountOutputTypeDefaultArgs instead
     */
    export type DimProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimShiftCountOutputTypeDefaultArgs instead
     */
    export type DimShiftCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimShiftCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimDowntimeReasonCountOutputTypeDefaultArgs instead
     */
    export type DimDowntimeReasonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimDowntimeReasonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimUnitCountOutputTypeDefaultArgs instead
     */
    export type DimUnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimUnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FactProductionCountOutputTypeDefaultArgs instead
     */
    export type FactProductionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FactProductionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimSiteDefaultArgs instead
     */
    export type DimSiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimSiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimAreaDefaultArgs instead
     */
    export type DimAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimAreaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimWorkCenterDefaultArgs instead
     */
    export type DimWorkCenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimWorkCenterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimEquipmentDefaultArgs instead
     */
    export type DimEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimEquipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimProductDefaultArgs instead
     */
    export type DimProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimShiftDefaultArgs instead
     */
    export type DimShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimDowntimeReasonDefaultArgs instead
     */
    export type DimDowntimeReasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimDowntimeReasonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimUnitDefaultArgs instead
     */
    export type DimUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimUnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FactProductionDefaultArgs instead
     */
    export type FactProductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FactProductionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FactDowntimeDefaultArgs instead
     */
    export type FactDowntimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FactDowntimeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FactScrapDefaultArgs instead
     */
    export type FactScrapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FactScrapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FactMaintenanceDefaultArgs instead
     */
    export type FactMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FactMaintenanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FactSensorEventDefaultArgs instead
     */
    export type FactSensorEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FactSensorEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditEventDefaultArgs instead
     */
    export type AuditEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataDictionaryDefaultArgs instead
     */
    export type DataDictionaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataDictionaryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataRetentionPolicyDefaultArgs instead
     */
    export type DataRetentionPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataRetentionPolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QueryPerformanceDefaultArgs instead
     */
    export type QueryPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QueryPerformanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataQualityScoresDefaultArgs instead
     */
    export type DataQualityScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataQualityScoresDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemMetricsDefaultArgs instead
     */
    export type SystemMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimDateRangeDefaultArgs instead
     */
    export type DimDateRangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimDateRangeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OntologyTermDefaultArgs instead
     */
    export type OntologyTermArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OntologyTermDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViewOeeDailyDefaultArgs instead
     */
    export type ViewOeeDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViewOeeDailyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViewReliabilitySummaryDefaultArgs instead
     */
    export type ViewReliabilitySummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViewReliabilitySummaryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViewScrapSummaryDefaultArgs instead
     */
    export type ViewScrapSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViewScrapSummaryDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}